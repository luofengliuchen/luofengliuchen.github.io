<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>落风的博客</title>
    <link>http://www.liuschen.com</link>
    <description>落风的博客</description>
    
      <item>
        <title>GPS坐标区域判定2</title>
        <link>http://www.liuschen.com/2017/09/20/gps2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/09/20/gps2.html</guid>
        <pubDate>Wed, 20 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;1.两点之间距离&lt;/h1&gt;

&lt;p&gt;通过手动算法计算：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static double getEarthDistance(double lat1,double lon1,
                             double lat2, double lon2){
    double φ1 = Math.toRadians(lat1);
    double φ2 = Math.toRadians(lat2);
    double Δφ = Math.toRadians(lat2-lat1);
    double Δλ =  Math.toRadians(lon2-lon1);

    double a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ/2) * Math.sin(Δλ/2);

    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    double d = EARTH_RADIUS_KM * c;
    return d;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过android中现成的方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static void computeDistanceAndBearing(double lat1, double lon1,
    double lat2, double lon2, float[] results) {
    // Based on http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf
    // using the &quot;Inverse Formula&quot; (section 4)

    int MAXITERS = 20;
    // Convert lat/long to radians
    lat1 *= Math.PI / 180.0;
    lat2 *= Math.PI / 180.0;
    lon1 *= Math.PI / 180.0;
    lon2 *= Math.PI / 180.0;

    double a = 6378137.0; // WGS84 major axis
    double b = 6356752.3142; // WGS84 semi-major axis
    double f = (a - b) / a;
    double aSqMinusBSqOverBSq = (a * a - b * b) / (b * b);

    double L = lon2 - lon1;
    double A = 0.0;
    double U1 = Math.atan((1.0 - f) * Math.tan(lat1));
    double U2 = Math.atan((1.0 - f) * Math.tan(lat2));

    double cosU1 = Math.cos(U1);
    double cosU2 = Math.cos(U2);
    double sinU1 = Math.sin(U1);
    double sinU2 = Math.sin(U2);
    double cosU1cosU2 = cosU1 * cosU2;
    double sinU1sinU2 = sinU1 * sinU2;

    double sigma = 0.0;
    double deltaSigma = 0.0;
    double cosSqAlpha = 0.0;
    double cos2SM = 0.0;
    double cosSigma = 0.0;
    double sinSigma = 0.0;
    double cosLambda = 0.0;
    double sinLambda = 0.0;

    double lambda = L; // initial guess
    for (int iter = 0; iter &amp;lt; MAXITERS; iter++) {
        double lambdaOrig = lambda;
        cosLambda = Math.cos(lambda);
        sinLambda = Math.sin(lambda);
        double t1 = cosU2 * sinLambda;
        double t2 = cosU1 * sinU2 - sinU1 * cosU2 * cosLambda;
        double sinSqSigma = t1 * t1 + t2 * t2; // (14)
        sinSigma = Math.sqrt(sinSqSigma);
        cosSigma = sinU1sinU2 + cosU1cosU2 * cosLambda; // (15)
        sigma = Math.atan2(sinSigma, cosSigma); // (16)
        double sinAlpha = (sinSigma == 0) ? 0.0 :
            cosU1cosU2 * sinLambda / sinSigma; // (17)
        cosSqAlpha = 1.0 - sinAlpha * sinAlpha;
        cos2SM = (cosSqAlpha == 0) ? 0.0 :
            cosSigma - 2.0 * sinU1sinU2 / cosSqAlpha; // (18)

        double uSquared = cosSqAlpha * aSqMinusBSqOverBSq; // defn
        A = 1 + (uSquared / 16384.0) * // (3)
            (4096.0 + uSquared *
             (-768 + uSquared * (320.0 - 175.0 * uSquared)));
        double B = (uSquared / 1024.0) * // (4)
            (256.0 + uSquared *
             (-128.0 + uSquared * (74.0 - 47.0 * uSquared)));
        double C = (f / 16.0) *
            cosSqAlpha *
            (4.0 + f * (4.0 - 3.0 * cosSqAlpha)); // (10)
        double cos2SMSq = cos2SM * cos2SM;
        deltaSigma = B * sinSigma * // (6)
            (cos2SM + (B / 4.0) *
             (cosSigma * (-1.0 + 2.0 * cos2SMSq) -
              (B / 6.0) * cos2SM *
              (-3.0 + 4.0 * sinSigma * sinSigma) *
              (-3.0 + 4.0 * cos2SMSq)));

        lambda = L +
            (1.0 - C) * f * sinAlpha *
            (sigma + C * sinSigma *
             (cos2SM + C * cosSigma *
              (-1.0 + 2.0 * cos2SM * cos2SM))); // (11)

        double delta = (lambda - lambdaOrig) / lambda;
        if (Math.abs(delta) &amp;lt; 1.0e-12) {
            break;
        }
    }

    float distance = (float) (b * A * (sigma - deltaSigma));
    results[0] = distance;
    if (results.length &amp;gt; 1) {
        float initialBearing = (float) Math.atan2(cosU2 * sinLambda,
            cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
        initialBearing *= 180.0 / Math.PI;
        results[1] = initialBearing;
        if (results.length &amp;gt; 2) {
            float finalBearing = (float) Math.atan2(cosU1 * sinLambda,
                -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);
            finalBearing *= 180.0 / Math.PI;
            results[2] = finalBearing;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;2.判断一点是否在不规则多边形中&lt;/h1&gt;

&lt;p&gt;判断一点是否在多边形中，常用的是射线法，个人觉得也是最简单的一种，因为比较角度和面积都会牵扯到正负的判断，而射线法则不需要。规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;以给定的点为起点，向任意方向做一条射线。如果射线与给定的多边形的交点为奇数则该点在多边形内部（点不再多边形边上且不与顶点重合），为偶数则为点在多边形外（0是偶数）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单单这样看的话，也并不简单，首先应该先建立坐标系，然后取一条过点的射线，列出函数表达式，然后因为已知多边形各各点的坐标，求出每条边的函数，遍历每条边，计算与射线的交点并计算交点是否在多边形的边上。如果在，算作一个交点。最后算出总的交点个数即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;特殊情况：当所选取的射线与一条边重合时，如果点不在重合线段上，算作两个交点，如果在，算作一个交点，并且排除相邻两边的计算，排除以上情况后，如果射线过多边形的一个顶点，那么依旧算作两个交点，并且排除过该顶点的另一条边的计算。其余的按照正常计算即可。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体问题具体分析，gps坐标是地理坐标，是在一个球体上表示，如果求一个点是否在指定图形区域内，如果要在笛卡尔坐标系中计算，就需要将坐标投影到平面上，可以用web墨卡托坐标系，在平面坐标系中求得多边形距离给定点最近的一点的坐标，将此点再次转化为gps坐标，然后计算给定点与该点的距离即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;之所以做两次转化是因为平面坐标系计算距离不准确，而且维度不同误差很大，所以平面坐标系将点到多边形转化为点到点的计算，然后可以在球面坐标系中用现成的方法来计算
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，以上方法还是太麻烦了，因为是应用计算，完全不必要，只需要取一个特殊的射线即可，我取的是 给定点指向北极点（将极点看作无穷远）的射线。那么只需要3步骤即可：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.判断射线是否与多边形边重合&lt;/li&gt;
  &lt;li&gt;2.判断给定点是否与多边形顶点重合&lt;/li&gt;
  &lt;li&gt;3.判断多边形每条边是否与射线相交（遍历，以下是对多边形每条线段的处理）&lt;/li&gt;
  &lt;li&gt;3.1.线段两个端点的纬度如果大于给定点，经度如果一个大于一个小于给定点则相交，记为一个交点。&lt;/li&gt;
  &lt;li&gt;3.2.如果线段两端点经度一个大于一个小于给定点，同时纬度一个大于一个小于给定点，那么就需要通过平行相交的比例关系判断与射线所在直线的交点是否是在射线上。如果在，记为一个交点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体算法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 判断点是否在图形区域内
 * 原理:射线法，取点所在的经线作为射线来判断
 *
 * 特殊情况：
 * 1.射线与n条边重合
 * 2.射线与经过n个顶点
 * @param point 点的经纬度，0/1   latitude/ longitude 纬度/经度
 * @param polygon 多边形的点集合，0/1   latitude/ longitude 纬度/经度
 * */
public static boolean isPointInPolygon(double[] point,double[][] polygon){
    /**参考射线取点所在经线自该点向南极发射的一条射线*/
    int node = 0;
    for (int i = 0; i &amp;lt; polygon.length; i++) {
        int next = i+1;
        if (i==polygon.length-1)
            next = 0;
        /**首先判断边是否与参考经线重合*/
        if(point[1]==polygon[i][1]&amp;amp;&amp;amp;polygon[i][1]==polygon[next][1]){
            if((point[0]&amp;gt;=polygon[i][0]&amp;amp;&amp;amp;point[0]&amp;lt;=polygon[next][0])||(point[0]&amp;lt;=polygon[i][0]&amp;amp;&amp;amp;point[0]&amp;gt;=polygon[next][0])){
                /**在线段内*/
                return true;
            }else if(point[0]&amp;lt;polygon[i][0]&amp;amp;&amp;amp;point[0]&amp;lt;polygon[next][0]){
                /**在线段外的射线上*/
                System.out.println(&quot;~~点在线段延长线上:&quot;+i);
                node+=2;
            }else{
                /**在线段外，并且不在射线上*/
            }
        }else if(point[1]==polygon[i][1]){
            /**判断顶点是否在参考经线之上*/
            if(point[0]==polygon[i][0]){
                /**点与图形顶点重合*/
                return true;
            }else if(point[0]&amp;lt;polygon[i][0]){
                node+=2;
            }
        }else{
            /**判断边是否与射线相交*/

            /**这种计算的先决条件是线段两点必须分布在当前位置点所在经线的两端*/
            if((polygon[i][1]&amp;gt;point[1]&amp;amp;&amp;amp;polygon[next][1]&amp;gt;point[1])||(polygon[i][1]&amp;lt;point[1]&amp;amp;&amp;amp;polygon[next][1]&amp;lt;point[1])){
                /**参考经线不会经过该线段*/
                continue;
            }else{
                /**判断纬度是否需要计算*/
                if(polygon[i][0]&amp;gt;point[0]&amp;amp;&amp;amp; polygon[next][0]&amp;gt;point[0]){
                    System.out.println(&quot;~~纬度判断:&quot;+i);
                    node++;
                }else if(polygon[i][0]&amp;lt;point[0]&amp;amp;&amp;amp; polygon[next][0]&amp;gt;point[0]){
                    /***/
                    double tempLength1 = getDistanceByAndroid(polygon[i][0],polygon[i][1],polygon[i][0],point[1]);
                    double tempLength2 = getDistanceByAndroid(polygon[next][0],polygon[next][1],polygon[next][0],point[1]);
                    /**参考距离*/
                    double tempLength4 = getDistanceByAndroid(point[0],point[1],polygon[next][0],point[1]);

                    double tempLength5 = getDistanceByAndroid(polygon[i][0],point[1],polygon[next][0],point[1]);
                    if((tempLength4/tempLength5)&amp;gt;(tempLength2/(tempLength1+tempLength2))){
                        /**经过一个交点*/
                        System.out.println(&quot;~~夹点判断1:&quot;+i);
                        node++;
                    }
                }else if(polygon[i][0]&amp;gt;point[0]&amp;amp;&amp;amp; polygon[next][0]&amp;lt;point[0]){
                    /***/
                    double tempLength1 = getDistanceByAndroid(polygon[i][0],polygon[i][1],polygon[i][0],point[1]);
                    double tempLength2 = getDistanceByAndroid(polygon[next][0],polygon[next][1],polygon[next][0],point[1]);
                    /**参考距离*/
                    double tempLength3 = getDistanceByAndroid(point[0],point[1],polygon[i][0],point[1]);

                    double tempLength5 = getDistanceByAndroid(polygon[i][0],point[1],polygon[next][0],point[1]);
                    if((tempLength3/tempLength5)&amp;gt;(tempLength1/(tempLength1+tempLength2))){
                        /**经过一个交点*/
                        System.out.println(&quot;~~夹点判断2:&quot;+i);
                        node++;
                    }
                }
                /**
                 * polygon[i][0]&amp;lt;point[0]&amp;amp;&amp;amp; polygon[next][0]&amp;lt;point[0]
                 相交于射线的反向延长线上(最后一种可能，基于性能不做判断)
                 * */
                }
            }
    }
    System.out.println(&quot;~~node:&quot;+node);
    if(node%2==0) return false;
    else return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;3.计算点到多边形的距离&lt;/h1&gt;

&lt;p&gt;直接计算我没有好的方法，我计算的是配合上面判断点是否在多边形内部，然后计算点到各个多边形边的最短距离&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.遍历多边形，得出每条边&lt;/li&gt;
  &lt;li&gt;2.已知给定点到线段端点的长度，以及线段长度，求出点到线段的距离&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法1，已知三边长，求高：&lt;/p&gt;

 	/**&lt;br /&gt;
&lt;pre&gt;&lt;code&gt; * 计算三角上a边上的高
 *@param a a边长
 *@param b b边长
 *@param c c边长
 * */
public static double getTrigCh(double b,double c,double a){
    double p1 = a+c+b;
    double p2 = a+c-b;
    double p3 = b+a-c;
    double p4 = b-a+c;
    double r1 = p1*p2*p3*p4;
    double r2 = Math.sqrt(r1);
    return r2/(2*a);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;算法2，计算点到多边形的距离：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**计算点到多边形之间的距离*/
public static double calculateDistance(double[] point,double[][] polygon){
    double[] distances = new double[polygon.length];
    double[] sideLengths = new double[polygon.length];
    for (int i = 0; i &amp;lt; polygon.length; i++) {
        int next = i+1;
        if (i==polygon.length-1)
            next = 0;
        distances[i] = getDistance(point[0],point[1],polygon[i][0],polygon[i][1]);
        sideLengths[i] = getDistance(polygon[i][0],polygon[i][1],polygon[next][0],polygon[next][1]);
        System.out.println(&quot;~distances[&quot;+i+&quot;]:&quot;+distances[i]);
        System.out.println(&quot;~sideLengths[&quot;+i+&quot;]:&quot;+sideLengths[i]);
    }
    double minDistance = Double.MAX_VALUE;
    for (int i = 0; i &amp;lt; polygon.length; i++) {
        int next = i+1;
        if (i==polygon.length-1)
            next = 0;
        double tampDistance;
        if(distances[i]&amp;gt;distances[next]&amp;amp;&amp;amp;distances[i]&amp;gt;sideLengths[i]){
            tampDistance = distances[next];
        }else if(distances[next]&amp;gt;distances[i]&amp;amp;&amp;amp;distances[next]&amp;gt;sideLengths[i]){
            tampDistance = distances[i];
        }else{
            tampDistance = getTrigCh(distances[i],distances[next],sideLengths[i]);
        }
        System.out.println(&quot;~tampDistance:&quot;+tampDistance);
        minDistance = (minDistance&amp;gt;tampDistance)?tampDistance:minDistance;
    }
    return minDistance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.liuschen.com/code/gpsUtils.html&quot;&gt;更多GPS操作方法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>GPS坐标区域判定1</title>
        <link>http://www.liuschen.com/2017/09/20/gps1.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/09/20/gps1.html</guid>
        <pubDate>Wed, 20 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;相关知识因为总要用到，结果再看时却已经忘的差不多，所以这次温习，记下，备忘。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;地球是一个两极稍扁，赤道略鼓的扁球体&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;坐标系区分&lt;/h1&gt;

&lt;p&gt;首先按坐标类型划分分为:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;地理坐标系(大地坐标系，球面坐标，地理坐标，4326 GCS_WGS_1984,火星坐标和百度坐标属于加偏过的地理坐标)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;投影坐标系(平面坐标，例:102100 WGS_1984_web_mercator_auxiliary_sphere,墨卡托投影坐标系)&lt;/p&gt;

    &lt;p&gt;web_mercator是一个投影坐标系，其参考的基准面是WGS_1984( WGS 1984 是一个长半轴(a)为6378137，短半轴（b）为6356752.314245179 的椭球体，扁率(f)为298.257223563，f=(a-b)/a ),并不是严格意义上的墨卡托投影,&lt;br /&gt;
  Auxiliary Sphere 就是在告知你，这个坐标在投影过程中，将椭球体近似为正球体做投影变换，虽然基准面是WGS 1984 椭球面&lt;br /&gt;
  102100是Esri内部使用ID与之对应EPSG分配的坐标系ID为3857&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中地理坐标系也是一种球面坐标系，是用来定位一点在地球中的位置的。而投影坐标系则是通过点线面来计算长度测算距离面积的。&lt;/p&gt;

&lt;p&gt;通过android手机获取的GPS坐标是经纬度坐标，一般小数位比较长，这是因为做分秒转化时没有除尽导致的，这也说明了Google取到的坐标是时分秒的形式，北京经度都是116。&lt;/p&gt;

&lt;p&gt;时分秒坐标转经纬度坐标：&lt;/p&gt;

&lt;p&gt;经/纬度 = 经/纬度 + 经/纬分/60 + 经/纬秒/3600&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GCJ-02：火星坐标系，我国使用的，所有电子地图必须经过至少一次的加偏

谷歌地图API，高德地图API，腾讯地图API上取到的，都是GCJ-02坐标
百度API上取到的，是BD-09坐标，只适用于百度地图相关产品。
搜狗API上取到的，是搜狗坐标，只适用于搜狗地图相关产品。
谷歌地球，google earth上取到的，是GPS坐标，而且是度分秒形式的经纬度坐标，在国内不允许直接使用。
百度和goole投影选择的都是墨卡托，web_mercator（web墨卡托）是将地球模拟为球体，Spherical Mercator常规墨卡托将地球模拟为椭球体
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;坐标转换&lt;/h1&gt;

&lt;p&gt;坐标转换包括，GPS坐标转火星坐标(中国必须，偏移)，GPS和web墨卡托互相转化(地图显示)，算法，略。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;地图概念区分&lt;/h1&gt;

&lt;p&gt;通常我们使用的定位坐标是GPS坐标，是一种地理坐标，即WGS_1984&lt;/p&gt;

&lt;p&gt;应用到地图中的坐标为平面坐标，即墨卡托坐标系，与上面坐标系不同的是这种坐标系是一种平面坐标系，也就是单位是m或是km&lt;/p&gt;

&lt;p&gt;我再用地图下载器下载的Google地图有未加偏和加偏的地图，这个加偏就是转火星坐标，也就是GCJ-02坐标，这种坐标的本质还是一种地理坐标系，所以还是用度分秒来表示&lt;/p&gt;

&lt;p&gt;arcgis中进行图形判定时会有些转化设置，SpatialReference.create(4326), SpatialReference.create(102100),是将gps坐标转换为地图投影坐标再计算，注意，是由于是图形计算，才需要平面坐标系。&lt;/p&gt;

&lt;p&gt;而我另一篇写的坐标区域判定并不是和arcgis一样纯图形的，是先通过gps来判断内外，然后通过各个点的距离来进行图形计算的，完美绕开了我误解的区域（我曾以为Google的偏移是由于gps转墨卡托坐标引起的）&lt;/p&gt;

&lt;p&gt;参考:&lt;a href=&quot;http://blog.csdn.net/kikitamoon/article/details/46124935&quot;&gt;Web Mercator 公开的小秘密&lt;/a&gt;&lt;br /&gt;
参考:&lt;a href=&quot;http://www.movable-type.co.uk/scripts/latlong.html&quot;&gt;Calculate distance, bearing and more between Latitude/Longitude points&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Kotlin笔记</title>
        <link>http://www.liuschen.com/2017/06/08/kotlin.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/06/08/kotlin.html</guid>
        <pubDate>Thu, 08 Jun 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;初次尝试，安装了IntelliJ IDEA&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;新建Kotlin JVM项目,新建包并新建main.kt&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//sampleStart
fun printSum(a: Int, b: Int): Unit {
    println(&quot;sum of $a and $b is ${a + b}&quot;)
}
//sampleEnd

fun main(args: Array&amp;lt;String&amp;gt;) {
    printSum(-1, 8)
}

fun maxOf(a: Int, b: Int): Int {
    if (a &amp;gt; b) {
        return a
    } else {
        return b
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可见，函数的关键字区别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:fun&lt;/li&gt;
  &lt;li&gt;Python:def&lt;/li&gt;
  &lt;li&gt;Java :没有，直接函数名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数参数和返回值：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:类型都放在后面，如参数args: Array&lt;string&gt;类型在参数后面，“：”隔开&lt;/string&gt;&lt;/li&gt;
  &lt;li&gt;Python:没有类型，直接交给程序自己判断&lt;/li&gt;
  &lt;li&gt;Java :类型在前，参数在后&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回值为空：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:Unit&lt;/li&gt;
  &lt;li&gt;Python:返回值类型是程序判断，不需要声明&lt;/li&gt;
  &lt;li&gt;Java :void&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出语句的不同:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Kotlin:println,可以直接在$后引用变量，如下：&lt;/p&gt;

    &lt;p&gt;fun printSum(a: Int, b: Int) {&lt;br /&gt;
      println(“sum of $a and $b is ${a + b}”)&lt;br /&gt;
  }&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Python:print,通过占位符引入变量，中间由“%”隔开&lt;/li&gt;
  &lt;li&gt;Java :直接通过“+”来拼接字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变量的声明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:val关键字用来定义只读的局部变量，var用来定义可变变量&lt;/li&gt;
  &lt;li&gt;Python:变量不需要声明，自动判断类型&lt;/li&gt;
  &lt;li&gt;Java :变量需要声明，而且有些时候必须有初始值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kotlin中，写法有点像Python，每句程序的结尾不需要写“;”,通过换行符来区分语句。&lt;br /&gt;
但是python中制表符和空格是会区分开，写程序时如果混用是可能会出错的，KotLin&lt;br /&gt;
目前还没有这种尝试，不知会不会一样。&lt;/p&gt;

&lt;p&gt;Kotlin中的条件语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和java一样，而Python则是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if 条件表达式:
	条件语句
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完全是用过换行与缩进来完成语句的书写的。&lt;/p&gt;

&lt;p&gt;Kotlin新定义了一个？，如Int?表示声明的这个类型值可以为null,这个值可以是返回值，也可以为声明的变量。&lt;/p&gt;

&lt;p&gt;java中的instanceof用来判断一个对象是否是一个类的实例，Kotlin直接用“is”来代替，简单直观。如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换。如（看来obj会在obj is String为true时自动转化为String类型）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun getStringLength(obj: Any): Int? {
    if (obj is String) {
        // `obj` 在该条件分支内自动转换成 `String`
        return obj.length
    }
    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型
    return null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for循环：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:for(obj in list){}&lt;/li&gt;
  &lt;li&gt;Python:for obj in list:&lt;/li&gt;
  &lt;li&gt;Java :for(Obj obj:list){}//高级for&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kotlin中的when表达式同Java中的不同，更像是Java中的switch语句（其中的函数赋值也同js中的语法很像，但js是弱类型的脚本语言，而Kotlin是同Java一样的强类型的高级编程语言）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun describe(obj: Any): String =
when (obj) {
    1          -&amp;gt; &quot;One&quot;
    &quot;Hello&quot;    -&amp;gt; &quot;Greeting&quot;
    is Long    -&amp;gt; &quot;Long&quot;
    !is String -&amp;gt; &quot;Not a string&quot;
    else       -&amp;gt; &quot;Unknown&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python能够通过for循环直接遍历字符串，Kotlin不能，但是Kotlin中的区间比Python表达的更简洁:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (x in 1..y+1) {
    println(&quot;fits in range&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检测数字在区间之外用“!in”：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (-1 !in 0..list.lastIndex) {
    println(&quot;-1 is out of range&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;倒序遍历:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (i in 4 downTo 1) print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;步长为2的遍历:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (i in 1..4 step 2) print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要创建一个不包括其结束元素的区间:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (i in 1 until 10) {   // i in [1, 10) 排除了 10
 	println(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在Python遍历区间:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in range(1,99):
	print &quot;%d&quot; % i
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>python笔记2</title>
        <link>http://www.liuschen.com/2017/05/20/Python2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/05/20/Python2.html</guid>
        <pubDate>Sat, 20 May 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;1.安装工具包&lt;/h1&gt;

&lt;p&gt;需要安装pandas_datareader和pandas&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install pandas
pip install pandas_datareader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是会出现错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ImportError: cannot import name PandasError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决办法是更换pandas的版本，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -U pandas==0.19.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换掉了我已经安装的0.20.1版本&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;2.股票代码含义&lt;/h1&gt;

&lt;p&gt;沪市A股票买卖的代码是以600、601或603打头&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;3.爬虫&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html&quot;&gt;BeautifulSoup文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装BeautifulSoup用来解析xml/Html文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install beautifulsoup4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引入项目：from bs4 import BeautifulSoup，使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;soup = BeautifulSoup(getHtml(dstUrl), &#39;html.parser&#39;, from_encoding=&#39;utf-8&#39;)
print soup.find_all(&#39;title&#39;)

soup.find_all(&quot;title&quot;)
# [&amp;lt;title&amp;gt;The Dormouse&#39;s story&amp;lt;/title&amp;gt;]

soup.find_all(&quot;p&quot;, &quot;title&quot;)
# [&amp;lt;p class=&quot;title&quot;&amp;gt;&amp;lt;b&amp;gt;The Dormouse&#39;s story&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;]

soup.find_all(&quot;a&quot;)
# [&amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&amp;gt;Elsie&amp;lt;/a&amp;gt;,
#  &amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt;,
#  &amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;]

soup.find_all(id=&quot;link2&quot;)
# [&amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt;]

import re
soup.find(text=re.compile(&quot;sisters&quot;))

data_soup.find_all(attrs={&quot;data-foo&quot;: &quot;value&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过find_all得到的列表中的HTML段都可以再次应用find,find_all过滤&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;4.数据库通信乱码&lt;/h1&gt;

&lt;p&gt;将爬到的数据写入数据库中，发现有几处编码格式会产生影响：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;py文件编码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;window系统，所以是ascii&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;系统编码&lt;/p&gt;

    &lt;p&gt;import sys&lt;br /&gt;
 reload(sys)&lt;br /&gt;
 sys.setdefaultencoding(‘gbk’)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;连接数据库的编码&lt;/p&gt;

    &lt;p&gt;db = MySQLdb.connect(“ip”,”user”,”pwd”,”house_msg”,charset=”gbk”)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写入字符的编码&lt;/p&gt;

    &lt;p&gt;soup = BeautifulSoup(getHtml(dstUrl), ‘html.parser’, from_encoding=’utf-8’)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库本身的字符集编码&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一开始我将所有都改为utf-8格式（为了适应数据库），但是发现py文件本身是ascii编码格式，根本不能写入数据库，即使将当前文件编码改为utf-8，它的引用文件依然会报这个错误，于是将系统编码改为gbk,可写入，但毫无疑问，数据库中表出现了乱码。最好智能将系统编码和连接数据库的编码以及数据库本身的字符集编码都改为了gbk,乱码问题才解决。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;异常：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;UnicodeEncodeError: &#39;gbk&#39; codec can&#39;t encode character u&#39;\xa0&#39; in position 208: illegal multibyte sequence
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python操作数据库写入时，字符串数据中如果有u’\xa0’将不能正确转码，需要string.replace(u’\xa0’,u’‘)替换掉&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Retrofit浅析-OkHttp-rxjava</title>
        <link>http://www.liuschen.com/2017/05/06/retrofit.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/05/06/retrofit.html</guid>
        <pubDate>Sat, 06 May 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;retrofit-okhttp-rxjava&quot;&gt;1.Retrofit-OkHttp-rxjava&lt;/h1&gt;

&lt;p&gt;首先，主体是retrofit，这种配置低耦合，通过converter来连接模块，retrofit2的连接模块有如下(在studio的仓库中搜索到的最新版本)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.squareup.retrofit2:converter-moshi:2.3.0
com.squareup.retrofit2:converter-scalars:2.3.0
com.squareup.retrofit2:converter-simplexml:2.3.0
com.squareup.retrofit2:converter-wire:2.3.0
com.squareup.retrofit2:converter-java8:2.3.0
com.squareup.retrofit2:converter-jackson:2.3.0
com.squareup.retrofit2:converter-protobuf:2.3.0
com.squareup.retrofit2:converter-guava:2.3.0
com.squareup.retrofit2:converter-gson:2.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同rxjava适配需要导入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.squareup.retrofit2:adapter-rxjava:2.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt;2.资源拦截器&lt;/h1&gt;

&lt;p&gt;BasicParamsInterceptor:这是一个独立的类，github上作者项目:&lt;a href=&quot;https://github.com/jkyeo/okhttp-basicparamsinterceptor&quot;&gt;https://github.com/jkyeo/okhttp-basicparamsinterceptor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用来向请求添加公共的参数，但是实际用，可能是因为一个独立文件，并不好使，没细究。&lt;/p&gt;

&lt;p&gt;因为就是一个普通的拦截器，完全可以自己定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OkHttpClient.Builder builder = new OkHttpClient.Builder();
   		builder.connectTimeout(30, TimeUnit.SECONDS);//连接超时时间
    builder.writeTimeout(30, TimeUnit.SECONDS);//写操作 超时时间
    builder.readTimeout(30, TimeUnit.SECONDS);//读操作超时时间
    builder.interceptors().add(new MyInterceptor());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拦截器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyInterceptor implements okhttp3.Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request.Builder builder = chain.request().newBuilder();
		/**为请求添加头*/
        Request requst = builder.addHeader(&quot;Content-type&quot;, &quot;application/json&quot;).build();
        return chain.proceed(requst);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;retrofit&quot;&gt;3.Retrofit使用&lt;/h1&gt;

&lt;p&gt;基础版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Retrofit retrofit = new Retrofit.Builder()
//加入OkHttpClient.Builder支持，这个是内部默认的，默认使用OkHttpClient
            .client(builder.build())
//加入基本url,最好如此，只到端口，后面‘/不能少’
            .baseUrl(&quot;http://192.168.24.76:8080/&quot;)
            .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Retrofit retrofit = new Retrofit.Builder()
//加入OkHttpClient.Builder支持，这个是内部默认的，默认使用OkHttpClient
            .client(builder.build())
//加入字符串支持
            .addConverterFactory(ScalarsConverterFactory.create())
//加入gson支持
            .addConverterFactory(GsonConverterFactory.create())
//加入rxJava2支持
            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
//加入基本url,最好如此，只到端口，后面‘/不能少’
            .baseUrl(&quot;http://192.168.24.76:8080/&quot;)
            .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;model&quot;&gt;4.请求model&lt;/h1&gt;

&lt;p&gt;Retrofit的参数是通过一个接口的注解来标明，用Java的动态代理来将参数传递进去，很巧妙将参数的定义和参数分开，简化了可见的代码，如下是定义的接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface BlogService {
    @FormUrlEncoded
    @POST(&quot;AndroidService/{id}/android_msg!androidMsg.action&quot;)
    Call&amp;lt;ResponseBody&amp;gt; getBlog(@Path(&quot;id&quot;) int id, @Query(&quot;name&quot;) int name, @Field(&quot;page&quot;) int page);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先知道，post请求方式和get请求方式不同，post是将参数单独编码传递，在URL中是不可见的&lt;/p&gt;

&lt;p&gt;@FormUrlEncoded 和@POST以及参数注解中的@Field是用于定义POST的单独参数编码的，@FormUrlEncoded 和@Field相互依赖，必须同时存在且只能在@POST时才能存在&lt;/p&gt;

&lt;p&gt;@Query定义的是URL中附带的可见参数注解中的是key,参数表示的是value&lt;/p&gt;

&lt;p&gt;发出请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BlogService service = retrofit.create(BlogService.class);
    Call&amp;lt;ResponseBody&amp;gt; call = service.getBlog(2,3,9);
    call.enqueue(new Callback&amp;lt;ResponseBody&amp;gt;() {
        @Override
        public void onResponse(Call&amp;lt;ResponseBody&amp;gt; call, Response&amp;lt;ResponseBody&amp;gt; response) {
            try {
                System.out.println(&quot;成功1:&quot;+new String(response.body().bytes(),&quot;utf-8&quot;));
            } catch (IOException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;成功1.2:&quot;+response.body().contentType());
            System.out.println(&quot;成功1.5:&quot;+response.body().contentLength());
            System.out.println(&quot;成功2:&quot;+response.message());
            System.out.println(&quot;成功3:&quot;+response.toString());
            System.out.println(&quot;成功4:&quot;+response.headers().toString());
            System.out.println(&quot;成功5:&quot;+response.code());
            System.out.println(&quot;成功6:&quot;+response.isSuccessful());
            System.out.println(&quot;成功7:&quot;+response.raw());
        }
        @Override
        public void onFailure(Call&amp;lt;ResponseBody&amp;gt; call, Throwable t) {
            System.out.println(&quot;失败：&quot;+t.toString());
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中可见ResponseBody是一个基础的返回对象，包含了很多东西，以下是测试返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;成功1:{&quot;message&quot;:&quot;success&quot;,&quot;success&quot;:true}
成功1.2:application/json;charset=UTF-8
成功1.5:-1
成功2:OK
成功3:Response{protocol=http/1.1, code=200, message=OK, url=http://192.168.24.76:8080/AndroidService/2/android_msg!androidMsg.action?name=3}
成功4:Server: Apache-Coyote/1.1
 Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
 Date: Tue, 23 May 2017 06:55:27 GMT
成功5:200
成功6:true
成功7:Response{protocol=http/1.1, code=200, message=OK, url=http://192.168.24.76:8080/AndroidService/2/android_msg!androidMsg.action?name=3}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;5.可插拔的的数据转换支持&lt;/h1&gt;

&lt;p&gt;gson支持，当然，需要相应的jar包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addConverterFactory(GsonConverterFactory.create())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将ResponseBody替换成自己定义的返回对象MyResultBean，就会自动解析，不添加上面支持的话会报错（直接down掉）；&lt;/p&gt;

&lt;p&gt;String字符串支持,当然，也需要相应的jar包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.addConverterFactory(ScalarsConverterFactory.create())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将ResponseBody替换成自己定义的返回对象String，就会自动解析，不添加上面支持的话会报错(会走失败的方法):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;失败：java.lang.IllegalStateException: Expected a string but was BEGIN_OBJECT at line 1 column 2 path $
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;rxjava2&quot;&gt;6.RxJava2支持&lt;/h1&gt;

&lt;p&gt;RxJava2是响应式编程框架，因为在Android开发中，请求网络只能在子线程，绘制界面只能在主线程，所以有些操作就需要分开来执行，AsyncTask就是一种解决方案。&lt;/p&gt;

&lt;p&gt;call是retrofit返回的对象，其中的回调方法都是在主线程中执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;call.enqueue(new Callback&amp;lt;String&amp;gt;() {
        @Override
        public void onResponse(Call&amp;lt;String&amp;gt; call, Response&amp;lt;String&amp;gt; response) {
        }
        @Override
        public void onFailure(Call&amp;lt;String&amp;gt; call, Throwable t) {
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加rxjava2支持，将可以把返回对象由原来的call变为Observable，Observable订阅线程执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;observable.subscribeOn(Schedulers.from(Executors.newFixedThreadPool(10)))
            .subscribe(new Observer&amp;lt;String&amp;gt;() {
                @Override
                public void onSubscribe(Disposable d) {

                    System.out.println(&quot;resultBean:&quot;);
                    System.out.println(&quot;当前所在线程为onResponse:&quot;+Thread.currentThread().getName());
                }

                @Override
                public void onNext(String value) {
                    System.out.println(&quot;resultBean:&quot;+value);
                    System.out.println(&quot;当前所在线程为onResponse:&quot;+Thread.currentThread().getName());
                }

                @Override
                public void onError(Throwable e) {
                    System.out.println(&quot;resultBean:&quot;+e.toString());
                    System.out.println(&quot;当前所在线程为onResponse:&quot;+Thread.currentThread().getName());
                }

                @Override
                public void onComplete() {
                    System.out.println(&quot;resultBean:onComplete&quot;);
                    System.out.println(&quot;当前所在线程为onResponse:&quot;+Thread.currentThread().getName());
                }
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中onSubscribe方法在所有方法之前执行，甚至在Okhttp的拦截器之前执行，运行在主线程&lt;/p&gt;

&lt;p&gt;onNext和onerror,onComplete运行在订阅的线程，subscribeOn的传入对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//订阅线程传入的是一个10线程的线程池
Schedulers.from(Executors.newFixedThreadPool(10))
//订阅线程是新开一个线程
Schedulers.newThread()	
/**
订阅线程做io操作，也是新线程，I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。
*/
Schedulers.io()
/**
计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。
*/
Schedulers.computation()
//独立线程：RxSingleScheduler-1
Schedulers.single()
//主线程，会报异常：android.os.NetworkOnMainThreadException
Schedulers.trampoline()
/***/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，如果想要返回的结果在主线程中，就直接用返回的call,如果希望返回的结果订阅在特定子线程，就返回observable对象来使用，rxjava与retrofit结合，observable是被创造好的，不需要重新create，消息也都给定了，只需要定义要发布的线程即可。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>python笔记1</title>
        <link>http://www.liuschen.com/2017/04/25/python.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/04/25/python.html</guid>
        <pubDate>Tue, 25 Apr 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;python语言接近于自然语言，基本语法逻辑和其他语言一样，只是一些小的细节不同，python2.x和python3.x的一些函数也有一些细节的不同。&lt;a href=&quot;http://www.runoob.com/python/&quot;&gt;python2的教程&lt;/a&gt;而我首先用的是python3,所以主要记录一下不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;python3python2&quot;&gt;1.python3和python2差异&lt;/h2&gt;

&lt;p&gt;python3中print后面字符串需要加()&lt;/p&gt;

&lt;p&gt;urllib分为了若干模块，需要分别引用&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2.安装下载&lt;/h2&gt;

&lt;p&gt;选择下载安装最好选择32位的2.x版的Python，原因如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2.x版的存在时间长，教程比较好找，相关blog也很多&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sourceforge.net/projects/mysql-python/?source=typ_redirect&quot;&gt;连接mysql的数据库引擎&lt;/a&gt;，诸如此类的插件库比较好找,换32位的也是因为64位的这个插件支持不好，因为插件是32位的，我安装的mysql也是32位的，避免麻烦&lt;/li&gt;
  &lt;li&gt;PIL是一个图形处理库，也是win32的和数据库连接引擎安装方式一样&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3.正则表达式&lt;/h2&gt;

&lt;p&gt;python的正则表达式主要有3中判断：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;匹配开始位置，如果不匹配返回none：re.match&lt;/li&gt;
  &lt;li&gt;搜索整个字符串:re.search&lt;/li&gt;
  &lt;li&gt;搜索整个字符串并返回一个list:re.findAll&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正则表达式的字符规则不说了，主要需要注意的方面是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;正则表达式前加一个字符’r’&lt;/li&gt;
  &lt;li&gt;正则可以引号嵌套，同时里面可以添加括号
    &lt;ul&gt;
      &lt;li&gt;一个括号的话，查找返回的是括号内的表达式匹配内容&lt;/li&gt;
      &lt;li&gt;多个括号的话，是返回的一个多维列表，列表中每一个对象是一个元组，元组中是对每一个括号内容匹配到的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysql&quot;&gt;4.Mysql数据库&lt;/h2&gt;

&lt;p&gt;数据库操作比较固定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import MySQLdb

db = MySQLdb.connect(&quot;127.0.0.1&quot;,&quot;user&quot;,&quot;pwd&quot;,&quot;数据库名&quot; )

# 使用cursor()方法获取操作游标 

cursor = db.cursor()

# SQL 语句
sql = &quot;&quot;

try:
   # 执行sql语句
   cursor.execute(sql)
   # 提交到数据库执行
   db.commit()
except:
   # 发生错误时回滚
   db.rollback()

# 关闭数据库连接
db.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;oracle&quot;&gt;4.5.连接Oracle数据库&lt;/h2&gt;

&lt;p&gt;下载数据库驱动:&lt;a href=&quot;https://pypi.python.org/pypi/cx_Oracle/5.3&quot;&gt;https://pypi.python.org/pypi/cx_Oracle/5.3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意下载的python版本的位数和驱动的位数以及安装的oracle数据库位数要一致&lt;/p&gt;

&lt;p&gt;我在本机安装的oracle是64位的，而驱动和python都是32位的，所以总是提示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import cx_Oracle
ImportError: DLL load failed: %1 不是有效的 Win32 应用程序。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后搜索下载一个32位的oci.dll放在python\Lib\site-packages下，问题解决。应该是数据库驱动会访问本机中的oci.dll，一般搜索都会在环境变量目录中和本目录中寻找，python\Lib\site-packages是插件安装目录，所以放在该目录下能被顺利访问到。但是又出现另一个问题，运行到调用数据库的程序会报：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cx_Oracle.InterfaceError: Unable to acquire Oracle environment handle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的处理方法是下载instantclient-basic-win32-11.2.0.1.0.zip，这个是连接数据库的客户端，一定要32位的，不然就没意义了。&lt;br /&gt;
然后拷贝其中的oci.dll, oraociei10.dll, oraocci10.dll到site-package中，当然oci.dll要覆盖之前添加的，因为要保证版本一致才行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db=cx_Oracle.connect(&#39;username&#39;,&#39;password&#39;,&#39;127.0.0.1/orcl&#39;,cx_Oracle.SYSDBA)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始IP的部分用的是本机的IP地址，但是却会报异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cx_Oracle.DatabaseError: ORA-12541: TNS:no listener
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将IP地址改为127.0.0.1能正常访问。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;5.常见错误(注意问题)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;IndentationError: unindent does not match any outer indentation level&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面的空格和制表符不能混用，否则就会出现这类问题，写程序时最好将空白的符号显示出来&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;格式化输出字符串”%s”%x,字符串和实际值用%隔开&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AttributeError: ‘module’ object has no attribute ‘XXX’&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;.pyc是Python的字节码文件，如果新建.py文件时，不要与预留关键字和模块名重复，否则引用就有可能出现问题，实际调用的是.pyc文件，所以解决办法将目录中与模块名重复的.py文件重新命名，并且删除生成的.pyc文件，重新编译即可&lt;br /&gt;
* url中带有‘,’的图片urlretrieve下载不了&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;6.多线程使用&lt;/h2&gt;

&lt;p&gt;基础用thread&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;thread.start_new_thread
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用thread的包装threading&lt;/p&gt;

&lt;p&gt;以上两个都是包里面自带的，还可以使用线程池&lt;/p&gt;

&lt;p&gt;python安装目录下有一个script文件夹，里面有包管理工具pip,可以运行如pip install threadpool安装线程池模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;task_pool = threadpool.ThreadPool(10,10,0,10)
param_list = [(({param1:param1},{param2:param2}))]
	requests = threadpool.makeRequests(线程函数, param_list)
	[task_pool.putRequest(req) for req in requests]
task_pool.wait()

def 线程函数(param1,param2):
	return;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接在主线程中是取不到全局定义的变量的，因为语法原因会被作为新的局部变量，所以如果要在子线程中取全局变量需要在其作用域中加全局声明 global，如要用全局变量context,就需要先&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global Context
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;scrapy&quot;&gt;7.使用Scrapy爬网页&lt;/h2&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install Scrapy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完后会有提示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;----------------------------------------
Command &quot;f:\programer2\python27\python.exe -u -c &quot;import setuptools, tokenize;__file__=&#39;c:\\users\\XXX\\appdata\\local
\\temp\\pip-build-98jdcm\\Twisted\\setup.py&#39;;f=getattr(tokenize, &#39;open&#39;, open)(__file__);code=f.read().replace(&#39;\r\n&#39;, &#39;
\n&#39;);f.close();exec(compile(code, __file__, &#39;exec&#39;))&quot; install --record c:\users\luofe\appdata\local\temp\pip-j9ztlc-reco
rd\install-record.txt --single-version-externally-managed --compile&quot; failed with error code 1 in c:\users\luofe\appdata\
local\temp\pip-build-98jdcm\Twisted\
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;似乎是window平台对着个框架有些要求，太麻烦就不配置了，对于我的需求，用多线程自己抓取已经能够满足。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;8.注意&lt;/h2&gt;

&lt;p&gt;空值：None&lt;br /&gt;
空字符：NULL&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;9.图像处理&lt;/h2&gt;

&lt;p&gt;PIL库导入：from PIL import Image, ImageEnhance, ImageDraw,ImageChops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#打开
img = Image.open(&quot;C:\\Users\\luofe\\Pictures\\12.jpg&quot;)
#改变大小
new_img = img.resize((128, 128), Image.BILINEAR) 
#旋转
rot_img = new_img.rotate(45)
#显示
img.show()
#保存
img.save(&quot;name&quot;,&quot;格式&quot;)
#获取尺寸
width, height = img.size  
#绘图，单独开一个图层
draw = ImageDraw.Draw(img)  
draw.line( ( (0,0), (width-1, height-1)), fill=255)
#各种效果
color = ImageEnhance.Color(img)  
color_img = color.enhance(3.0)

sharpness = ImageEnhance.Sharpness(img)  
sharp_img = sharpness.enhance(7.0)

contrast = ImageEnhance.Contrast(img)  
contrast_img = contrast.enhance(2.0)  

brightness = ImageEnhance.Brightness(img)  
bright_img = brightness.enhance(2.0) 

#反相
invert_img = ImageChops.invert(img)
#混合模式，需要两张图
#lighter_image = ImageChops.lighter(image1, image2)
#darker_image = ImageChops.darker(image1, image2)
#difference_image = ImageChops.difference(image1, image2) 
#multiply_image = ImageChops.multiply(image1, image2)
#screen_image = ImageChops.screen(image1, image2)  
#add_image = ImageChops.add(img1, img2, scale, offset)    
#subtract_image = ImageChops.subtract(img1, img2, scale, offset)

#获取像素点
point = img.getpixel((pXX,pYY))
#设置像素点
img.putpixel((pXX,pYY),point)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jupyter-notebook&quot;&gt;10.jupyter notebook&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过pip install jupyter来安装，提示血少C++库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;running install
running build
running build_py
creating build
creating build\lib.win32-2.7
copying scandir.py -&amp;gt; build\lib.win32-2.7
running build_ext
building &#39;_scandir&#39; extension
error: Microsoft Visual C++ 9.0 is required. Get it from http://aka.ms/vcpython27
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载VCForPython27.msi，安装，然后重试，安装成功&lt;/p&gt;

&lt;p&gt;将命令路径添加到环境变量后在cmd窗口键入命令：jupyter notebook，启动会打开一个浏览器文本编辑器，在文本编辑器中可以直接执行代码并生成结果。&lt;/p&gt;

&lt;h2 id=&quot;pythoncaffe&quot;&gt;11.Python与caffe结合&lt;/h2&gt;

&lt;p&gt;下载的caffe是for window版本的，首先，解压，进入目录下Python文件夹中，查看requirement.txt文件夹，根据内容安装依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#和c语言沟通，可以将Python编译成c语言模块使用
Cython&amp;gt;=0.19.2
#Python的一种开源的数值计算扩展，有matlabd的一些功能
numpy&amp;gt;=1.7.1
#也是一种数字计算库
scipy&amp;gt;=0.13.2
#一组用于图像处理的算法的集合，是Python下的一种图形库
scikit-image&amp;gt;=0.9.3
#是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。有点类似MATLAB中的统计图。
matplotlib&amp;gt;=1.3.1
#一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。
ipython&amp;gt;=3.0.0
#HDF5持久化存储的Python版本
h5py&amp;gt;=2.2.0
#一个键值对数据库
leveldb&amp;gt;=0.191
#NetworkX是一个用Python语言开发的图论与复杂网络建模工具，内置了常用的图与复杂网络分析算法，可以方便的进行复杂网络数据分析、仿真建模等工作。
networkx&amp;gt;=1.8.1
#python测试框架
nose&amp;gt;=1.3.0
#Pandas是python的一个数据分析包
pandas&amp;gt;=0.12.0
#python时间处理工具类
python-dateutil&amp;gt;=1.4,&amp;lt;2
#将文件读取到内存，主要用来读取配置文件
protobuf&amp;gt;=2.5.0
#用来解析命令行参数的库
python-gflags&amp;gt;=2.0
#L是一个Python的YAML解析器
pyyaml&amp;gt;=3.10
#PIL图形库
Pillow&amp;gt;=2.3.0
#画图，数据分析的依赖库
six&amp;gt;=1.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是通过&lt;strong&gt;pip install [soft_name]&lt;/strong&gt;，可以直接执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Freemarker基本使用</title>
        <link>http://www.liuschen.com/2017/04/20/Freemarker.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/04/20/Freemarker.html</guid>
        <pubDate>Thu, 20 Apr 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;freemarker&quot;&gt;Freemarker&lt;/h2&gt;

&lt;p&gt;导入Freemarker的jar包&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;生成Java代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 生成Java代码
 * */
public static void generateJavaCode(){
	

	String templateFile = &quot;src/demo_java.ftl&quot;;
	String targetFile = &quot;src/com/luofeng/Person.java&quot;;
	
	Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();

	map.put(&quot;packageName&quot;, &quot;com.luofeng&quot;);
	map.put(&quot;className&quot;, &quot;Person&quot;);
	map.put(&quot;author&quot;, &quot;luofeng&quot;);

	
    List&amp;lt;Attribute&amp;gt; attr_list = new ArrayList&amp;lt;Attribute&amp;gt;();
    attr_list.add(new Attribute(&quot;id&quot;, &quot;Long&quot;));
    attr_list.add(new Attribute(&quot;name&quot;, &quot;String&quot;));
    attr_list.add(new Attribute(&quot;age&quot;, &quot;Integer&quot;));
    attr_list.add(new Attribute(&quot;hobby&quot;, &quot;List&amp;lt;String&amp;gt;&quot;));

    map.put(&quot;attrs&quot;, attr_list);
    
    Configuration configuration = new Configuration();
	
	try {
		Template template = configuration.getTemplate(templateFile);
		template.setEncoding(&quot;UTF-8&quot;);
		Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(targetFile), &quot;UTF-8&quot;));  
        template.process(map, out);
        out.flush();
        out.close();
	} catch (IOException e) {
		e.printStackTrace();
	} catch (TemplateException e) {
		e.printStackTrace();
	}
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java的ftl模板文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package ${packageName};

import java.util.List;

/**
 *  @author ${author}
 */
public class ${className} {
    &amp;lt;#list attrs as attr&amp;gt; 
    private ${attr.value!&quot;meizhi&quot;} ${attr.name};
    &amp;lt;/#list&amp;gt;

    &amp;lt;#list attrs as attr&amp;gt;
    public void set${attr.name?cap_first}(${attr.value!&quot;meizhi&quot;} ${attr.name}){
        this.${attr.name} = ${attr.name};
    }
    public ${attr.value!&quot;meizhi&quot;} get${attr.name?cap_first}(){
        return this.${attr.name};
    }

    &amp;lt;/#list&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;Welcome ${user!&quot;Anonymous&quot;}!&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以为替换的变量设置默认值，因为变量为空会直接崩溃掉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if user??&amp;gt;&amp;lt;h1&amp;gt;Welcome ${user}!&amp;lt;/h1&amp;gt;&amp;lt;/#if&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以判断变量是否存在，不存在的话会忽略掉整个代码段&lt;/p&gt;

&lt;h2 id=&quot;html&quot;&gt;生成Html代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 生成Html代码
 * */
public void generateHtmlCode(){
	String templateFile = &quot;src/demo_html.ftl&quot;;
	String targetFile = &quot;src/html.html&quot;;
	
	Map map = new HashMap&amp;lt;String, String&amp;gt;();
	map.put(&quot;message&quot;, &quot;hello world&quot;);
	map.put(&quot;name&quot;, &quot;java小强&quot;);
	
	Configuration configuration = new Configuration();
	
	try {
		Template template = configuration.getTemplate(templateFile);
		template.setEncoding(&quot;UTF-8&quot;);
		Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(targetFile), &quot;UTF-8&quot;));  
        template.process(map, out);
        out.flush();
        out.close();
	} catch (IOException e) {
		e.printStackTrace();
	} catch (TemplateException e) {
		e.printStackTrace();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的ftl模板&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;  
  &amp;lt;head&amp;gt;  
        &amp;lt;title&amp;gt;freemarker是什么&amp;lt;/title&amp;gt;  
    &amp;lt;/head&amp;gt;  
    &amp;lt;body&amp;gt;  
        &amp;lt;h1&amp;gt;${message},${name}&amp;lt;/h1&amp;gt;  
    &amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，在代码中我设置的编码格式是UTF-8,但是eclipse默认打开文件的编码格式可能是gbk,如果这个全局值不修改，直接打开生成的文件就会乱码，位置是在：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window-&amp;gt;Preferences-&amp;gt;General-&amp;gt;Workspace-&amp;gt;Text file encoding
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>GIT配置</title>
        <link>http://www.liuschen.com/2017/04/03/git2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/04/03/git2.html</guid>
        <pubDate>Mon, 03 Apr 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一直以来，用git和SVN都是懂得基本操作就行了，会克隆推送提交什么的，一直缺少一个全局性的把握，所以一旦设置出现问题就手足无措，即使知道了解决方法，不常用的知识往往也易于忘记。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;git的配置分为，局部，全局和系统，作用域不同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] name [value [value_regex]]
git config [&amp;lt;file-option&amp;gt;] [type] --add name value
git config [&amp;lt;file-option&amp;gt;] [type] --replace-all name value [value_regex]
git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] --get name [value_regex]
git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] --get-all name [value_regex]
git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] --get-regexp name_regex [value_regex]
git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] --get-urlmatch name URL
git config [&amp;lt;file-option&amp;gt;] --unset name [value_regex]
git config [&amp;lt;file-option&amp;gt;] --unset-all name [value_regex]
git config [&amp;lt;file-option&amp;gt;] --rename-section old_name new_name
git config [&amp;lt;file-option&amp;gt;] --remove-section name
git config [&amp;lt;file-option&amp;gt;] [-z|--null] -l | --list
git config [&amp;lt;file-option&amp;gt;] --get-color name [default]
git config [&amp;lt;file-option&amp;gt;] --get-colorbool name [stdout-is-tty]
git config [&amp;lt;file-option&amp;gt;] -e | --edit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;file-option&gt;就是作用域&lt;/file-option&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; --global              use global config file（全局）
--system              use system config file（系统）
--local               use repository config file（局部）
-f, --file &amp;lt;file&amp;gt;     use given config file（自定义）
--blob &amp;lt;blob-id&amp;gt;      read config from given blob object（自定义）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;例子&lt;/h3&gt;

&lt;p&gt;1.查看仓库配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config -l[-list]
git config –-local -l
git config –-global -l
git config –-system -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.添加配置(键和值不可缺少)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config –-local --add name value
git config –-global --add name value
git config –-system --add name value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.修改配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config –-local  name value
git config –-global  name value
git config –-system  name value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.删除配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config –-local  --unset name
git config –-global  --unset name
git config –-system  --unset name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候修改的时候会提示找不到修改项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: key does not contain a section: –-global[local]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能是文中”–“字符编码的问题，换一种再试&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我系统上没有配置系统配置，但是按照一般套路应该是：&lt;br /&gt;
&lt;strong&gt;系统配置&amp;gt;全局配置&amp;gt;局部配置&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;所以如果要在不同地址分别配置不同库地址，就不要再设置全局地址，否则会被覆盖（主要是针对图形化的客户端），也比较混乱&lt;/p&gt;
&lt;/blockquote&gt;

</description>
      </item>
    
      <item>
        <title>Android反编译smali文件的修改</title>
        <link>http://www.liuschen.com/2017/03/31/smali.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/31/smali.html</guid>
        <pubDate>Fri, 31 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前提到过Android的反编译，知道了Android的apk反编译后依然是一个完整的项目。资源文件易于修改，不提了，这里主要记录一下smali文件的一些特性和修改方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;smali文件是Dalvik虚拟机的指令码，和汇编文件有点像。&lt;/p&gt;

&lt;p&gt;进入到smali包下面,往往会发现诸如R$id.smali等R$*.smali格式的文件，这是自动生成的R文件，也就是资源映射文件，这些文件一旦编译好都是死的，没法变，所以不到万不得已不要smali码和资源文件一起添加，太麻烦。&lt;/p&gt;

&lt;p&gt;包里面的smali文件都是一个名字可以对应多个文件，这是将写在Java中的内部类拆分的结果。后面用${数字}来区分，也可以是${数字}${数字}表示内部类的内部类，只不过这样增加代码复杂度的写法不多见而已。&lt;/p&gt;

&lt;p&gt;然后就可以修改smali码了，需要注意两点:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;了解指令码的含义（&lt;a href=&quot;http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html&quot;&gt;Dalvik操作指令&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;注意代码中的汉字字符会转成Unicode码，所以添加需要将汉字字符会转成Unicode码(&lt;a href=&quot;http://www.cnblogs.com/mq0036/p/4007452.html&quot;&gt;如何转&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里我主要修改一个Handler的内部，它的头如下，这也是所有内部类的共性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.class L该文件的完整路径名;
.super Landroid/os/Handler(父类);
.source &quot;原始从属的Java类.java&quot;

# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = L该文件原始从属的Java类的完整路径名(在哪个类里面定义就是那个类);
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x0
    name = null
.end annotation

# instance fields
.field final synthetic this$0:L该文件原始从属的Java类的完整路径名;

# direct methods
.method constructor &amp;lt;init&amp;gt;(L该文件原始从属的Java类的完整路径名;)V
.locals 0

.prologue
.line 1
iput-object p1, p0, L该文件的完整路径名;-&amp;gt;this$0:L该文件原始从属的Java类的完整路径名;

.line 278
invoke-direct {p0}, Landroid/os/Handler;-&amp;gt;&amp;lt;init&amp;gt;()V

return-void
.end method
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能单看没什么用，还是不能理解，就需要自己写些例子，生成apk反编译对比看看，就会发现规律&lt;/p&gt;

&lt;p&gt;.field故名思议就是变量，而且一般是全局的&lt;/p&gt;

&lt;p&gt;.method和end method之间是方法体，.method constructor &lt;init&gt;表示是该handler内部类的构造方法&lt;/init&gt;&lt;/p&gt;

&lt;p&gt;一个字符串常量v2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const-string v2, &quot;SOMETHING&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建一个对象并存到v4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new-instance v4, L对象完整路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法(这个是要结果的):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invoke-virtual {v1, v2}, Ljava/lang/String;-&amp;gt;equals(Ljava/lang/Object;)Z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法后将结果保存到v2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;move-result-object v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法(这个不要结果，是用来初始化v4这个内部类对象的，v6存储的是默认内部类所属外部类对象，v2存储的是外部类的一个final修饰的参数，都不是正经传入的参数，是编译器处理的结果)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invoke-direct {v4, v6, v2}, Lv4存储的实例对应的类的路径;-&amp;gt;&amp;lt;init&amp;gt;(Lv6存储的实例对应的类的路径;Ljava/lang/String;)V
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;重新打包时经常有错误报v数字不在v1-v15范围内(&lt;a href=&quot;http://www.aichengxu.com/other/2553264.htm&quot;&gt;reason&lt;/a&gt;)，又因为v可以反复使用，所以这个应该是如汇编一样是对寄存器的操作，v1-v15表示寄存器，所以只要明白了类是如何取到的，其他的就好理解了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;if结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if-eqz v1, :cond_1
.
.
:cond_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外部的final定义的对象，内部类是如何取到实例的？首先做如下定义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.local v2, &quot;对象名(在Java中自己起的)&quot;:Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用上面的invoke-direct方法将v2塞进去,然后再内部类中的构造方法里就会有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iput-object p2, p0, L该类完整路径名;-&amp;gt;val$对象名:Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在具体方法中会通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iget-object v2, p0, L该类完整路径名;-&amp;gt;val$对象名:Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到该值，即存储在v2中&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是通过查找字符串来定位修改的大致位置的，然后通过if结构的关键字cond来确定最终的修改坐标，比较粗浅，因为关于smali文件我还有许多不明白的地方，日后再有需要再去详细了解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;还有一点，我发现.line {数字}这种似乎只是记录行号，具体作用不明，随便添加删除也看不出影响，所以修改代码时不用考虑就好。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
      </item>
    
      <item>
        <title>Bootstrap</title>
        <link>http://www.liuschen.com/2017/03/28/Bootstrap.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/28/Bootstrap.html</guid>
        <pubDate>Tue, 28 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://v3.bootcss.com/getting-started/#download&quot;&gt;参考bootstrap起步文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;bootstrap&quot;&gt;下载bootstrap并解压&lt;/h2&gt;

&lt;h2 id=&quot;grunt&quot;&gt;安装编译系统Grunt&lt;/h2&gt;

&lt;p&gt;首先下载并安装 node.js，之前安装cordova时安装过了，省略。&lt;/p&gt;

&lt;p&gt;按装grunt-cli ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入 /bootstrap/ 根目录，然后执行 npm install 命令。npm 将读取 package.json 文件并自动安装此文件中列出的所有被依赖的扩展包。&lt;/p&gt;

&lt;p&gt;如果在安装依赖包或者运行 Grunt 命令时遇到了问题，请首先删除 npm 自动生成的 /node_modules/ 目录，然后，再次运行 npm install 命令（这一步需要翻墙不然会有如下错误）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm ERR! Windows_NT 10.0.14393
npm ERR! argv &quot;F:\\programer2\\nodejs\\node.exe&quot; &quot;F:\\programer2\\nodejs\\node_modules\\npm\\bin\\npm-cli.js&quot; &quot;install&quot;
npm ERR! node v6.10.0
npm ERR! npm  v3.10.10
npm ERR! code ELIFECYCLE

npm ERR! phantomjs@1.9.20 install: `node install.js`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the phantomjs@1.9.20 install script &#39;node install.js&#39;.
npm ERR! Make sure you have the latest version of node.js and npm installed.
npm ERR! If you do, this is most likely a problem with the phantomjs package,
npm ERR! not with npm itself.
npm ERR! Tell the author that this fails on your system:
npm ERR!     node install.js
npm ERR! You can get information on how to open an issue for this project with:
npm ERR!     npm bugs phantomjs
npm ERR! Or if that isn&#39;t available, you can get their info via:
npm ERR!     npm owner ls phantomjs
npm ERR! There is likely additional logging output above.

npm ERR! Please include the following file with any support request:
npm ERR!     F:\programer2\bootstrap\bootstrap-3.3.7\npm-debug.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grunt命令运行却没问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt dist （仅编译 CSS 和 JavaScript 文件）
grunt watch （监测文件的改变，并运行指定的 Grunt 任务）
grunt test （运行测试用例）
grunt docs （编译并测试文档中的资源文件）
grunt （重新构建所有内容并运行测试用例）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以编译javascript和css,文件夹下dest文件夹为生成的直接可以在生产环境中使用的js和css代码&lt;/p&gt;

&lt;p&gt;当然，这个dest文件夹里面的内容也可以直接在官网上下载。&lt;/p&gt;

&lt;h2 id=&quot;bootstrap-1&quot;&gt;bootstrap基本模板&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
    &amp;lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&amp;gt;
    &amp;lt;title&amp;gt;Bootstrap 101 Template&amp;lt;/title&amp;gt;

    &amp;lt;!-- Bootstrap --&amp;gt;
    &amp;lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;

    &amp;lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&amp;gt;
    &amp;lt;!-- WARNING: Respond.js doesn&#39;t work if you view the page via file:// --&amp;gt;
    &amp;lt;!--[if lt IE 9]&amp;gt;
      &amp;lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;![endif]--&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;

    &amp;lt;!-- jQuery (necessary for Bootstrap&#39;s JavaScript plugins) --&amp;gt;
    &amp;lt;script src=&quot;js/jquery-3.2.0.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;!-- Include all compiled plugins (below), or include individual files as needed --&amp;gt;
    &amp;lt;script src=&quot;js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bootstrap-2&quot;&gt;bootstrap控件实例学习&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://v3.bootcss.com/components/&quot;&gt;参考中文文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;学习最方便的途径就是做自己的东西，所以我这里写一个介绍某某平台产品的页面&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/bootstrap.html&quot;&gt;例子URL&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;bootstrap-3&quot;&gt;为什么需要编译bootstrap&lt;/h2&gt;

&lt;p&gt;我们知道，js和css和Java代码不同是不需要编译的，但是bootstrap的编译主要是为了生成javascript和css代码；存储bootstrap样式的代码主要写在less中，通过编译可以生成对应的css代码，从而使更改样式变得简单。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>android反编译还原项目指南</title>
        <link>http://www.liuschen.com/2017/03/21/smali2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/21/smali2.html</guid>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Android反编译工具就不说了，之前已经具体说过，只要会用几个功能，就能解出源码，如果恰巧源码没有进行混淆，那么就赚了，理论上可以还原出项目的开发文件的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先举一个例子，以下是原始代码，某个ListView的adapter的getView方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
	public View getView(int position, View convertView, ViewGroup parent) {
		
		if (getCount() == 0) {
			return null;
		}
		ViewHolder holder = null;
		if (convertView == null) {
			holder=new ViewHolder();
			convertView=mInflater.inflate(R.layout.list_item_updownload, null);
			holder.tv1=(TextView) convertView.findViewById(R.id.listitem_1);
			holder.tv2=(TextView) convertView.findViewById(R.id.listitem_2);
			holder.tv3=(TextView) convertView.findViewById(R.id.listitem_3);
			holder.tv4=(TextView) convertView.findViewById(R.id.listitem_4);
			holder.tv5=(TextView) convertView.findViewById(R.id.listitem_5);
			holder.tv6=(TextView) convertView.findViewById(R.id.listitem_6);
			
			convertView.setTag(holder);
			
		} else {
			holder = (ViewHolder) convertView.getTag();
		}
		holder.tv1.setText(mList.get(position).getNum());
		holder.tv2.setText(mList.get(position).getProjectName());
		holder.tv3.setText(mList.get(position).getZypName());
		holder.tv4.setText(mList.get(position).getZuoyedanwei());
		holder.tv5.setText(mList.get(position).getStartTime());
		holder.tv6.setText(mList.get(position).getEndTime());
		return convertView;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是编译成class文件后反解后对应的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public View getView(int paramInt, View paramView, ViewGroup paramViewGroup)
{
  if (getCount() == 0)
    return null;
  DataUploadActivity.ViewHolder localViewHolder;
  if (paramView == null)
  {
    localViewHolder = new DataUploadActivity.ViewHolder(null);
    paramView = this.mInflater.inflate(2130903048, null);
    DataUploadActivity.ViewHolder.access$1(localViewHolder, (TextView)paramView.findViewById(2131492897));
    DataUploadActivity.ViewHolder.access$2(localViewHolder, (TextView)paramView.findViewById(2131492898));
    DataUploadActivity.ViewHolder.access$3(localViewHolder, (TextView)paramView.findViewById(2131492899));
    DataUploadActivity.ViewHolder.access$4(localViewHolder, (TextView)paramView.findViewById(2131492901));
    DataUploadActivity.ViewHolder.access$5(localViewHolder, (TextView)paramView.findViewById(2131492902));
    DataUploadActivity.ViewHolder.access$6(localViewHolder, (TextView)paramView.findViewById(2131492903));
    paramView.setTag(localViewHolder);
  }
  while (true)
  {
    DataUploadActivity.ViewHolder.access$7(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getNum());
    DataUploadActivity.ViewHolder.access$8(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getProjectName());
    DataUploadActivity.ViewHolder.access$9(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getZypName());
    DataUploadActivity.ViewHolder.access$10(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getZuoyedanwei());
    DataUploadActivity.ViewHolder.access$11(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getStartTime());
    DataUploadActivity.ViewHolder.access$12(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getEndTime());
    return paramView;
    localViewHolder = (DataUploadActivity.ViewHolder)paramView.getTag();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出的是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;原始代码的注解不见了&lt;/li&gt;
  &lt;li&gt;资源文件变成了一串数字&lt;/li&gt;
  &lt;li&gt;里面多了很多个$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先来说第三点，因为第三点出现的范围相当广而且需要先进行修改来使项目顺利通过编译。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，当定义一个变量并被赋值，然后再回调方法中被调用，这时由于回调方法内部和定义变量的位置位于不同作用域，所以需要变量前加final修饰，当编译在反编译后的得到的代码将没有final修饰符，该变量作为一个参数传入回调的类中，在类中引用该变量则变为 val$原始类名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此引申，一个回调方法即使没有参数，也会默认传入null，遇到删除就好&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;break的用法，在反编译得到的代码中会遇到break label+数字  的代码，这个其实和goto语句一样是一个跳转语句，千万不要大惊小怪。可见，其实像if这样的条件语句都是翻译成跳转语句执行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;for循环会变成while(true)+if条件判断，if条件语句如果体量过大，会被优化为if-break跳转语句。我遇到的多重嵌套语句，很多都会变成break（这里同goto,因为Java中没有goto,所以用break）+while循环形式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上面例子中的access$数字形式，适用于内部类访问外部类数据成员时，是编译阶段自动生成的&lt;/li&gt;
  &lt;li&gt;switch语句也是有点头疼，反编译出来会变得很错乱，就不要看代码表面的逻辑了，还是会出现一个while循环，而且里面可能有出现的很不可理的return和continue，这是就看对代码上下文理解来整理了，没什么技巧。switch的default会被放在第一个，还有最后的return会被提前&lt;/li&gt;
  &lt;li&gt;还有一个有趣的现象，就是值数字的变量名会被改为诸如i,j,k这种让人混淆的名字。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有诸多小问题，如&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量没有初始化值&lt;/li&gt;
  &lt;li&gt;优化后代码出现大量跟在return或是break后的不可用语句&lt;/li&gt;
  &lt;li&gt;至于资源文件的对照，只能参考反编译出来的R文件批量修改了&lt;/li&gt;
  &lt;li&gt;大多注解都是对应的编译阶段，还有泛型就是为了编译而生的，如果因为缺少而报错需要加上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里还有一个很重要的问题，有时候一大段代码会反编译不出来，反编译的结果是注释掉的代码块，然后提示说是这一段代码有错误。那么，这一大段代码就只有自己根据上下文的逻辑自己写了。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>一些web相关东西(摘自网络)</title>
        <link>http://www.liuschen.com/2017/03/20/something.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/20/something.html</guid>
        <pubDate>Mon, 20 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;js&quot;&gt;1.js框架&lt;/h2&gt;

&lt;h3 id=&quot;bootstrap&quot;&gt;bootstrap&lt;/h3&gt;

&lt;h3 id=&quot;propeller&quot;&gt;Propeller&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Propeller 是一个基于 Bootstrap 和 Google’s Material Design 语言的 CSS 组件框架。它包含 25 个组件，响应敏捷，具有典型 Material Design 动画的特点。该项目可以作为 Bootstrap 主题下载，也可作为完整的框架或独立的组件下载。
BaguetteBox
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;baguetteboxjs&quot;&gt;baguetteBox.js&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;baguetteBox.js 是一个简单简单、易用的 JavaScript lightbox库，它具有一下特点：
纯 JavaScript 实现，无需依赖其他库
支持触摸屏设备手势操作
支持显示标题（说明）
支持响应式图像
支持CSS3过渡
使用 SVG 按钮，没有多余的文件下载
启用 gzip 压缩后仅 2KB
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;whitestorm&quot;&gt;Whitestorm&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Whitestorm 使用 Three.js 引擎开发 3D 网页应用和游戏，它为普通的 Three.js 任务提供封装，使搭建环境，创建对象，添加物件等操作更简单。官方提供了很好的项目教程，以及与 React 集成的工具。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;animatelo&quot;&gt;Animatelo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Animatelo 是极度流行的 Animate.css 库的端口，它用 Web Animations API 克隆代替 CSS 转换。所有原始的 Animate.css 效果都被重建，但现在的 API 是基于 JavaScript 类而不是 CSS 类。该库轻量且不依赖 jQuery，但在旧版浏览器要求 polyfill。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;fusebox&quot;&gt;FuseBox&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;FuseBox 是一个用于 JavaScript 和 CSS 的捆绑加载器，带有 TypeScript，Sass 等可选的附加组件。它以简洁与性能为主，为 webpack 提供替代方案。相关教程：Angular 2 + TypeScript, React + Babel, Vue.js, Electron 等。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;yargs&quot;&gt;Yargs&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Yargs 框架通过使用 Node.js 构建功能全面的命令行应用，它能轻松配置命令，解析多个参数，并设置快捷方式等，还能自动生成帮助菜单。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;webgradients&quot;&gt;WebGradients&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;WebGradients 含有多种漂亮的渐变色，可在任何 HTML 页面轻松应用。你可在项目网站快速预览可用的渐变色，还能一键复制 CSS 到你的项目中去。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sticky-kit&quot;&gt;Sticky-Kit&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Sticky-kit 是一个 jQuery 插件，它允许你在页面附加元素，设置跟随滚动的侧边栏效果。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;scrolldir&quot;&gt;ScrollDir&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ScrollDir 是一个超轻量无依赖的 JavaScript 库，用以检查滚动条的移动，并根据你的选择元素切换 上/下 数据属性。该项目能给你带来平滑的用户体验。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;svgo&quot;&gt;Svgo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;用以优化 SVG 文件的 Node.js 工具，它将它们从非必要的信息中剥离出来，如，编辑器元数据，注释，隐藏元素等。SVGO 具有基于插件的架构，你可自由选择需要删除和保留的内容。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;storejs&quot;&gt;Store.js&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Store.js 是一个跨浏览器的用于高级本地存储的解决方案，它实现了浏览器的本地存储的 JavaScript 封装 API，不是通过 Cookie 和 Flash 技术实现，而是使用 localStorage、globalStorage 和 userData 行为。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;snarkdown&quot;&gt;Snarkdown&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Snarkdown 是一个用 JavaScript 编写的极简的 Markdown 解析器。它不是功能最全的，但可能是最容易实现的一款解析器。Snarkdown 只有 1Kb 大小，且只有一种方法，适合速成项目。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;unfetch&quot;&gt;Unfetch&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Fetch API 能让开发者更好地处理异步请求，它能在大多数浏览器上受支持，但 fetch() 方法在 IE 浏览器中仍不可用。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;scrollanim&quot;&gt;Scrollanim&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Scrollanim 是使用 CSS3 + JavaScript 实现的用于创建滚动动画的库，应用到元素上后，当此元素出现在浏览器可视区域时便会执行对应的动画。Scrollanim 是 Kissui 的一部分，所以使用 Scrollanim 时需要用到 kissui.css。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;neurojs&quot;&gt;Neurojs&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;用于在浏览器中进行深度学习 JavaScript 框架，可以通过强化学习进行全栈神经网络。演示：Demo app
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;reactjs&quot;&gt;ReactJS&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;用于提高js页面刷新性能
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;2.自动化构建工具&lt;/h2&gt;

&lt;p&gt;Jenkins(Java),jekyll(基于模版轻量级博客系统)&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3.自动化运维工具&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ansible.com.cn/docs/intro.html&quot;&gt;ansible&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4.分布式计算&lt;/h2&gt;

&lt;p&gt;Apache Spark&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>linux网络调试</title>
        <link>http://www.liuschen.com/2017/03/16/linux.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/16/linux.html</guid>
        <pubDate>Thu, 16 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个文件是网络连接的文件，可视化的编辑也是修改和创建的这个文件&lt;br /&gt;
vi /etc/sysconfig/network-scripts/ifcfg-networkname修改onBoot=yes&lt;/p&gt;

&lt;p&gt;网络服务的开关&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service network stop
service network start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看网络连接状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl status network.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看关于网络部分的日志&lt;br /&gt;
cat /var/log/messages | grep -n network&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;19746:Mar  6 11:40:58 localhost network: 正在打开接口 eno16777736： 成功激活的连接（D-Bus 激活路径：/org/freedesktop/NetworkManager/ActiveConnection/11）
19747:Mar  6 11:40:58 localhost network: [  确定  ]
19750:Mar  6 11:40:58 localhost systemd: Started LSB: Bring up/down networking.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置开机启动一个NetworkManager服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable NetworkManager-wait-online.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service NetworkManager restart
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>如何将已存在的APK项目作为资源引用</title>
        <link>http://www.liuschen.com/2017/03/15/project.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/15/project.html</guid>
        <pubDate>Wed, 15 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;android开发中，调用外部引用的方法分为三种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引入jar包文件&lt;/li&gt;
  &lt;li&gt;把项目整体作为依赖&lt;/li&gt;
  &lt;li&gt;通过maven或是gradle直接配置依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本上，项目如果要开发更简洁，引入外部的依赖是不可避免的，这些引入的方法都很简单，不多加详述，现在我主要探究的是如何通过已有的apk拓展源，来制作可用的依赖。&lt;/p&gt;

&lt;p&gt;关于这点有两点设想&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;反编译apk，修改清单文件，重新打包，将apk作为插件供新程序调用。&lt;/li&gt;
  &lt;li&gt;反编译apk,将反编译出的class文件打成jar包，供新程序调用，引入资源文件，修改映射关系&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;反编译，重打包&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;将apk反编译后会解出一个smali文件夹和res文件夹以及一个解码过的清单文件，如果单纯的解压apk,得到的则是dex文件和resources.arsc文件以及没有解码的res和清单文件，将反编译后的文件夹重新打包，会生成一个build文件夹，里面的内容和解压apk得到的文件类似。也就是说，其实反编译得到的代码是一个完整的开发工程，只是不是Java而已。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;反编译  apktool d -f -.apk&lt;/strong&gt;，会生成一个apk的同名文件夹&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重打包  apktool b -f 反编译得到的文件夹&lt;/strong&gt;,然后会在该文件夹下的dist目录中得到未签名的apk&lt;/p&gt;

&lt;p&gt;这时，包是没有签名的，没有签名的apk是不能安装到手机上的，所以，先简单说一下签名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;每个程序在安装前都需要签名，即是是调试的apk也不例外，发布到市场上的apk一般会单独生成一个keystore,而一般调试用的是系统里面的一个debug.keystore

keytool(jdk的bin目录下)是用来生成keystore的，eclipse和studio里面有图形化的生成方式其实也是调用的这个命令
keytool -genkeypair -alias - debug.keystore -keyalg RSA -validity  100
-keystore debug.keystore
命令说明如下：
 -genkeypair  ：指定生成数字证书
-alias ：指定生成数字证书的别名
-keyalg：指定生成数字证书的算法  这里如RSA算法
-validity：指定生成数字证书的有效期
-keystore ：指定生成数字证书的存储路径。  （这里默认在keytool.exe 目录下）


jarsigner(jdk的bin目录下)命令是用来签名的，调试的时候就是用这个命令签入debug.keystore的
jarsigner -verbose -keystore debug.keystore -signedjar
dst.apk src.apk debug.keystore 
以上命令的说明：
-verbose：指定生成详细输出
-keystore：指定数字证书存储路径
-signedjar：该选项的三个参数为  签名后的apk包  未签名的apk包  数字证书别名

我的debug.keystore在用户目录下的.android文件夹中

查看证书信息keytool -list -keystore debug.keystore
默认密码为：android

debug.keystore签名的别名为androiddebugkey
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果用debug.keystore来&lt;strong&gt;签名&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;jarsigner -verbose -keystore C:\Users\用户.android\debug.keystore -signedjar dst.apk src.apk androiddebugkey&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;正在添加: META-INF/MANIFEST.MF
正在添加: META-INF/ANDROIDD.SF
正在添加: META-INF/ANDROIDD.RSA
正在签名: AndroidManifest.xml
正在签名: classes.dex
正在签名: res/anim/calendar_push_left_in.xml
正在签名: res/anim/calendar_push_left_out.xml
正在签名: res/anim/calendar_push_right_in.xml
正在签名: res/anim/calendar_push_right_out.xml
正在签名: res/anim/push_bottom_in.xml
正在签名: res/anim/push_bottom_in2.xml
			。
			。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用这一流程，来做若干测试：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;修改反编译后的清单文件（比如为activity添加入口，去掉入口，修改包名等等），打包，签名，安装运行程序，程序能如预期的修改效果。&lt;/li&gt;
  &lt;li&gt;修改反编译后的资源文件(如替换图片)，程序也能如期产生对应效果。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改smali&lt;/p&gt;

    &lt;p&gt;Dalvik字节码Dalvik是google专门为Android操作系统设计的一个虚拟机，经过深度的优化。虽然Android上的程序是使用java来开发的，但是Dalvik和标准的java虚拟机JVM是不同的。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的文件执行格式dex（dalvik executable），而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。打包成apk的过程就是将java编译成class文件，然后将class文件封装成dex打包入apk的过程。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;通过这个方法总结出利用原始apk文件部分功能的方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;修改apk入口，将之作为插件依附在新建的apk上&lt;/li&gt;
  &lt;li&gt;新建项目写好需要添加的功能，然后编译成apk文件，反编译出源码，对照修改原来的smali文件和资源文件，重新打包签名&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;classjar&quot;&gt;反编译，提取class文件制作jar包&lt;/h2&gt;

&lt;p&gt;之前反编译到的文件通过jd-gui读取时有很多乱序代码，所以直接抠出Java代码放在开发环境中修改将是一项相当耗时，而且需要懂其中的的业务逻辑，不然就就不可能还原其代码，那么就只能将它打成jar包在新工程中调用，如果是这样，那么就剩下了一个问题，就是如何修复class文件中的资源id和资源本身的映射关系。&lt;/p&gt;

&lt;p&gt;通过实践可知，如果将一个android项目导出为jar包，除了不能包含清单文件和一系列配置文件外（因为配置文件外部也有，如果里面也存在就会造成冲突），资源文件并不能被正确找到。毕竟，资源文件的映射ID是随机生成的。&lt;/p&gt;

&lt;p&gt;而Android系统将代码生成apk过程如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/androiddevelop/article/details/10948639&quot;&gt;命令行方式生成APK&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;1、使用Android SDK提供的aapt.exe(build-tools目录)生成R.Java类文件&lt;/p&gt;

  &lt;p&gt;2、使用Android SDK提供的aidl.exe(build-tools目录)把.aidl转成.java文件&lt;/p&gt;

  &lt;p&gt;3、使用JDK提供的javac.exe（jdk的bin目录下）编译.java类文件生成class文件&lt;/p&gt;

  &lt;p&gt;4、使用Android SDK提供的dx.bat(build-tools目录)命令行脚本生成classes.dex文件&lt;/p&gt;

  &lt;p&gt;5、使用Android SDK提供的aapt.exe(build-tools目录)生成资源包文件（包括res、assets、androidmanifest.xml等）&lt;/p&gt;

  &lt;p&gt;6、使用Android SDK提供的apkbuilder.bat（老版本在sdk中tool目录下，新版是没有这个文件的）生成未签名的apk安装文件&lt;/p&gt;

  &lt;p&gt;7、使用jdk的jarsigner.exe（jdk的bin目录下）对未签名的包进行apk签名&lt;/p&gt;

  &lt;p&gt;8、安装使用的adb.exe在SDK的platform-tools目录下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;android.jar里面是有资源文件的，但是通过尝试，发现引入的jar是和android.jar包不一样的，引入的jar包相当于和本地写的代码是一样的，不允许重复，清单文件资源文件还有resources.arsc文件，resources.arsc一开始我认为里面存放的应该是资源的映射关系，所以放在jar包中能有用，但是却会提示和本地生成的resources.arsc有冲突。那么就不能将这些文件一同写入jar包了，但是如果分开来src和jar包只放代码，res放资源，由于开发环境中R映射文件是动态生成的。而我现在操作的是R文件映射关系已经固定的项目，强行指定固然可以一试，但却不是好方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dex2jar classes.dex             //dex转jar
jar xf classes_dex2jar.jar		//解压jar
jar cvf ketroa.jar *			//打jar包
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是我又想到了第二种导入依赖的方法，项目指定，在eclipse中如果一个项目把另一个项目作为依赖，那么这个项目引用的包就会指向被引用项目的bin文件中自动生成的jar包，这个bin文件中除了有jar包，还有一个res资源文件夹，一个清单文件，和一个R.txt文件，虽然小，但是所有需要的文件都有。R.txt格式文件如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int dimen activity_horizontal_margin 0x7f040000
int dimen activity_vertical_margin 0x7f040001
int drawable ic_launcher 0x7f020000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式虽然可行，但是也需要熟知Android生成apk的过程，对已有打包脚本进行修改才行，虽然是从两种出发点考虑，但是却和上面的强行指定是同一种路子。&lt;/p&gt;

&lt;p&gt;关于aapt，可以通过调出命令文档可知aapt d -param apk可以查看apk的各种信息。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>protobuf基本使用</title>
        <link>http://www.liuschen.com/2017/03/13/caffe.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/13/caffe.html</guid>
        <pubDate>Mon, 13 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下载protobuf，安装都是很简单的步骤，如果想要将安装文件安装到特定目录，需要在configure的时候加入具体的路径参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --prefix=/home/myprotobuf(自己指定的路径)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用：&lt;/p&gt;

&lt;p&gt;为了方便可以先将目录加入环境变量(这个是临时的)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exprot PATH=/home/myprotobuf/bin/:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将动态连接库的搜索路径加入到系统中（之后编译链接代码时会用到）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export LD_LIBRARY_PATH=/home/myprotobuf/lib:$LD_LIBRARY_PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，建一个文件protobuf_demo.proto，通过命令生成cc文件和头文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protoc --cpp_out=. ./protobuf_demo.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;protobuf_demo.proto记录了目标文件需要配置的元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;message protobuf_demo{

required int32 id = 1;
required string str = 2;
required string hello = 4;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再编写cpp文件并在文件中引用上面生成的C++头文件，我的文件如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &quot;protobuf_demo.pb.h&quot;
#include &amp;lt;google/protobuf/io/coded_stream.h&amp;gt;
#include &amp;lt;google/protobuf/io/zero_copy_stream_impl.h&amp;gt;
#include &amp;lt;google/protobuf/text_format.h&amp;gt;

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

using namespace std;
using google::protobuf::io::FileInputStream;
using google::protobuf::io::FileOutputStream;
using google::protobuf::io::ZeroCopyInputStream;
using google::protobuf::io::CodedInputStream;
using google::protobuf::io::ZeroCopyOutputStream;
using google::protobuf::io::CodedOutputStream;

int main(void)
{
protobuf_demo msg;
const char * filename = &quot;some.prototxt&quot;;
int fd = open(filename,O_RDONLY);
if(fd == -1)
{
  cout &amp;lt;&amp;lt; &quot;File not found:&quot; &amp;lt;&amp;lt; filename &amp;lt;&amp;lt; endl;
}
FileInputStream* input = new FileInputStream(fd);
bool success = google::protobuf::TextFormat::Parse(input,&amp;amp;msg);

cout &amp;lt;&amp;lt; msg.id() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; msg.str() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; msg.hello() &amp;lt;&amp;lt; endl;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译生成可执行文件，然后通过该文件就可以读出当前文件加下some.prototxt的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id: 1888
str: &quot;192.168.0.1
hello: &quot;haha&quot;
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>docker</title>
        <link>http://www.liuschen.com/2017/03/09/docker.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/09/docker.html</guid>
        <pubDate>Thu, 09 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httpsdocsdockercomengineinstallationlinuxcentos&quot;&gt;1.&lt;a href=&quot;https://docs.docker.com/engine/installation/linux/centos/&quot;&gt;安装过程:&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;如果已经安装过客户端，先进行清理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum -y remove docker docker-common container-selinux
sudo yum -y remove docker-selinux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装之前，先更新仓库，添加仓库源地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install -y yum-utils
sudo yum-config-manager \
--add-repo \
https://docs.docker.com/engine/installation/linux/repo_files/centos/docker.repo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果添加仓库失败，可以先执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum-config-manager --enable docker-testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum-config-manager --disable docker-testing
sudo yum-config-manager --enable docker-testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装docker之前，先更新包索引&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum makecache fast
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装docker,可以先列出所有版本，选择需要版本安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum list docker-engine.x86_64  --showduplicates |sort -r
sudo yum -y install docker-engine-&amp;lt;VERSION_STRING&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以直接安装最新版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum -y install docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动helloword测试镜像,没有会自动下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新docker，先更新包索引，然后安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum makecache fast
sudo yum -y upgrade docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;卸载docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum -y remove docker-engine
sudo rm -rf /var/lib/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不想每次都用sudo来获取管理员权限，可以建立用户组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo groupadd docker //新建组
sudo usermod -aG docker $USER //添加用户
docker run hello-world  //测试
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dockers&quot;&gt;2.配置dockers开机启动&lt;/h2&gt;

&lt;p&gt;systemd(RHEL, CentOS, Fedora, Ubuntu 16.04 and higher)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl enable docker  开机自启动
sudo systemctl disable docker  取消开机自启动
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;upstart(Ubuntu 14.10 and below)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;默认开机自启动，可以通过以下方法关闭
echo manual | sudo tee /etc/init/docker.override
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chkconfi(Oracle Linux 6)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo chkconfig docker on
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;docker&quot;&gt;3.查看docker信息&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo docker version
sudo docker info
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;httpblogcsdnnetzjinhuaarticledetails52041757&quot;&gt;4.&lt;a href=&quot;http://blog.csdn.net/zjin_hua/article/details/52041757&quot;&gt;数据卷&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//创建数据卷
sudo docker run --name data -v /data -t -i centos /bin/bash
//可以找到host主机挂载数据卷对应的目录
docker inspect data
//将主机根目录下的Source文件夹作为共享目录挂载到container根下的web文件夹
sudo docker run --name web -v /source/:/web -t -i centos /bin/bash
//同上，只是挂载文件夹只读
sudo docker run --rm --name test -v /source/:/test:ro -t -i centos /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;5.容器命名&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo docker run -d -t -i --name test centos bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;持久化镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker save -o webapp.tar 6fae60ef3446
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;持久化容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker export 6fae60ef3446 &amp;gt; webapp.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DockerFile的使用&lt;/p&gt;

&lt;p&gt;dockerFile相当于Linux中的shell脚本和window批处理文件，通过自动化的脚本程序自动生成所需的镜像文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t &amp;lt;待生成的镜像名&amp;gt; &amp;lt;dockerfile所在的文件路径&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ENV 设置环境变量&lt;br /&gt;
ADD 往里面拷贝东西&lt;br /&gt;
RUN 运行镜像中的命令&lt;br /&gt;
EXPOSE 暴露端口&lt;br /&gt;
CMD 启动时执行命令，可替代性&lt;/p&gt;

&lt;p&gt;源镜像在文件中通过From来指定&lt;/p&gt;

&lt;h2 id=&quot;docker-help&quot;&gt;6.docker help&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Usage:	docker COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default &quot;/root/.docker&quot;)
  -D, --debug              Enable debug mode
      --help               Print usage
  -H, --host list          Daemon socket(s) to connect to (default [])
  -l, --log-level string   Set the logging level (&quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;fatal&quot;) (default &quot;info&quot;)
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default &quot;/root/.docker/ca.pem&quot;)
      --tlscert string     Path to TLS certificate file (default &quot;/root/.docker/cert.pem&quot;)
      --tlskey string      Path to TLS key file (default &quot;/root/.docker/key.pem&quot;)
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Management Commands:
  container   Manage containers
  image       Manage images
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  volume      Manage volumes

Commands:
  attach      Attach to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container&#39;s changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  diff        Inspect changes on a container&#39;s filesystem
  events      Get real time events from the server
  exec        Run a command in a running container
  export      Export a container&#39;s filesystem as a tar archive
  history     Show the history of an image
  images      List images
  import      Import the contents from a tarball to create a filesystem image
  info        Display system-wide information
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  login       Log in to a Docker registry
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;例子一：鲸语者&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;docker run docker/whalesay cowsay boo-boo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dockerfile脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM docker/whalesay:latest
RUN apt-get -y update &amp;amp;&amp;amp; apt-get install -y fortunes
CMD /usr/games/fortune -a | cowsay
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t docker-whale .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成container并启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run docker-whale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;container启动方式指定的不同，效果不同。&lt;/p&gt;

&lt;h1 id=&quot;docker-1&quot;&gt;docker中网络的配置&lt;/h1&gt;

&lt;p&gt;既然docker是一个虚拟化的轻量解决方案，那么自然我们要考虑它的隔离性和通信问题，如何访问它是我们应用docker的最终问题。&lt;/p&gt;

&lt;p&gt;run容器时通过-P或-p指定绑定端口，如果不指定，docker会随机映射一个49000~49900的端口至容器内部开放的网络端口&lt;/p&gt;

&lt;p&gt;-p可以指定要映射的端口，并且，在一个指定端口上只能绑定一个容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip:hostPort:containerPort  映射指定地址的特定端口
ip::containerPort          映射指定地址的任意端口
hostPort:containerPort     映射所有地址端口，可以-p多次指定
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;容器互联&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--link 链接容器:链接别名
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>网络探测技术初探</title>
        <link>http://www.liuschen.com/2017/03/06/broadcast.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/06/broadcast.html</guid>
        <pubDate>Mon, 06 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;使用组播&lt;/h2&gt;

&lt;p&gt;广播地址就是为一就对了，子网内传播主机号全为一，所有子网内传播，子网号和主机号全为一。&lt;/p&gt;

&lt;p&gt;组播就是以组为单位的广播，以下摘自百度百科：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。
224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；
224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；
224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；
239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。
组播地址
列表如下：
224.0.0.0 基准地址（保留）
224.0.0.1 所有主机的地址 （包括所有路由器地址）
224.0.0.2 所有组播路由器的地址
224.0.0.3 不分配
224.0.0.4 dvmrp路由器
224.0.0.5 所有ospf路由器
224.0.0.6 ospf DR/BDR
224.0.0.7 st路由器
224.0.0.8 st主机
224.0.0.9 rip-2路由器
224.0.0.10 Eigrp路由器
224.0.0.11 活动代理
224.0.0.12 dhcp 服务器/中继代理
224.0.0.13 所有pim路由器
224.0.0.14 rsvp封装
224.0.0.15 所有cbt路由器
224.0.0.16 指定sbm
224.0.0.17 所有sbms
224.0.0.18 vrrp
以太网传输单播ip报文的时候，目的mac地址使用的是接收者的mac地址。但是在传输组播报文时，传输目的不再是一个具体的接收者，而是一个成员不确定的组，所以使用的是组播mac地址。组播mac地址是和组播ip地址对应的。iana（internet assigned number authority）规定，组播mac地址的高24bit为0x01005e，mac 地址的低23bit为组播ip地址的低23bit。
由于ip组播地址的后28位中只有23位被映射到mac地址，这样就会有32个ip组播地址映射到同一mac地址上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前做过一个手机之间互发消息探测存在的APP，是先使用组播发消息，局域网内有设备收到，这个设备就会发送一条UDP数据报来声明存在，发送探测消息的一端接收到这个消息，就回复一条UDP数据报。一来一回，两个设备就都知晓了对方的存在。然而，在实际应用中两个Android设备互相探测是没问题的，但是由电脑端发送组播消息探测手机端却收不到任何回应，调试时知道手机端根本没收到组播消息（电脑端防火墙是关闭着的），因为手机和手机之间的组播就能接收，所以，我怀疑网络底层可能加了某些过滤规则，在加上网上有些说法，组播和广播的消息很容易被屏蔽，所以暂时放弃这种思路。免得所付者巨多，所得者却少之又少。&lt;/p&gt;

&lt;h2 id=&quot;socket&quot;&gt;Socket轮询&lt;/h2&gt;

&lt;p&gt;这种方法有点笨，就是算出局域网的网段，然后向可能的IP地址发起SOCKet连接，如果能连上，就让客户端机器向服务端发起Netty连接请求。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>GBK编码问题</title>
        <link>http://www.liuschen.com/2017/02/26/GBK.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/02/26/GBK.html</guid>
        <pubDate>Sun, 26 Feb 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php&quot;&gt;http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GBK 亦采用双字节表示，总体编码范围为 8140-FEFE，首字节在 81-FE 之间，尾字节在 40-FE 之间&lt;/p&gt;

&lt;p&gt;全部编码分为三大部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;汉字区。包括：&lt;br /&gt;
a. GB 2312 汉字区。即 GBK/2: B0A1-F7FE。收录 GB 2312 汉字 6763 个，按原顺序排列。&lt;br /&gt;
b. GB 13000.1 扩充汉字区。包括：&lt;br /&gt;
(1) GBK/3: 8140-A0FE。收录 GB 13000.1 中的 CJK 汉字 6080 个。&lt;br /&gt;
(2) GBK/4: AA40-FEA0。收录 CJK 汉字和增补的汉字 8160 个。CJK 汉字在前，按 UCS 代码大小排列；增补的汉字（包括部首和构件）在后，按《康熙字典》的页码/字位排列。&lt;br /&gt;
(3) 汉字“〇”安排在图形符号区GBK/5：A996。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图形符号区。包括：&lt;br /&gt;
a. GB 2312 非汉字符号区。即 GBK/1: A1A1-A9FE。其中除 GB 2312 的符号外，还有 10 个小写罗马数字和 GB 12345 增补的符号。计符号 717 个。&lt;br /&gt;
b. GB 13000.1 扩充非汉字区。即 GBK/5: A840-A9A0。BIG-5 非汉字符号、结构符和“〇”排列在此区。计符号 166 个。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户自定义区：分为(1)(2)(3)三个小区。&lt;br /&gt;
(1) AAA1-AFFE，码位 564 个。&lt;br /&gt;
(2) F8A1-FEFE，码位 658 个。&lt;br /&gt;
(3) A140-A7A0，码位 672 个。&lt;br /&gt;
第(3)区尽管对用户开放，但限制使用，因为不排除未来在此区域增补新字符的可能性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中用户自定义区即表示空白部分，在使用GBK编码时，由于我们一般不改动编码，所以用户自定义区是没有定义的，所以如果要检测半编码的字符，假如字符的编码为ABCD&lt;/p&gt;

&lt;p&gt;首先A不能为4,5,6,7,然后就是编码不能在用户定义区的范围内，以下代码是从byte数组中提取60字节来检测是否编码错乱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isErrorGBKCode(byte[] bytes){
	for (int i = 0; i &amp;lt; 30; i++) {
		String hexStringHeader = Integer.toHexString(bytes[i*2]);
		String hexStringTail = Integer.toHexString(bytes[i*2+1]);
		System.out.println(hexStringHeader+&quot;=======&quot;+hexStringTail);
		if(hexStringHeader.length()&amp;lt;8 || hexStringTail.length()&amp;lt;8)
			continue;
		char first = hexStringHeader.charAt(6);
		char second = hexStringHeader.charAt(7);
		char third = hexStringTail.charAt(6);
		char fourth = hexStringTail.charAt(7);

		char[] code = {first,second,third,fourth};
		String codeStr = new String(code);

		/**
		 * (1) AAA1-AFFE，码位 564 个。
		 (2) F8A1-FEFE，码位 658 个。
		 (3) A140-A7A0，码位 672 个。
		 * */
		if(codeStr.matches(&quot;^a[a-f][a-f][1-9a-e]$&quot;))
			return true;
		if(codeStr.matches(&quot;^f[8-9a-f][a-f][1-9a-e]$&quot;))
			return true;
		if(codeStr.matches(&quot;^a[1-7][4-9a]0$&quot;))
			return true;
		if(codeStr.matches(&quot;^[^4-7]]&quot;))
			return true;

	}
	return false;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>FastDFS配置文档</title>
        <link>http://www.liuschen.com/2017/01/16/fastdfs.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/01/16/fastdfs.html</guid>
        <pubDate>Mon, 16 Jan 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;1.简介&lt;/h2&gt;

&lt;p&gt;FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储（不是大文件）和负载均衡的问题。特别适合以文件为载体的在线服务。&lt;/p&gt;

&lt;p&gt;FastDFS有两个重要模块，tracker和storage。tracker负责调度分配文件的访问和负载均衡。storage则负责文件的管理，其中包括文件的存储，同步，和提供文件的访问接口。其中还允许以键值对的形式对文件写入一些元数据。&lt;/p&gt;

&lt;p&gt;tracker和storage可以包括一个或多个服务端，这些服务端可以在不影响对外提供服务的情况下动态的添加和删除。集群中的每个服务器是对等的。&lt;/p&gt;

&lt;h2 id=&quot;linux&quot;&gt;1.Linux部署&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意:一定要下载正确的版本，我最开始下载了v1.27，结果Java端死活上载不了文件，之前的版本是依赖libevent这个库的，而新的版本依赖的是libfastcommon，一定要按照给出的下载地址下载libfastcommon,以防出错，以下步骤为v5.08中的INSTALL文件中给出的步骤，如果亲下载的版本更新，请以FastDFS目录下INSTALL中给出的安装步骤为准。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下载最新版本v5.0.8FastDFS:&lt;a href=&quot;https://sourceforge.net/projects/fastdfs/files/&quot;&gt;https://sourceforge.net/projects/fastdfs/files/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;github-libfastcommon-&quot;&gt;步骤一. 从github上下载 libfastcommon 源码包并且安装它&lt;/h3&gt;

&lt;p&gt;the github address:&lt;br /&gt;
   https://github.com/happyfish100/libfastcommon.git&lt;/p&gt;

&lt;h3 id=&quot;fastdfs&quot;&gt;步骤二.下载 FastDFS源码包（已下载），并且解压&lt;/h3&gt;

&lt;p&gt;tar xzf FastDFS_v5.x.tar.gz&lt;/p&gt;

&lt;h3 id=&quot;fastdfs-1&quot;&gt;步骤三.进入FastDFS目录&lt;/h3&gt;
&lt;p&gt;cd FastDFS&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;步骤四.执行命令:&lt;/h3&gt;

&lt;p&gt;./make.sh&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;步骤五.执行安装命令&lt;/h3&gt;

&lt;p&gt;./make.sh install&lt;/p&gt;

&lt;h3 id=&quot;config&quot;&gt;步骤六.编辑修改config文件&lt;/h3&gt;

&lt;p&gt;config文件是用来启动tracker和storage的，在conf目录下，执行安装命令后在/etc/fdfs/目录下也有备份&lt;/p&gt;

&lt;p&gt;在这一步先做简单的修改，只需要改配置文件的中设置的IP和搜索‘home’,更改需要设置本地存储位置即可&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;步骤七.启动服务器&lt;/h3&gt;

&lt;h4 id=&quot;tracker-&quot;&gt;启动 tracker 程序:&lt;/h4&gt;

&lt;p&gt;/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart&lt;/p&gt;

&lt;h4 id=&quot;in-linux-you-can-start-fdfstrackerd-as-a-service&quot;&gt;in Linux, you can start fdfs_trackerd as a service:&lt;/h4&gt;

&lt;p&gt;/sbin/service fdfs_trackerd start&lt;/p&gt;

&lt;h4 id=&quot;storage-&quot;&gt;启动 storage 程序:&lt;/h4&gt;

&lt;p&gt;/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart&lt;/p&gt;

&lt;h4 id=&quot;in-linux-you-can-start-fdfsstoraged-as-a-service&quot;&gt;in Linux, you can start fdfs_storaged as a service:&lt;/h4&gt;

&lt;p&gt;/sbin/service fdfs_storaged start&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;步骤八.测试启动的程序&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;启动测试程序格式:&lt;/h4&gt;

&lt;p&gt;/usr/bin/fdfs_test 客户端配置文件 操作(download,upload)&lt;/p&gt;

&lt;p&gt;/usr/bin/fdfs_test1 客户端配置文件 操作(download,upload)&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;上传文件示例:&lt;/h4&gt;

&lt;p&gt;/usr/bin/fdfs_test conf/client.conf upload /usr/include/stdlib.h&lt;/p&gt;

&lt;h3 id=&quot;monitor&quot;&gt;步骤九.启动monitor程序&lt;/h3&gt;

&lt;p&gt;/usr/bin/fdfs_monitor 客户端配置文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：启动完后有时需要一点时间才可以访问，如果马上测试返回不成功的话，并不一定是配置错了。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;2.配置文件和启动的一些补充&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于是分布式存储，在一个服务器上可以选择tracker和storage进行部署。&lt;br /&gt;
修改配置文件，FastDFS目录下conf下以conf为扩展名的文件都是配置文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配置tracker.conf和storage.conf中的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;base_path:存储数据和log文件

store_path0:存储文件路径

tracker_server：tracker服务器

group_name=group1:设置storage所属的组，同组磁盘存储单元互相备份
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动tracker：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fdfs_trackerd ./conf/tracker.conf restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动storage：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fdfs_storaged ./conf/storage.conf restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/fdfs_test /etc/fdfs/client.conf upload file
/usr/bin/fdfs_test /etc/fdfs/client.conf download file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出配置信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/fdfs_monitor /etc/fdfs/client.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fdfs_trackerd和fdfs_storaged是安装的可执行文件，如果安装的目录没有加入了环境变量，需要加上全路径，就是上面说的可执行文件的安装路径,新版本的fdfs_trackerd和fdfs_storaged是安装在/usr/bin中，需要加全路径，修改的conf最好也是修改/etc/fdfs下的相关配置文件，便于寻找部署。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;3.搭建反向代理服务器&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;到这一步，不是必须的，但是由于FastDFS新版本不支持HTTP服务了，所以需要自己搭建该服务，同时，也可以解决不同storage之间复制文件时，访问未传输文件导致的错误，nginx能将访问链接重定向到源文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;依然是这个地址：&lt;a href=&quot;https://sourceforge.net/projects/fastdfs/files/&quot;&gt;https://sourceforge.net/projects/fastdfs/files/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载fastdfs-nginx-module&lt;/p&gt;

&lt;p&gt;下载nginx(我下载的是稳定版1.10.2):&lt;a href=&quot;http://nginx.org/en/download.html&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;nginx&quot;&gt;安装nginx&lt;/h3&gt;

&lt;p&gt;解压，fastdfs-nginx-module，内有一个src文件夹，路径假设为$(PATH)&lt;/p&gt;

&lt;p&gt;添加依赖（我没有执行这一步，考虑到安装的环境可能不同，最好一次性将依赖安装，就可以避免下面的一些配置和编译的错误）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl openssl-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切换到nginx目录中，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --add-module=$(PATH)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure: error: the HTTP rewrite module requires the PCRE library.
./configure: error: the HTTP gzip module requires the zlib library.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install pcre-devel
yum install zlib-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行make,如果报错yacc命令未找到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install bison-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:devel表示的是开发版本，与源码编译来相同，有暴露的include和链接库供其他程序编译时调用&lt;/p&gt;

&lt;p&gt;报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fastdfs-nginx-module/src/common.c:29:27: 致命错误：local_ip_func.h：没有那个文件或目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;local_ip_func.h经过搜索发现是fastcommon中的头文件，这里找不到，可能是编译目录未包含，事实上也是如此，编译时包含了/usr/local/include/fastcommon目录，但是local_ip_func.h确是在/usr/include/fastcommon&lt;/p&gt;

&lt;p&gt;所以，只需要生成makefile（这个文件在obj目录下）文件后，添加一下include目录搜索地址即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;将-L/usr/local/lib改为-L/usr/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ALL_INCS中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-I /usr/include/fastdfs \
-I /usr/include \
-I /usr/local/include \
-I /usr/include/fastcommon/ \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译中出现这个问题就是fastcommon的安装路径和nginx中添加插件找寻的目录不一致导致的，当然也可以一开始不要将fastcommon安装在local下.&lt;/p&gt;

&lt;p&gt;编译成功后，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>eclipse配合maven导入项目遇到的问题</title>
        <link>http://www.liuschen.com/2017/01/16/error.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/01/16/error.html</guid>
        <pubDate>Mon, 16 Jan 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;错误一：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Multiple annotations found at this line:
	- cvc-complex-type.2.4.c: The matching wildcard is strict, but no declaration can be found for element &#39;dubbo:application&#39;.
	- schema_reference.4: Failed to read schema document &#39;http://code.alibabatech.com/schema/dubbo/dubbo.xsd&#39;, because 1) could not 
 find the document; 2) the document could not be read; 3) the root element of the document is not &amp;lt;xsd:schema&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决办法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;http://blog.csdn.net/tech4j/article/details/46754751
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;错误二：&lt;/h2&gt;

 	jsp文件报错：The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path&lt;br /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解决办法：&lt;/h3&gt;

&lt;p&gt;将jre system library改为本机存在的正确的版本，添加serverRuntime&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;错误三：&lt;/h2&gt;

&lt;p&gt;Multiple annotations found at this line:&lt;br /&gt;
	- Plugin execution not covered by lifecycle configuration: org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile (execution: &lt;br /&gt;
	 default-testCompile, phase: test-compile)&lt;/p&gt;

&lt;p&gt;maven-&amp;gt;Lifecycle Mapping载入如下文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;lifecycleMappingMetadata&amp;gt;
  &amp;lt;pluginExecutions&amp;gt;
    &amp;lt;pluginExecution&amp;gt;
      &amp;lt;pluginExecutionFilter&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;goals&amp;gt;
          &amp;lt;goal&amp;gt;compile&amp;lt;/goal&amp;gt;
          &amp;lt;goal&amp;gt;testCompile&amp;lt;/goal&amp;gt;
        &amp;lt;/goals&amp;gt;
        &amp;lt;versionRange&amp;gt;[3.1,)&amp;lt;/versionRange&amp;gt;
      &amp;lt;/pluginExecutionFilter&amp;gt;
      &amp;lt;action&amp;gt;
        &amp;lt;ignore/&amp;gt;
      &amp;lt;/action&amp;gt;
    &amp;lt;/pluginExecution&amp;gt;
  &amp;lt;/pluginExecutions&amp;gt;
&amp;lt;/lifecycleMappingMetadata&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中artifactId的值maven-compiler-plugin，versionRange的值和goal的值根据报的错误不同，做不同改动&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;错误四：&lt;/h2&gt;

&lt;p&gt;Cannot change version of project facet Dynamic Web Module to 2.3&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;解决方法&lt;/h3&gt;

&lt;p&gt;http://www.cnblogs.com/yezhenhan/archive/2011/10/17/2215279.html&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;错误五：&lt;/h2&gt;

&lt;p&gt;One or more constraints have not been satisfied.&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;错误六：&lt;/h2&gt;

&lt;p&gt;安装完tomcat插件后，点击启动tomcat的小猫图标，没有启动tomcat，反而在没有断点的情况下进入了调试。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;解决方法：&lt;/h3&gt;

&lt;p&gt;重新建立工作区，重新导入，重新设置，这个情况出现是由于工作区配置在导入tomcat插件后出现混乱了。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;错误七：&lt;/h2&gt;

&lt;p&gt;重新建立工作区，重新配置，git,maven，tomcat插件都设置好了，项目重新导入没有异常，但启动tomcat时报异常&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.lang.ClassNotFoundException: org.apache.catalina.loader.DevLoader
at java.net.URLClassLoader$1.run(URLClassLoader.java:372)
at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
at java.security.AccessController.doPrivileged(Native Method)
at java.net.URLClassLoader.findClass(URLClassLoader.java:360)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-11&quot;&gt;解决方法：&lt;/h3&gt;

&lt;p&gt;1、在eclipse目录下，找到DevLoader包，位于\eclipse\plugins\com.sysdeo.eclipse.tomcat（tomcat插件） 的DevLoader.zip&lt;/p&gt;

&lt;p&gt;2、复制到apache-tomcat-6.0.x 里的lib里, 并改为DevLoader.jar&lt;/p&gt;

&lt;p&gt;3、重启tomcat.&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;错误八：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1698)
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1544)
at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4219)
at org.apache.catalina.core.StandardContext.start(StandardContext.java:4779)
at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:803)
at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:780)
at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:583)
at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:676)
at org.apache.catalina.startup.HostConfig.deployDescriptors(HostConfig.java:602)
at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:503)
at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1322)
at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:325)
at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:142)
at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1069)
at org.apache.catalina.core.StandardHost.start(StandardHost.java:822)
at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1061)
at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:463)
at org.apache.catalina.core.StandardService.start(StandardService.java:525)
at org.apache.catalina.core.StandardServer.start(StandardServer.java:761)
at org.apache.catalina.startup.Catalina.start(Catalina.java:595)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:483)
at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289)
at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-13&quot;&gt;解决方法：&lt;/h3&gt;

&lt;h2 id=&quot;section-14&quot;&gt;错误九：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;XX cannot be resolved
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-15&quot;&gt;解决方法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;将编码格式改为UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-16&quot;&gt;错误十：&lt;/h2&gt;

&lt;p&gt;web.xml is missing and &lt;failonmissingwebxml&gt; is set to true、&lt;/failonmissingwebxml&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;解决方法：&lt;/h3&gt;

&lt;p&gt;如果你的项目在 /src/main/webapp/WEB-INF 下有web.xml，但是仍然还是报这个错误，需要两步操作&lt;/p&gt;

&lt;p&gt;1）右击项目，打开Properties对话框，点击Deployment Assembly选项，在右边添加一个文件夹，并且保存设置&lt;/p&gt;

&lt;p&gt;2）在eclispe上方点击Project -&amp;gt;Clean 清理一下这个项目&lt;/p&gt;

&lt;h2 id=&quot;section-18&quot;&gt;错误十一&lt;/h2&gt;

&lt;p&gt;编译项目时，编译到一半，eclipse卡死&lt;/p&gt;

&lt;h3 id=&quot;section-19&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;每次卡死的地方找到是一个js文件，所以，取消掉js的校验&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Window-&amp;gt;Preferences-&amp;gt;Valiation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取消表中关于javascript Client校验的勾选&lt;/p&gt;

&lt;p&gt;删除.project中校验js的配置项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	&amp;lt;buildCommand&amp;gt;
		&amp;lt;name&amp;gt;org.eclipse.wst.jsdt.core.javascriptValidator&amp;lt;/name&amp;gt;
		&amp;lt;arguments&amp;gt;
		&amp;lt;/arguments&amp;gt;
	&amp;lt;/buildCommand&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;br /&gt;
		&lt;nature&gt;org.eclipse.wst.jsdt.core.jsNature&lt;/nature&gt;&lt;/p&gt;

&lt;p&gt;删除项目中的js文件，重新添加&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>