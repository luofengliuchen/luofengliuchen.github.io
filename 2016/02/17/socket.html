<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
<!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

<title>Socket编程笔记 | 落风的博客</title>
<meta name="author" content="落风">

  <meta name="keywords" content="Socket">




<link rel="shortcut icon" href="http://7xpui7.com1.z0.glb.clouddn.com/blog-site-favicon.ico" />

<link rel="stylesheet" type="text/css" href="/assets/css/style.css">

<link href="/pages/rss.xml" rel="alternate" title="落风的博客" type="application/atom+xml">
  </head>
  <body>
    <aside id="sidebar">
  <nav id="tags">
    <a href="/index.html" id="avatar" style="background-image:url(http://7xpui7.com1.z0.glb.clouddn.com/blog-site-avatar.png)"></a>

    <ul id="tags__ul">
      <li id="pl__all" class="tags__li tags-btn active">全部</li>
       
        <li id="技术" class="tags__li tags-btn">技术</li>
       
        <li id="杂说" class="tags__li tags-btn">杂说</li>
       
        <li id="小说" class="tags__li tags-btn">小说</li>
       
        <li id="照片" class="tags__li tags-btn">照片</li>
      
    </ul>

    <div id="tags__bottom">
      <a href="mailto:luofengliuchen@gmail.com" id="icon-email" class="tags-btn fontello"></a>
      <a href="/pages/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
    </div>
  </nav> <!-- end #tags -->

  <div id="posts-list">
    <form action="" id="search-form">
      <a href="/index.html" id="mobile-avatar" style="background-image:url(http://7xpui7.com1.z0.glb.clouddn.com/blog-site-avatar.png)"></a>
      <!-- NOTE: input field is disabled by default -->
      <input id="search-input" type="text" placeholder="Search...">
    </form>

    <nav id="pl__container">
    
      <a class=" pl__all" href="/2016/08/05/proguard.html"><span class="pl__circle"></span><span class="pl__title">Proguard</span><span class="pl__date">Aug 2016</span></a>
    
      <a class=" pl__all" href="/2016/08/02/nine.html"><span class="pl__circle"></span><span class="pl__title">Nine</span><span class="pl__date">Aug 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/07/22/zip.html"><span class="pl__circle"></span><span class="pl__title">Android解压缩zip文件</span><span class="pl__date">Jul 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/06/07/person.html"><span class="pl__circle"></span><span class="pl__title">程序员编程语录</span><span class="pl__date">Jun 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/04/29/sqlite.html"><span class="pl__circle"></span><span class="pl__title">Android数据库和Bean的交互</span><span class="pl__date">Apr 2016</span></a>
    
      <a class="杂说 pl__all" href="/2016/04/25/wildernessdiary-habby.html"><span class="pl__circle"></span><span class="pl__title">荒原日记-习惯</span><span class="pl__date">Apr 2016</span></a>
    
      <a class="杂说 pl__all" href="/2016/04/16/wildernessdiary-start.html"><span class="pl__circle"></span><span class="pl__title">荒原日记-开篇</span><span class="pl__date">Apr 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/02/21/studio.html"><span class="pl__circle"></span><span class="pl__title">Visual Studio开发Android程序</span><span class="pl__date">Feb 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/02/19/c++.html"><span class="pl__circle"></span><span class="pl__title">C++学习整理</span><span class="pl__date">Feb 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/02/17/socket.html"><span class="pl__circle"></span><span class="pl__title">Socket编程笔记</span><span class="pl__date">Feb 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/02/16/apk.html"><span class="pl__circle"></span><span class="pl__title">git常用命令行</span><span class="pl__date">Feb 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/02/14/apk.html"><span class="pl__circle"></span><span class="pl__title">android反编译</span><span class="pl__date">Feb 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/02/05/html5-2.html"><span class="pl__circle"></span><span class="pl__title">html5内嵌入android</span><span class="pl__date">Feb 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/02/04/html5-1.html"><span class="pl__circle"></span><span class="pl__title">HTML5绘图学习记录</span><span class="pl__date">Feb 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/02/03/html5.html"><span class="pl__circle"></span><span class="pl__title">HTML5绘图学习</span><span class="pl__date">Feb 2016</span></a>
    
      <a class="照片 pl__all" href="/2016/01/31/fox3.html"><span class="pl__circle"></span><span class="pl__title">想要冬眠的狐狸</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="照片 pl__all" href="/2016/01/31/fox2.html"><span class="pl__circle"></span><span class="pl__title">擅长卖萌的狐狸</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="照片 pl__all" href="/2016/01/31/fox1.html"><span class="pl__circle"></span><span class="pl__title">正在找东西的狐狸</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="小说 pl__all" href="/2016/01/27/dream-flower.html"><span class="pl__circle"></span><span class="pl__title">梦花</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="杂说 pl__all" href="/2016/01/27/project-mode.html"><span class="pl__circle"></span><span class="pl__title">我对瀑布开发模式和敏捷开发模式的理解</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/01/25/stackblur.html"><span class="pl__circle"></span><span class="pl__title">Android滤镜-快速模糊</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/01/18/listview-focus.html"><span class="pl__circle"></span><span class="pl__title">listview焦点冲突</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/01/18/android-StringPicker.html"><span class="pl__circle"></span><span class="pl__title">NumberPicker与StringPicker</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/01/15/draw-a-logo2.html"><span class="pl__circle"></span><span class="pl__title">Android绘图-LOGO兼容低版本</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/01/15/android-logo1.html"><span class="pl__circle"></span><span class="pl__title">Android绘图-LOGO-实现3</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/01/15/NDK.html"><span class="pl__circle"></span><span class="pl__title">Androidstudio下jni的一些问题</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/01/14/draw-a-logo.html"><span class="pl__circle"></span><span class="pl__title">Android绘图-LOGO-实现2</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/01/12/draw-a-logo.html"><span class="pl__circle"></span><span class="pl__title">Android绘图-LOGO-实现1</span><span class="pl__date">Jan 2016</span></a>
    
      <a class="技术 pl__all" href="/2016/01/11/deal-with-pix.html"><span class="pl__circle"></span><span class="pl__title">android图像处理:像素过滤</span><span class="pl__date">Jan 2016</span></a>
    
    </nav>
  </div> <!-- end #posts-list -->
</aside> <!-- end #sidebar -->
    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20160217">Socket编程笔记</h1>
  <blockquote>
  <p>android中的socket连接HttpURLConnection来实现的。而HttpClient是对HttpURLConnection做了一层封装，HttpClient6.0之后被废弃了,推荐用HttpURLConnection。而HttpURLConnection继承于HttpConnection，两者都是抽象类，想了解其中的实现原理，就要深入的剖析一下代码，但是其中一些关键的方法如connect()方法却是抽象的，所以需要找到它的实现类。</p>
</blockquote>

<p>首先，是找到connect()的实现，最可能的是在URL类中找线索，因为是在url中获取的</p>

<pre><code>URL url = new URL(httpUrl);//此处有异常抛出
HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();
</code></pre>

<p>然而，URL中却显示streamHandler中取得的</p>

<pre><code>public URLConnection openConnection() throws IOException {
    return streamHandler.openConnection(this);
}
</code></pre>

<p>而streamHandler这个实例所属的对象实现的方法仍然是抽象的</p>

<pre><code>protected abstract URLConnection openConnection(URL u) throws IOException;
</code></pre>

<p>也就是说单独知道这个出处还不够，还需要知道streamHandler是在什么时候被赋值的，这时候可以注意到URL中有URLStreamHandlerFactory streamHandlerFactory的工厂声明，点击去发现还是抽象的(晕)，然后顺着streamHandlerFactory就找到了下面的方法，是对streamHandler赋值的关键</p>

<pre><code> void setupStreamHandler() {
    // Check for a cached (previously looked up) handler for
    // the requested protocol.
    streamHandler = streamHandlers.get(protocol);
    if (streamHandler != null) {
        return;
    }

    // If there is a stream handler factory, then attempt to
    // use it to create the handler.
    if (streamHandlerFactory != null) {
        streamHandler = streamHandlerFactory.createURLStreamHandler(protocol);
        if (streamHandler != null) {
            streamHandlers.put(protocol, streamHandler);
            return;
        }
    }

    // Check if there is a list of packages which can provide handlers.
    // If so, then walk this list looking for an applicable one.
    String packageList = System.getProperty("java.protocol.handler.pkgs");
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    if (packageList != null &amp;&amp; contextClassLoader != null) {
        for (String packageName : packageList.split("\\|")) {
            String className = packageName + "." + protocol + ".Handler";
            try {
                Class&lt;?&gt; c = contextClassLoader.loadClass(className);
                streamHandler = (URLStreamHandler) c.newInstance();
                if (streamHandler != null) {
                    streamHandlers.put(protocol, streamHandler);
                }
                return;
            } catch (IllegalAccessException ignored) {
            } catch (InstantiationException ignored) {
            } catch (ClassNotFoundException ignored) {
            }
        }
    }

    // Fall back to a built-in stream handler if the user didn't supply one
    if (protocol.equals("file")) {
        streamHandler = new FileHandler();
    } else if (protocol.equals("ftp")) {
        streamHandler = new FtpHandler();
    } else if (protocol.equals("http")) {
        try {
            String name = "com.android.okhttp.HttpHandler";
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals("https")) {
        try {
            String name = "com.android.okhttp.HttpsHandler";
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals("jar")) {
        streamHandler = new JarHandler();
    }
    if (streamHandler != null) {
        streamHandlers.put(protocol, streamHandler);
    }
}
</code></pre>

<p>看注释区分，总共分为4个部分</p>

<h1 id="section">第一部分</h1>

<pre><code> streamHandler = streamHandlers.get(protocol);
    if (streamHandler != null) {
        return;
    }
</code></pre>

<p>是取缓存的streamHandler实例，如果已经存在了，就不会往下执行了。</p>

<h1 id="section-1">第二部分</h1>

<pre><code>if (streamHandlerFactory != null) {
        streamHandler = streamHandlerFactory.createURLStreamHandler(protocol);
        if (streamHandler != null) {
            streamHandlers.put(protocol, streamHandler);
            return;
        }
    }
</code></pre>

<p>明显用到了工厂，所以需要知道工厂的出处，是这里:</p>

<pre><code>/**
 * Sets the stream handler factory for this VM.
 *
 * @throws Error if a URLStreamHandlerFactory has already been installed
 *     for the current VM.
 */
public static synchronized void setURLStreamHandlerFactory(URLStreamHandlerFactory factory) {
    if (streamHandlerFactory != null) {
        throw new Error("Factory already set");
    }
    streamHandlers.clear();
    streamHandlerFactory = factory;
}
</code></pre>

<p>得了，这个是公共的设置方法:Sets the stream handler factory for this VM顿时感觉好高大上，总之，不通。</p>

<h1 id="section-2">第三部分</h1>

<p>在系统属性指定的包中寻找相应的URLStreamHandler处理类，因为没怎么用过这种方法，值得注意，不过不是这里的重点</p>

<pre><code>String packageList = System.getProperty("java.protocol.handler.pkgs");
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    if (packageList != null &amp;&amp; contextClassLoader != null) {
        for (String packageName : packageList.split("\\|")) {
            String className = packageName + "." + protocol + ".Handler";
            try {
                Class&lt;?&gt; c = contextClassLoader.loadClass(className);
                streamHandler = (URLStreamHandler) c.newInstance();
                if (streamHandler != null) {
                    streamHandlers.put(protocol, streamHandler);
                }
                return;
            } catch (IllegalAccessException ignored) {
            } catch (InstantiationException ignored) {
            } catch (ClassNotFoundException ignored) {
            }
        }
    }
</code></pre>

<h1 id="section-3">第四部分</h1>

<p>再不成只能做最后的挣扎了</p>

<pre><code>if (protocol.equals("file")) {
        streamHandler = new FileHandler();
    } else if (protocol.equals("ftp")) {
        streamHandler = new FtpHandler();
    } else if (protocol.equals("http")) {
        try {
            String name = "com.android.okhttp.HttpHandler";
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals("https")) {
        try {
            String name = "com.android.okhttp.HttpsHandler";
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals("jar")) {
        streamHandler = new JarHandler();
    }
    if (streamHandler != null) {
        streamHandlers.put(protocol, streamHandler);
    }
</code></pre>

<p>其中https依然是在特定包com.android.okhttp.HttpsHandler中找<br />
而其他的则是直接new一个对象，这些对象的导入</p>

<pre><code>import libcore.net.url.FileHandler;
import libcore.net.url.FtpHandler;
import libcore.net.url.JarHandler;
</code></pre>

<p>在androidstudio中显示的是灰色的，表示没有没有提供相关源码，至此，线索全断了，不过通过这些查找也并非没有收获。</p>

<p>一直以来找的URLStreamHandler streamHandler其实是一个协议流处理器，每一个<br />
对应一个URLHttpConnection，至于实现它们的源码，限于sdk中源码包没有所以没看到，不过却找到了出处，网上查了一下知道了其中实现也是通过Socket，大体的关系总是理清了。</p>

<h1 id="section-4">总结：</h1>

<p>1.URLHttpConnection和URLHttpsConnection都继承了URLConnection都是基于应用层对http或https协议的封装，里面通信还是用的socket</p>

<p>2.URLConnection里面调用的Socket是传输层对应用层提供的抽象接口,是下层黑箱的一个门面，其中包括的协议有传输层的TCP协议和UDP协议，以及网络层的IP协议。当然也可以直接用socket通信，可以在应用层通过socket来架构网络框架，但是需要考虑多线程，以及状态监控（其实用URLConnection也要自己写多线程）等因素，更省流量以及更可控，但是如果要用到http等应用层协议，还是用URLConnection方便些。</p>

<p>3.每个URLConnection都有一个相对应的URLStreamHandler实例用来处理协议，URL类中还有关于file，ftp,jar对应类型的URLStreamHandler应该也是一些协议的封装的处理器，也就是说每一种协议需要对应一种处理模型。</p>

<h1 id="section-5">最后，温习一下网络模型：</h1>

<h2 id="section-6">应用层-应用层，表示层，会话层</h2>

<h2 id="section-7">传输层-传输层</h2>

<h2 id="section-8">网际互联层-网络层</h2>

<h2 id="section-9">网络接入层-数据链路层，物理层</h2>


</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://www.liuschen.com/2016/02/17/socket.html&text=Socket编程笔记" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://www.liuschen.com/2016/02/17/socket.html&title=Socket编程笔记" target="_blank"></a>
</div> <!-- end #post__share -->
<div id="disqus_thread" name="luofeng">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div>

<!-- <div id="disqus_thread"></div>
<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//luofeng.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> -->


        <p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Hosted on <a href="https://pages.github.com" target="_blank">Github</a></p>
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.pjax.js"></script>
<script src="/assets/js/nprogress.js"></script>
<script src="/assets/js/script.js"></script>
  </body>
</html>