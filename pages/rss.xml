<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>落风的博客</title>
    <link>http://www.liuschen.com</link>
    <description>落风的博客</description>
    
      <item>
        <title>荒原日记-时空狂想</title>
        <link>http://www.liuschen.com/2016/10/02/wildernessdiary-time.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/10/02/wildernessdiary-time.html</guid>
        <pubDate>Sun, 02 Oct 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;我们存在于此的客观因素是时间和空间，人之于物，我想和物之于物没什么不同。只不过是人，进化出了高情态的智能。所以有能力去认知自己的现状，进而改变其所处的环境。&lt;/p&gt;

&lt;p&gt;首先是唯心主义的观点，认为人才是世界的中心，世界是以人的意识为前提存在的，如果你认为荒诞，就不要再往下看了，先入为主往往会让人丧失判断力，“缸中之脑”其实就是一种唯心主义的现实体现，可怕的是你不觉得它是对的，却也无法证明它是错的。神学最初就是以唯心立论的，然而经过长达几个世纪科学的发展，它的观点不断的被现代科学否决，而它也像一个摇摆不定的娼妇，在一次次的改变着自己的主张，接收着现代科学的渗透。但是却一直未遭到废弃，究其原因，是因为现代科学解决不了人的信仰问题，自古以来，人类都对自己存在的意义充满了好奇。神学，宗教可以给你答案，然而科学给不了。所以现在仍有不少的科学家试图用科学的手段来证明一些宗教现象的背后的意义。&lt;/p&gt;

&lt;p&gt;称量灵魂重量就是一个典型的例子，有人说灵魂的重量是21g，事实上如何，怕也没人知道，只是觉得不可信，人有高矮胖瘦，更何况灵魂，只是说21g，无所谓严谨，说是科学实验恐怕也只是噱头。灵魂向来是一个抽象的概念，指的是我之所以是我的那个本质。久而久之，却连离体之说都被传的煞有其事。但是，灵魂究竟为何？是可以独立的还是某些硬件或是后天形成的特征。我们可以假设几个例子：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;灵魂是否存在于每个人的DNA中，如果是，那么同卵的双胞胎是否共享同样的灵魂？但现实生活中，他(他)们确是不同的个体 。&lt;/li&gt;
  &lt;li&gt;那么，灵魂不是存在于自己的基因当中，会不会存在于自己的记忆当中，当自身发育不完全或是年龄小的时候可能正是形成灵魂的时候，但是无论什么时候，总是会有那么一个时期，是自己构筑自己自我意识的时候。而这个时候大部分人都不会记得。因为人生来就是一张白纸，而白纸没有ID，它可以是特定的人，也可以是任何人。然后在之上灵魂会自己形成。&lt;/li&gt;
  &lt;li&gt;如果克隆技术发展到一定水平，允许克隆自己，那么，当我们克隆一个自己，并把自己现有的所有记忆移植到他之上。那么，这里就会产生一个有趣的问题，如果我(本体)在克隆体记忆移植完成并苏醒前死掉，那么克隆体苏醒时里面会不会是我本体的意识，可以肯定的是至少在本体无恙时不会是本体的意识，因为本体还活着，这就尴尬了。这是终极的假设，会出现几种可能情况，一是记忆可以移植，但是本体死亡前，克隆体是不会苏醒的，这说明了意识在宇宙中是一种独特的东西，具有唯一性，并且超越时空的限制；二是记忆可以移植，但是成功移植的条件是本体会立即死亡，这也说明意识是一种独特的存在，具有唯一性，但并不能证明和时空的关联；三是记忆可以移植并且本体和克隆体都正常，这个是最自然的，同时也是让人最难以接受的，它可能说明人类的意识可能不过是人自己的错觉罢了。它和自然界中的其他事物一样，兴盛衰败，人小了，懵懂，人老了，痴呆。都只不过是为了让人接受自然变化的平滑过渡而已。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于轮回，大部分都是宗教的观点和人美好的愿望，苦难者寄往来生，支配者渴望永生，然而不管是来生还是永生，还是我最初所想，都不是那么有趣，永生和死亡自古以来都是一个交缠的话题，我们害怕死亡，所以渴望永生，然而细细思量，无穷无尽的生命却更为恐怖。没有尽头，没有一个人能忍受的了，所以对于轮回的猜想才更为现实。事物有兴盛衰败的变化，这是自然界中最为合理的规则，所以人对永生的追求便寄望到了轮回一途。阴朝地府我想是不会有的，现今科学的发展也不容我这么考虑，然而轮回的存在也许是可能的，只不过并不是以我们期望的方式，如果意识是独特的存在，轮回可以说必然存在，如果意识不过是我们的错觉，我们并没有什么独特之处，那么我们死后，便可以轮回成任何人，我和你并没有什么区别，生来不过是一张白纸，我们的意识可能只不过是某些偶发因素导致的概率事件。当把发生概率的范围扩展至无穷（宇宙），那么即便是小概率事件也会变得相当大，而这，就是轮回。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>网络工程-抓包分析</title>
        <link>http://www.liuschen.com/2016/09/18/net-analysis.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/09/18/net-analysis.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;socket&quot;&gt;1.socket套接字&lt;/h2&gt;
&lt;p&gt;socket套接字是应用层调用的传输层提供的，传输层封装Tcp/Udp协议，网际层提供ip协议的封装。所以，一般情况下，调用套接字的层序默认的协议Tcp/Udp以及ip协议，http协议可以在应用层自己定制。&lt;/p&gt;

&lt;h2 id=&quot;retransmission&quot;&gt;2.Retransmission：&lt;/h2&gt;
&lt;p&gt;TCP协议是一个可靠的协议。它通过重新发送(retransmission)来实现TCP片段传输的可靠性。简单的说，TCP会不断重复发送TCP片段，直到片段被正确接收。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;3.协议：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;* 网际层协议：包括：IP协议、ICMP协议（Ping）、ARP协议(用于广播发现)、RARP协议。
* 传输层协议：TCP协议、UDP协议。
* 应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;fiddlerwireshark&quot;&gt;4.fiddler和wireshark&lt;/h2&gt;
&lt;p&gt;fiddler可以监听抓取手机发送的包，是因为它本身具有&lt;strong&gt;代理功能&lt;/strong&gt;，手机通过这个代理的端口上网，fiddler监听这个代理端口从而抓取到手机的网络数据包，并且&lt;strong&gt;修改完监听的端口一定要重启应用才能生效&lt;/strong&gt;。wireshark则没有代理功能。所以单纯修改手机代理为同一局域网内电脑地址，并设置端口，在电脑中用wireshark虽然能抓到该端口有数据包，但是这些数据包是不能发送出去的，也就是说手机设置代理后是上不了网的，因为wireshark只负责抓包，没有代理功能。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;5.数据包类型含义：&lt;/h2&gt;

&lt;p&gt;SYN表示建立连接，&lt;/p&gt;

&lt;p&gt;FIN表示关闭连接，&lt;/p&gt;

&lt;p&gt;ACK表示响应，&lt;/p&gt;

&lt;p&gt;PSH表示有 DATA数据传输，&lt;/p&gt;

&lt;p&gt;RST表示连接重置。&lt;/p&gt;

&lt;h2 id=&quot;tcp-spurious-retransmission&quot;&gt;6.tcp spurious retransmission：&lt;/h2&gt;

&lt;h3 id=&quot;tcp&quot;&gt;tcp虚假重传&lt;/h3&gt;

&lt;p&gt;指实际上并没有超时，但看起来超时了，导致虚假超时重传的原因有很多种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于部分移动网络，当网络发生切换时会导致网络延时突增&lt;/li&gt;
  &lt;li&gt;当网络的可用带宽突然变小时，网络rtt会出现突增的情况，这会导致虚假超时重传&lt;/li&gt;
  &lt;li&gt;网络丢包（原始和重传的包都有可能丢包）会导致虚假重传超时。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;wireshark&quot;&gt;7.wireshark捕获的包：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Frame：物理层的数据帧概况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ethernet II：数据链路层以太网帧头部信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Internet Protocol Version 4：互联网层IP包头部信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Transmission Control Protocol：传输层的数据段头部信息，此处是TCP协议。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hypertext Transfer Protocol：应用层的信息，此处是HTTP协议。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;socketwireshark&quot;&gt;8.socket通过wireshark捕获的包示例&lt;/h2&gt;
&lt;p&gt;通过socket正常建立tcp连接时，会先通过握手，然后发送消息，当找不到服务器时，会收到一个重置连接的包&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;正常连接的包&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog_wireshark_socket.png&quot; alt=&quot;正常连接情况&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;对应端口没有开服务，会直接被拒绝&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog_wireshark_disconnect.png&quot; alt=&quot;找不到服务器&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;找不到服务器(地址)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/not-find-server.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;finackclosewaitfinackfinackclosewait&quot;&gt;正常关闭(客户端发送关闭连接的包FIN_ACK,服务端收到后做相应关闭处理(参见下文CLOSE_WAIT)，然后发送FIN_ACK做最后确认,如果只有一个FIN_ACK包，就是服务端停在了CLOSE_WAIT状态，最后会发现保持了大量的连接)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/close-normal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;异常关闭&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/close-error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;netstat&quot;&gt;9.通过netstat命令得到的信息：&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/kobejayandy/article/details/17655739&quot;&gt;引用出处&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;常用的三个状态是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ESTABLISHED 表示正在通信，&lt;/li&gt;
  &lt;li&gt;TIME_WAIT 表示主动关闭，&lt;/li&gt;
  &lt;li&gt;CLOSE_WAIT 表示被动关闭。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP协议规定，对于已经建立的连接，网络双方要进行四次握手才能成功断开连接，如果缺少了其中某个步骤，将会使连接处于假死状态，连接本身占用的资源不会被释放。网络服务器程序要同时管理大量连接，所以很有必要保证无用连接完全断开，否则大量僵死的连接会浪费许多服务器资源。在众多TCP状态中，最值得注意的状态有两个：CLOSE_WAIT和TIME_WAIT。&lt;/p&gt;

&lt;h3 id=&quot;timewait&quot;&gt;TIME_WAIT&lt;/h3&gt;

&lt;p&gt;TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。  由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接&lt;/p&gt;

&lt;h3 id=&quot;closewait&quot;&gt;CLOSE_WAIT&lt;/h3&gt;

&lt;p&gt;CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。&lt;/p&gt;

&lt;p&gt;为什么需要 TIME_WAIT 状态？&lt;/p&gt;

&lt;p&gt;假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，client必须进入 TIME_WAIT 状态，因为client可能面 临重发最终ACK的情形。&lt;br /&gt;
为什么 TIME_WAIT 状态需要保持 2MSL 这么长的时间？&lt;br /&gt;
如果 TIME_WAIT 状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP实现必须防止某个连接的重复报文在连接终止后出现，所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被 丢弃。建立第二个连接的时候，不会混淆。&lt;br /&gt;
 TIME_WAIT 和CLOSE_WAIT状态socket过多&lt;/p&gt;

&lt;p&gt;如果服务器出了异常，百分之八九十都是下面两种情况：&lt;br /&gt;
1.服务器保持了大量TIME_WAIT状态&lt;br /&gt;
2.服务器保持了大量CLOSE_WAIT状态，简单来说CLOSE_WAIT数目过大是由于被动关闭连接处理不当导致的。&lt;/p&gt;

&lt;h2 id=&quot;tcp-window-full&quot;&gt;10.TCP Window Full&lt;/h2&gt;

&lt;p&gt;tcp滑动窗口接收达到上限，此时会在响应包中告诉发送端，自己窗口达到上限，发送端就不再发送消息。&lt;/p&gt;

&lt;h3 id=&quot;wiresharkwin&quot;&gt;通过wireshark捕获的包,每条包信息后面的win就是本机向对方告知的本机接收窗口大小&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/tcp-window-full.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;单个包详情&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/tcp-window-full-details.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;糊涂窗口综合症&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/tcp-window-full-pic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我这里遇到的问题是客户端向服务端发送包，服务端没有从滑动窗口及时取出数据，导致服务端接收窗口不断减小，从服务端TCP发回的响应信息就可以看出。最终，服务端接收窗口为零。客户端被告知服务端接收窗口为零，于是向服务端发送TCP window Full包，标志客户端不再发送正常数据包，开始进入零窗口探测模式，隔一段时间发送一个TCP ZerowindowProbe包，进行探测服务端是否能接收数据。&lt;/p&gt;

&lt;p&gt;参考资料:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/awpatp/archive/2013/02/17/2914152.html&quot;&gt;什么是TCP Window&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/olartan/p/4268269.html&quot;&gt;Windows系统下的TCP参数优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/woaiyy/p/3554182.html&quot;&gt;TCP窗口滑动以及拥塞控制1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-26548237-id-3966297.html&quot;&gt;TCP的流量控制与拥塞控制2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Android基站定位</title>
        <link>http://www.liuschen.com/2016/09/15/BLocation.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/09/15/BLocation.html</guid>
        <pubDate>Thu, 15 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;定位是一项精细的活，现在GPS基本上已经成为了手机上的一项基本功能，但同时它也有诸多的限制，如启动慢，受环境影响明显等，所以后来又有诸多辅助定位的手段，如基站定位，和WiFi定位，不过两者却都是需要基于庞大的数据支持，也就是必须有基站和WiFi热点与真实GPS坐标映射的数据库才行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;gsm--umts--lte&quot;&gt;1. GSM / UMTS / LTE&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; MCC，Mobile Country Code，移动国家代码（中国的为460）；
 MNC，Mobile Network Code，移动网络号码（00移动 01联通 11电信4G）； 
 LAC/TAC(1~65535)，Location Area Code，位置区域码；
 CID/CI( 2G(1~65535), 3G/4G(1~268435455))，Cell Identity，基站编号；
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;android&quot;&gt;android手机的获取:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;TelephonyManager manager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);

 String operator = manager.getNetworkOperator();
 /**通过operator获取 MCC 和MNC */
 int MCC = Integer.parseInt(operator.substring(0, 3));
 int MNC = Integer.parseInt(operator.substring(3));

 GsmCellLocation location = (GsmCellLocation) manager.getCellLocation();

 /**通过GsmCellLocation获取中国移动和联通 LAC 和cellID */
 int LAC = location.getLac();
 int CID = location.getCid(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cdma&quot;&gt;2. CDMA&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;BID(1~65535):cdmaCellLocation.getBaseStationId()（基站ID,同GSM的CID）
NID(0~65535):cdmaCellLocation.getNetworkId() (网络ID,同GSM的LAC)
SID(0~32767):cdmaCellLocation.getSystemId() (同GSM的MNC)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;android-1&quot;&gt;android手机中的获取&lt;/h3&gt;

 		TelephonyManager manager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;    CdmaCellLocation location = (CdmaCellLocation)manager.getCellLocation();
    int BID = location.getBaseStationId();
    int NID = location.getNetworkId();
	int SID = location.getSystemId();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;3. 手机信号的获取&lt;/h2&gt;

&lt;p&gt;Android可以通过以下代码获取到手机收到的所有信号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TelephonyManager manager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    String operator = manager.getNetworkOperator();
    /**通过operator获取 MCC 和MNC */
    int mcc = Integer.parseInt(operator.substring(0, 3));
    int mnc = Integer.parseInt(operator.substring(3));

    List&amp;lt;CellInfo&amp;gt; allCellInfo =  manager.getAllCellInfo();
    String result = &quot;&quot;;
    for (CellInfo info:allCellInfo) {

        if(info instanceof CellInfoCdma){
            CellIdentityCdma cellIdentityCdma = ((CellInfoCdma)info).getCellIdentity();
            result += &quot;BaseStationId:&quot;+cellIdentityCdma.getBasestationId()
                    +&quot;,NetworkId:&quot;+cellIdentityCdma.getNetworkId()+&quot;,SystemId：&quot;
                    +cellIdentityCdma.getSystemId()+&quot;,signal&quot;+((CellInfoCdma)info).getCellSignalStrength()+&quot;\n&quot;;
        }else if(info instanceof CellInfoLte){
            CellIdentityLte cellIdentityLte = ((CellInfoLte)info).getCellIdentity();
            result += &quot;Mnc:&quot;+cellIdentityLte.getMnc()
                    +&quot;,Ci:&quot;+cellIdentityLte.getCi()+&quot;,Tac：&quot;
                    +cellIdentityLte.getTac()+&quot;,signal&quot;+((CellInfoLte)info).getCellSignalStrength()+&quot;\n&quot;;
        }else if(info instanceof CellInfoGsm){
            CellIdentityGsm cellIdentityGsm = ((CellInfoGsm)info).getCellIdentity();
            result += &quot;Mnc:&quot;+cellIdentityGsm.getMnc()
                    +&quot;,Cid:&quot;+cellIdentityGsm.getCid()+&quot;,Lac：&quot;
                    +cellIdentityGsm.getLac()+&quot;,signal&quot;+((CellInfoGsm)info).getCellSignalStrength()+&quot;\n&quot;;
        }else if(info instanceof CellInfoWcdma){
            CellIdentityWcdma cellIdentityWcdma = ((CellInfoWcdma)info).getCellIdentity();
            result += &quot;Mnc:&quot;+cellIdentityWcdma.getMnc()
                    +&quot;,Cid:&quot;+cellIdentityWcdma.getCid()+&quot;,Lac：&quot;
                    +cellIdentityWcdma.getLac()+&quot;,signal&quot;+((CellInfoWcdma)info).getCellSignalStrength()+&quot;\n&quot;;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个if条件中得到的结果前面三个大抵是每个基站的标识以及区域信息，就如上面的MNC,CID之类的，而最后一个是获取的信号强度SignalStrength，第一个CellInfoCdma能获取到这几个值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int mCdmaDbm;   // This value is the RSSI value
private int mCdmaEcio;  // This value is the Ec/Io
private int mEvdoDbm;   // This value is the EVDO RSSI value
private int mEvdoEcio;  // This value is the EVDO Ec/Io
private int mEvdoSnr;   // Valid values are 0-8.  8 is the highest signal to noise ratio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;RSSI&lt;/strong&gt;:Received Signal Strength Indication接收的信号强度指示，无线发送层的可选部分，用来判定链接质量，以及是否增大广播发送强度，可用来测算距离&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/lele/articles/2832885.html&quot;&gt;RSSI为什么是负值&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ec/Io&lt;/strong&gt;:这是一个反映手机端当前接收的导频信号（Pilot）的水平。手机开机首先做的事情就是搜索导频信号，如果搜索不到有用的导频信号，手机就无法正确识别网络。很多时候，手机经常会处在很多基站重叠覆盖的区域，也就是有很多导频的区域。各个导频之间也会相互干扰，形成导频污染。Ec表示手机当前接收到的可用导频信号强度，Io表示手机当前所接收到的所有干扰信号强度。所以，Ec/Io就表明手机当前所接收到的有用信号和干扰信号的比例。反映了手机在这一点上多路导频信号的整体覆盖水平。&lt;/p&gt;

&lt;p&gt;第二个CellInfoLte能获取到的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int mSignalStrength;  //信号强度
private int mRsrp;			  //表示LTE参考信号接收质量，这种度量主要是根据信号质量来对不同LTE候选小区进行排序。这种测量用作切换和小区重选决定的输入。
private int mRsrq;            //表示发送信号质量
private int mRssnr;
private int mCqi;
private int mTimingAdvance;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三个CellSignalStrengthGsm和第四个CellSignalStrengthWcdma能获取到的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int mSignalStrength; // Valid values are (0-31, 99) as defined in TS 27.007 8.5
private int mBitErrorRate;   // bit error rate (0-7, 99) as defined in TS 27.007 8.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里可能会郁闷，lte,cdma,gsm这些是什么？这些是手机用到的通信技术，具体解释网上很多，而划分到三大运营商如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;中国移动，2G：GSM，3G：TD-SCDMA ,4G:TD-LTE&lt;/li&gt;
  &lt;li&gt;中国联通，2G：GSM，3G：WCDMA ,4G:FDD-LTE&lt;/li&gt;
  &lt;li&gt;中国电信，2G：CDMA（实际上相当于2.5G），3G：CDMA 2000 ,4G:FDD-LTE、TD-LTE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Android内部区分信号类型是按照如下规则:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch (networkType) {
        case NETWORK_TYPE_GPRS:
        case NETWORK_TYPE_GSM:
        case NETWORK_TYPE_EDGE:
        case NETWORK_TYPE_CDMA:
        case NETWORK_TYPE_1xRTT:
        case NETWORK_TYPE_IDEN:
            return NETWORK_CLASS_2_G;
        case NETWORK_TYPE_UMTS:
        case NETWORK_TYPE_EVDO_0:
        case NETWORK_TYPE_EVDO_A:
        case NETWORK_TYPE_HSDPA:
        case NETWORK_TYPE_HSUPA:
        case NETWORK_TYPE_HSPA:
        case NETWORK_TYPE_EVDO_B:
        case NETWORK_TYPE_EHRPD:
        case NETWORK_TYPE_HSPAP:
        case NETWORK_TYPE_TD_SCDMA:
            return NETWORK_CLASS_3_G;
        case NETWORK_TYPE_LTE:
        case NETWORK_TYPE_IWLAN:
            return NETWORK_CLASS_4_G;
        default:
            return NETWORK_CLASS_UNKNOWN;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些信号类型是为了针对不同手机卡不同返回值做具体处理用的，但是返回的东西的用途确是一样的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基站标识，用来从已经知道的数据库中取出对应的卫星坐标，这个获取数据库是关键，网上有许多付费提供的接口，有些免费，却限制次数，但是所幸，我需要做基站定位的地方，区域有限，想取到这些位置可能覆盖到的基站信息可能并不难，只需要写一个程序，拿着手机在区域内到处走走，搜集到所有基站的信息，然后自己建个数据库即可（0），也可以用网上限制次数的免费接口，反正只用一次也足够，总之，方法很多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当前位置距离基站的距离，这个对于我而言比较复杂，我能想到的有两种方法，一是通过电波到达时间来算距离，即TDOA定位，但是找不到获取对应信息的方法，只能放弃，二是通过信号强度来计算出自己距离基站的位置，而信号强度上面已经获取到了，只剩下计算的方法（1）（2）。获取到距离后通过三个或三个以上的基站就可以定位到当前位置。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（0）&lt;a href=&quot;http://www.gpsspg.com/bs.htm&quot;&gt;基站查询&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;（1）&lt;a href=&quot;http://www.cnblogs.com/magicboy110/archive/2010/12/10/1902741.html&quot;&gt;比较详细的参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;（2）&lt;a href=&quot;http://www.360doc.com/content/15/0725/11/8493019_487280425.shtml&quot;&gt;自由空间路径传播损耗&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;除了基站定位，还有WiFi定位，与基站定位原理一样，只要附近有WiFi，不需要连接上，只需获取其唯一的标识，然后通过数据库查询其对应的坐标即可，数据库的建立是问题，毕竟WiFi哪里都是，于是有人说，找几个出租，给些钱，装上GPS与WiFi连接对应设备到处跑，不是也很快吗，想想也是，一些看似庞大的工程，其实往往不难，只要用对地方，我们平时常用app，谁知道会不会把我们连接的WiFi和已经获取GPS坐标绑定上传呢。&lt;/p&gt;

&lt;p&gt;以上是Android基站定位的原理，其实如果不执着于完全的自主开发，完全可以用第三方提供的服务如&lt;a href=&quot;http://lbsyun.baidu.com/index.php?title=android-locsdk&quot;&gt;百度定位&lt;/a&gt;，大致原理相同，但是很多算法不需要自己去考虑。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>netty point</title>
        <link>http://www.liuschen.com/2016/08/26/netty-point.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/08/26/netty-point.html</guid>
        <pubDate>Fri, 26 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;channelfuture&quot;&gt;1. ChannelFuture的作用&lt;/h2&gt;
&lt;p&gt;channelFuture 是为了保存channel异步操作的结果的，在Netty中所有的IO操作都是异步的，因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFuture,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之，所有的操作都会返回一个ChannelFuture。&lt;/p&gt;

&lt;h2 id=&quot;ctxclose-and-ctxchannelcloseoverflowhttpstackoverflowcomquestions21240981in-netty-4-whats-the-difference-between-ctx-close-and-ctx-channel-close&quot;&gt;2. ctx.close and ctx.channel.close的区别（&lt;a href=&quot;http://stackoverflow.com/questions/21240981/in-netty-4-whats-the-difference-between-ctx-close-and-ctx-channel-close&quot;&gt;引用自overflow&lt;/a&gt;）&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Let’s say we have three handlers in the pipeline, and they all intercept the close() operation, and calls ctx.close() in it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;ChannelPipeline p = ...;
p.addLast(&quot;A&quot;, new SomeHandler());
p.addLast(&quot;B&quot;, new SomeHandler());
p.addLast(&quot;C&quot;, new SomeHandler());
...

public class SomeHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {
        ctx.close(promise);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Channel.close() will trigger C.close(), B.close(), A.close(), and then close the channel.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;ChannelPipeline.context(“C”).close() will trigger B.close(), A.close(), and then close the channel.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;ChannelPipeline.context(“B”).close() will trigger A.close(), and then close the channel.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;ChannelPipeline.context(“A”).close() will close the channel. No handlers will be called.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;So, when you should use Channel.close() and ChannelHandlerContext.close()? The rule of thumb is:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you are writing a ChannelHandler and wanna close the channel in the handler, call ctx.close().&lt;br /&gt;
If you are closing the channel from outside the handler (e.g. you have a background thread which is not an I/O thread, and you want to close the connection from that thread.)&lt;/p&gt;

&lt;h2 id=&quot;channelpromise&quot;&gt;3. ChannelPromise的作用&lt;/h2&gt;

&lt;p&gt;Promise与future的不同在于它可以设置自己的状态，是在future之上的扩展。所以Promise是netty内部用到的，给返回给用户的对象Future是同一个。&lt;/p&gt;

&lt;h2 id=&quot;shutdowngracefully&quot;&gt;4. 优雅关闭shutdownGracefully&lt;/h2&gt;

&lt;p&gt;这是一个有效的关闭客户端/服务端的方法，会向对方发送结束连接请求，同时关闭信道和Pipeline，同时退出循环(结束线程等待，向下执行)。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>netty框架是如何执行connect连接的</title>
        <link>http://www.liuschen.com/2016/08/25/netty_connect.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/08/25/netty_connect.html</guid>
        <pubDate>Thu, 25 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;连接&lt;/h1&gt;

&lt;p&gt;以客户端为例，netty是通过以下代码发起服务请求的，其中b是Bootstrap的实例对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;future = b.connect(new InetSocketAddress(host, port)).sync();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而上面的connect方法是Bootstrap对象中的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public ChannelFuture connect(SocketAddress remoteAddress) {
    if(remoteAddress == null) {
        throw new NullPointerException(&quot;remoteAddress&quot;);
    } else {
        this.validate();
        return this.doConnect(remoteAddress, this.localAddress());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的doConnect对象是在同一个类中的方法，其中的ChannelFuture和PromiseFuture分别存储的是注册和连接的结果，和外部的对象有所区别，因为PromiseFuture是继承ChannelFuture的接口，其中多了一些设置的方法，这个方法是先初始化并且注册，然后如果成功的话，就开始进行连接操作，先做连 接代码的追踪&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private ChannelFuture doConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
    final ChannelFuture regFuture = this.initAndRegister();
    final Channel channel = regFuture.channel();
    if(regFuture.cause() != null) {
        return regFuture;
    } else {
        final ChannelPromise promise = channel.newPromise();
        if(regFuture.isDone()) {
            doConnect0(regFuture, channel, remoteAddress, localAddress, promise);
        } else {
            regFuture.addListener(new ChannelFutureListener() {
                public void operationComplete(ChannelFuture future) throws Exception {
                    Bootstrap.doConnect0(regFuture, channel, remoteAddress, localAddress, promise);
                }
            });
        }

        return promise;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的doConnect依然在同一个类中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static void doConnect0(final ChannelFuture regFuture, final Channel channel, final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
    channel.eventLoop().execute(new OneTimeTask() {
        public void run() {
            if(regFuture.isSuccess()) {
                if(localAddress == null) {
                    channel.connect(remoteAddress, promise);
                } else {
                    channel.connect(remoteAddress, localAddress, promise);
                }

                promise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            } else {
                promise.setFailure(regFuture.cause());
            }

        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后上面的connect方法是在channel接口中定义的方法，channel类继承关系如图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blognetty_channel.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中NioSocketChannel的继承关系：&lt;code&gt;NioSocketChannel extends AbstractNioByteChannel implements SocketChannel &lt;/code&gt;而AbstractNioByteChannel又继承于AbstractNioChannel，在AbstractNioChannel中在找到了connect的实现方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final void connect(final SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
        if(promise.setUncancellable() &amp;amp;&amp;amp; this.ensureOpen(promise)) {
            try {
                if(AbstractNioChannel.this.connectPromise != null) {
                    throw new IllegalStateException(&quot;connection attempt already made&quot;);
                }

                boolean t = AbstractNioChannel.this.isActive();
                if(AbstractNioChannel.this.doConnect(remoteAddress, localAddress)) {
                    this.fulfillConnectPromise(promise, t);
                } else {
                    AbstractNioChannel.this.connectPromise = promise;
                    AbstractNioChannel.this.requestedRemoteAddress = remoteAddress;
                    int connectTimeoutMillis = AbstractNioChannel.this.config().getConnectTimeoutMillis();
                    if(connectTimeoutMillis &amp;gt; 0) {
                        AbstractNioChannel.this.connectTimeoutFuture = AbstractNioChannel.this.eventLoop().schedule(new OneTimeTask() {
                            public void run() {
                                ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;
                                ConnectTimeoutException cause = new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress);
                                if(connectPromise != null &amp;amp;&amp;amp; connectPromise.tryFailure(cause)) {
                                    AbstractNioUnsafe.this.close(AbstractNioUnsafe.this.voidPromise());
                                }

                            }
                        }, (long)connectTimeoutMillis, TimeUnit.MILLISECONDS);
                    }

                    promise.addListener(new ChannelFutureListener() {
                        public void operationComplete(ChannelFuture future) throws Exception {
                            if(future.isCancelled()) {
                                if(AbstractNioChannel.this.connectTimeoutFuture != null) {
                                    AbstractNioChannel.this.connectTimeoutFuture.cancel(false);
                                }

                                AbstractNioChannel.this.connectPromise = null;
                                AbstractNioUnsafe.this.close(AbstractNioUnsafe.this.voidPromise());
                            }

                        }
                    });
                }
            } catch (Throwable var6) {
                promise.tryFailure(this.annotateConnectException(var6, remoteAddress));
                this.closeIfClosed();
            }

        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上的都Connect是由具体功能的实现类NioSocketChannel中实现具体方法的定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
    if(localAddress != null) {
        this.javaChannel().socket().bind(localAddress);
    }

    boolean success = false;

    boolean var5;
    try {
        boolean connected = this.javaChannel().connect(remoteAddress);
        if(!connected) {
            this.selectionKey().interestOps(8);
        }

        success = true;
        var5 = connected;
    } finally {
        if(!success) {
            this.doClose();
        }

    }

    return var5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终的承担者依旧是调用的Java中的nio来进行连接的&lt;code&gt;this.javaChannel().connect(remoteAddress)&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;注册&lt;/h1&gt;

&lt;p&gt;然后继续之前的注册操作的代码分析，先是跳转到AbstractBootstrap中，在这里面实际是同过&lt;code&gt;ChannelFuture regFuture = this.group().register(channel)&lt;/code&gt;来生成一个该方法返回的ChannelFuture&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final ChannelFuture initAndRegister() {
    Channel channel = this.channelFactory().newChannel();

    try {
        this.init(channel);
    } catch (Throwable var3) {
        channel.unsafe().closeForcibly();
        return (new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE)).setFailure(var3);
    }

    ChannelFuture regFuture = this.group().register(channel);
    if(regFuture.cause() != null) {
        if(channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }

    return regFuture;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而这个是接口EventLoopGroup中定义的方法，故名思义，EventLoopGroup就是一个集，或是池,其中继承关系如下所示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;EventLoopGroup
    &lt;ul&gt;
      &lt;li&gt;MultithreadEventLoopGroup
        &lt;ul&gt;
          &lt;li&gt;LocalEventLoopGroup&lt;/li&gt;
          &lt;li&gt;EpollEventLoopGroup&lt;/li&gt;
          &lt;li&gt;NioEventLoopGroup&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ThreadPerChannelEventLoopGroup
        &lt;ul&gt;
          &lt;li&gt;OioEventLoopGroup&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;EventLoop
        &lt;ul&gt;
          &lt;li&gt;SingleThreadEventLoop
            &lt;ul&gt;
              &lt;li&gt;EpollEventLoop&lt;/li&gt;
              &lt;li&gt;ThreadPerChannelEventLoop&lt;/li&gt;
              &lt;li&gt;LocalEventLoop&lt;/li&gt;
              &lt;li&gt;NioEventLoop&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;EmbeddedEventLoop&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并且其中的group是我们在外部通过实例化&lt;code&gt;private EventLoopGroup group = new NioEventLoopGroup();&lt;/code&gt;创建的，&lt;/p&gt;

&lt;p&gt;在NioEventLoopGroup的父类MultithreadEventLoopGroup中找到了对应的实现方法，next返回的是一个单独的执行单元EventLoop；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public ChannelFuture register(Channel channel) {
    return this.next().register(channel);
}

public EventLoop next() {
    return (EventLoop)super.next();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由上面的继承关系可以看出，要找到 &lt;code&gt;this.next().register(channel)&lt;/code&gt;的具体实现需要在SingleThreadEventLoop和NioEventLoop中寻找，在SingleThreadEventLoop中找到了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public ChannelFuture register(Channel channel) {
    return this.register(channel, new DefaultChannelPromise(channel, this));
}

public ChannelFuture register(Channel channel, ChannelPromise promise) {
    if(channel == null) {
        throw new NullPointerException(&quot;channel&quot;);
    } else if(promise == null) {
        throw new NullPointerException(&quot;promise&quot;);
    } else {
        channel.unsafe().register(this, promise);
        return promise;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TO BE CONTINUE&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>netty自带心跳响应</title>
        <link>http://www.liuschen.com/2016/08/20/netty-beat.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/08/20/netty-beat.html</guid>
        <pubDate>Sat, 20 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;netty客户端的写法，不再赘述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b.group(group).channel(NioSocketChannel.class)
				.option(ChannelOption.TCP_NODELAY, true)
				.handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
					@Override
					protected void initChannel(SocketChannel ch) throws Exception {
						
						ch.pipeline().addLast(new IdleStateHandler(HEARTBEAT_READABLE_INTERVAL_TIME,
									HEARTBEAT_WRITABLE_INTERVAL_TIME, HEARTBEAT_READ_WRITE_INTERVAL_TIME));
							ch.pipeline().addLast(&quot;HeartBeatHandler&quot;, new HeartBeatHandler(client));

					}

				});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IdleStateHandler类是为了监听空闲的状态，传入的参数分别为，读空闲，写空闲，以及读写空闲&lt;br /&gt;
而自定义的一个handler HeartBeatHandler则是为了复写其中的一个处理心跳的方法 userEventTriggered&lt;/p&gt;

&lt;h3 id=&quot;idlestatehandler&quot;&gt;IdleStateHandler类中有三个内部函数（任务函数）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;AllIdleTimeoutTask&lt;/li&gt;
  &lt;li&gt;ReaderIdleTimeoutTask&lt;/li&gt;
  &lt;li&gt;WriterIdleTimeoutTask&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而通过每一个任务函数中实现IdleStateEvent状态的赋值以及向下的透传，最终传到HeartBeatHandler中处理:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
         IdleStateEvent t;
         if(IdleStateHandler.this.firstWriterIdleEvent) {
         IdleStateHandler.this.firstWriterIdleEvent = false;
          t = IdleStateEvent.FIRST_WRITER_IDLE_STATE_EVENT;
             } else {
                        t = IdleStateEvent.WRITER_IDLE_STATE_EVENT;
                }

         IdleStateHandler.this.channelIdle(this.ctx, t);


protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {
    ctx.fireUserEventTriggered(evt);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于三个超时任务的执行主要是通过时间戳的对比来判断的&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;读:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
    if(this.readerIdleTimeNanos &amp;gt; 0L || this.allIdleTimeNanos &amp;gt; 0L) {
        this.lastReadTime = System.nanoTime();
        this.reading = false;
    }

    ctx.fireChannelReadComplete();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;写:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;this.writeListener = new ChannelFutureListener() {
        public void operationComplete(ChannelFuture future) throws Exception {
            IdleStateHandler.this.lastWriteTime = System.nanoTime();
            IdleStateHandler.this.firstWriterIdleEvent = IdleStateHandler.this.firstAllIdleEvent = true;
        }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在超时任务中，真正判断是否执行超时动作的是下面的函数（以读超时为例）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long nextDelay = IdleStateHandler.this.readerIdleTimeNanos;
            if(!IdleStateHandler.this.reading) {
                nextDelay -= System.nanoTime() - IdleStateHandler.this.lastReadTime;
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nextDelay：赋的值是用户设置的也就是传IdleStateHandler构造函数的的值，然后该值减去（当前时间-上次动作完成的时间），如果结果小于0就表示超时了。&lt;/p&gt;

&lt;p&gt;而读写超时略有不同，取的是上次读写完成时间中距离现在最近的时间为上次读写完成时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;long nextDelay = IdleStateHandler.this.allIdleTimeNanos;
            if(!IdleStateHandler.this.reading) {
                nextDelay -= System.nanoTime() - Math.max(IdleStateHandler.this.lastReadTime, IdleStateHandler.this.lastWriteTime);
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，超时任务是从handler添加时就已经开始执行的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
    if(ctx.channel().isActive() &amp;amp;&amp;amp; ctx.channel().isRegistered()) {
        this.initialize(ctx);
    }
}

private void initialize(ChannelHandlerContext ctx) {
    switch(this.state) {
    case 1:
    case 2:
        return;
    default:
        this.state = 1;
        EventExecutor loop = ctx.executor();
        this.lastReadTime = this.lastWriteTime = System.nanoTime();
        if(this.readerIdleTimeNanos &amp;gt; 0L) {
            this.readerIdleTimeout = loop.schedule(new IdleStateHandler.ReaderIdleTimeoutTask(ctx), this.readerIdleTimeNanos, TimeUnit.NANOSECONDS);
        }

        if(this.writerIdleTimeNanos &amp;gt; 0L) {
            this.writerIdleTimeout = loop.schedule(new IdleStateHandler.WriterIdleTimeoutTask(ctx), this.writerIdleTimeNanos, TimeUnit.NANOSECONDS);
        }

        if(this.allIdleTimeNanos &amp;gt; 0L) {
            this.allIdleTimeout = loop.schedule(new IdleStateHandler.AllIdleTimeoutTask(ctx), this.allIdleTimeNanos, TimeUnit.NANOSECONDS);
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;鉴于此，也就是说，IdleStateHandler在添加到handler链中时就已经开始执行它的超时任务，以设置的时间间隔为周期，不停的检查是否超时，一旦超时就会执行超时任务对应动作向下透传，在自定义的心跳handler中通过特定函数捕获&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
	if(IdleStateEvent.class.isAssignableFrom(evt.getClass())){
		IdleStateEvent event = (IdleStateEvent) evt;
		if(event.state() == IdleState.WRITER_IDLE){

		}else if(event.state() == IdleState.READER_IDLE){

		}else if (event.state() == IdleState.ALL_IDLE){
			
		}
	}
	ctx.fireUserEventTriggered(evt);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>android svg动画</title>
        <link>http://www.liuschen.com/2016/08/12/AndroidSVG.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/08/12/AndroidSVG.html</guid>
        <pubDate>Fri, 12 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;用过矢量绘图的人都应该知道svg是一种矢量图的格式，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --&amp;gt;
&amp;lt;svg version=&quot;1.1&quot; id=&quot;图层_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot;
	 viewBox=&quot;0 0 595.3 841.9&quot; style=&quot;enable-background:new 0 0 595.3 841.9;&quot; xml:space=&quot;preserve&quot;&amp;gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;
	.st0{fill:none;stroke:#000000;stroke-miterlimit:10;}
	.st1{fill:url(#XMLID_18_);stroke:#131320;stroke-miterlimit:10;}
	.st2{fill:#E21B15;stroke:#131320;stroke-miterlimit:10;}
	.st3{fill:none;stroke:#131320;stroke-miterlimit:10;}
&amp;lt;/style&amp;gt;
&amp;lt;line id=&quot;XMLID_1_&quot; class=&quot;st0&quot; x1=&quot;133.3&quot; y1=&quot;145.4&quot; x2=&quot;54.7&quot; y2=&quot;344.4&quot;/&amp;gt;
&amp;lt;line id=&quot;XMLID_2_&quot; class=&quot;st0&quot; x1=&quot;183.3&quot; y1=&quot;393.4&quot; x2=&quot;297.6&quot; y2=&quot;448.5&quot;/&amp;gt;
&amp;lt;line id=&quot;XMLID_3_&quot; class=&quot;st0&quot; x1=&quot;268&quot; y1=&quot;203.6&quot; x2=&quot;159.8&quot; y2=&quot;274&quot;/&amp;gt;
&amp;lt;line id=&quot;XMLID_4_&quot; class=&quot;st0&quot; x1=&quot;94&quot; y1=&quot;444.4&quot; x2=&quot;202.7&quot; y2=&quot;626.1&quot;/&amp;gt;
&amp;lt;line id=&quot;XMLID_5_&quot; class=&quot;st0&quot; x1=&quot;426.2&quot; y1=&quot;256.7&quot; x2=&quot;240.5&quot; y2=&quot;330.1&quot;/&amp;gt;
&amp;lt;line id=&quot;XMLID_6_&quot; class=&quot;st0&quot; x1=&quot;285.3&quot; y1=&quot;368.9&quot; x2=&quot;437.4&quot; y2=&quot;420.9&quot;/&amp;gt;
&amp;lt;line id=&quot;XMLID_7_&quot; class=&quot;st0&quot; x1=&quot;437.4&quot; y1=&quot;256.7&quot; x2=&quot;589.4&quot; y2=&quot;308.7&quot;/&amp;gt;
&amp;lt;line id=&quot;XMLID_8_&quot; class=&quot;st0&quot; x1=&quot;589.4&quot; y1=&quot;308.7&quot; x2=&quot;461.9&quot; y2=&quot;421&quot;/&amp;gt;
&amp;lt;linearGradient id=&quot;XMLID_18_&quot; gradientUnits=&quot;userSpaceOnUse&quot; x1=&quot;262.8693&quot; y1=&quot;119.1227&quot; x2=&quot;533.773&quot; y2=&quot;121.9446&quot;&amp;gt;
	&amp;lt;stop  offset=&quot;0&quot; style=&quot;stop-color:#FFFFFF&quot;/&amp;gt;
	&amp;lt;stop  offset=&quot;1&quot; style=&quot;stop-color:#000000&quot;/&amp;gt;
&amp;lt;/linearGradient&amp;gt;
&amp;lt;rect id=&quot;XMLID_9_&quot; x=&quot;254.7&quot; y=&quot;76.1&quot; class=&quot;st1&quot; width=&quot;270.9&quot; height=&quot;88.8&quot;/&amp;gt;
&amp;lt;path id=&quot;XMLID_10_&quot; class=&quot;st2&quot; d=&quot;M420,525L291.5,775c-5.1-1-115.8-23.3-133.7-93.9c-19.5-77.1,87.3-151.4,154.1-178.6
	c55.7-22.7,154.6-41.6,183.7,0c29,41.5-14.9,138.2-115.3,233.7c-3.1,0.3-6.1,0.7-9.2,1&quot;/&amp;gt;
&amp;lt;path id=&quot;XMLID_11_&quot; class=&quot;st2&quot; d=&quot;M-165.7,640.3&quot;/&amp;gt;
&amp;lt;path id=&quot;XMLID_12_&quot; class=&quot;st3&quot; d=&quot;M365,333.4c21.5,0.8,43.1-0.7,64.2-4.6&quot;/&amp;gt;
&amp;lt;path id=&quot;XMLID_13_&quot; class=&quot;st3&quot; d=&quot;M428.6,292.9c-3.3,5.5-5.7,11.5-8.4,17.2c-9.1,19.4-22.3,37-38.4,51.1&quot;/&amp;gt;
&amp;lt;path id=&quot;XMLID_14_&quot; class=&quot;st3&quot; d=&quot;M398.7,334c4.2-1.5,8,2.8,10.4,6.6c6.3,10.2,12.7,20.3,19,30.5&quot;/&amp;gt;
&amp;lt;line id=&quot;XMLID_15_&quot; class=&quot;st3&quot; x1=&quot;36.4&quot; y1=&quot;371.1&quot; x2=&quot;-92.2&quot; y2=&quot;621.1&quot;/&amp;gt;
&amp;lt;line id=&quot;XMLID_16_&quot; class=&quot;st3&quot; x1=&quot;-92.2&quot; y1=&quot;631.2&quot; x2=&quot;306.8&quot; y2=&quot;198.5&quot;/&amp;gt;
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有点像js和xml,如果要在android上绘制，就需要先对它进行解析操作，再进行绘制。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>AndroidStudio版本更新记录</title>
        <link>http://www.liuschen.com/2016/08/11/Androidstudioupdatelike.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/08/11/Androidstudioupdatelike.html</guid>
        <pubDate>Thu, 11 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;对于开发者而言，最重要的无疑是开发工具的使用，做Android开发之前用的是eclipse，现在用的则是Google的Androidstudio，我不常更新工具，太麻烦也常常会出现很多问题，但是也会因此错过很多新的东西，比如Google的版本，每次更新总会带来很多新奇的特性，懒惰即是错过，虽然之前有同事因为更新出现了诸多问题，耗费了时间，最终也没能成功。但是，仔细想想这些都不是什么问题，尤其是现在我相对比较闲的情况下。&lt;/p&gt;

&lt;p&gt;首先是下载，在官网上下在&lt;br /&gt;
android-studio-bundle-143.2915827-windows.exe&lt;br /&gt;
当然如无法下载也可以在网上搜索下载。&lt;br /&gt;
我安装的2.1.2貌似是最新的版本。但是安装完后运行之前的程序，果不其然，报了一堆错.&lt;/p&gt;

&lt;p&gt;首先是gradle版本不匹配，当前是2.1.2而我之前项目是1.3&lt;br /&gt;
然后就提示我是否更新，更新项目gradle到新版本有好处云云。然后我就同意了，然后就报错了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error:Gradle version 2.10 is required. Current version is 2.4. If using the gradle wrapper, try editing the distributionUrl in D:\softku\wangpan\AndroidAppBook\gradle\wrapper\gradle-wrapper.properties to gradle-2.10-all.zip
&amp;lt;a href=&quot;fixGradleVersionInWrapper&quot;&amp;gt;Fix Gradle wrapper and re-import project&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;lt;a href=&quot;openGradleSettings&quot;&amp;gt;Gradle settings&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是gradle版本问题，需要翻墙下载，当然也可以单独下载&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://services.gradle.org/distributions&quot;&gt;http://services.gradle.org/distributions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;而在项目的gradle\wrapper下面的gradle-wrapper.properties文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Thu Aug 11 08:37:08 CST 2016
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以修改项目依赖的gradle版本下载地址&lt;/p&gt;

&lt;p&gt;最后也就是做这些的目的，运行一些之前由于需要版本过高运行不了的项目，运行后依然报错，由于用的sdk是老的，缺少高版本的sdk，于是我将新安装的sdk下add-ons,platforms，system-images,build-tools和platform-tools下对应的版本sdk文件copy到了旧的Sdk(因为下的版本较多，很大)中，再次运行程序，成功。AndroidStudio更新成功。&lt;/p&gt;

&lt;p&gt;有时候导入版本较早工程时会报&lt;br /&gt;
Gradle DSL method not found: ‘runProguard()’&lt;/p&gt;

&lt;p&gt;原因是这个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildTypes {
    release {

        runProguard false // 已经被废弃并且停止使用了

        ......
    }
}
new:

buildTypes {
    release {

        minifyEnabled false // 替代的方式

        ......
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改一下就好了。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Androidstudio下的代码混淆</title>
        <link>http://www.liuschen.com/2016/08/05/proguard.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/08/05/proguard.html</guid>
        <pubDate>Fri, 05 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;首先在项目的build.gradle中Android标签下添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signingConfigs {
    release {
        keyAlias &#39;xxx&#39;
        keyPassword &#39;xxx&#39;
        storeFile file(&#39;xxx&#39;)
        storePassword &#39;xxx&#39;
    }
}

buildTypes {
    release {
        signingConfig signingConfigs.release
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中第二个是混淆的设置，第一个配置的是数字签名的路径以及密码等信息，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signingConfig signingConfigs.release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;个是依赖于这项配置的，不然会报错&lt;/p&gt;

&lt;p&gt;然后，就是配置混淆的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-ignorewarnings
-optimizationpasses 5          # 指定代码的压缩级别
-dontusemixedcaseclassnames   # 是否使用大小写混合
-dontpreverify           # 混淆时是否做预校验
-verbose                # 混淆时是否记录日志


-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*  # 混淆时所采用的算法

-keep public class * extends android.app.Activity      # 保持哪些类不被混淆
-keep public class * extends android.app.Application   # 保持哪些类不被混淆
-keep public class * extends android.app.Service       # 保持哪些类不被混淆
-keep public class * extends android.content.BroadcastReceiver  # 保持哪些类不被混淆
-keep public class * extends android.content.ContentProvider    # 保持哪些类不被混淆
-keep public class * extends android.app.backup.BackupAgentHelper # 保持哪些类不被混淆
-keep public class * extends android.preference.Preference        # 保持哪些类不被混淆
-keep public class com.android.vending.licensing.ILicensingService    # 保持哪些类不被混淆

-keep class javax.security.** { *; }


-keepclasseswithmembernames class * {  # 保持 native 方法不被混淆
    native &amp;lt;methods&amp;gt;;
}
-keepclasseswithmembers class * {   # 保持自定义控件类不被混淆
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet);
}
-keepclasseswithmembers class * {# 保持自定义控件类不被混淆
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet, int);
}
-keepclassmembers class * extends android.app.Activity { # 保持自定义控件类不被混淆
    public void *(android.view.View);
}
-keepclassmembers enum * {     # 保持枚举 enum 类不被混淆
    public static **[] values();
    public static ** valueOf(java.lang.String);
}
-keep class * implements android.os.Parcelable { # 保持 Parcelable 不被混淆
    public static final android.os.Parcelable$Creator *;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下，系统的控件不必要混淆，如activity，service等，其次由于默在Androidstudio中默认已经将libs包中的jar添加了，重复添加反而会报错，最后项目中用到反射的地方一定不能混淆。&lt;br /&gt;
添加完后却还是报错了，先添加了-dontwarn，然并没什么用，然后加了-ignorewarnings忽略警告，成功生成apk,只是一定要注意确保警告中的地方没被项目调用，否则实际运行时还会出错，后果更严重。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>nine patch图片的用法绘制以及作用</title>
        <link>http://www.liuschen.com/2016/08/02/nine.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/08/02/nine.html</guid>
        <pubDate>Tue, 02 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;问题:&lt;/p&gt;

&lt;p&gt;今天从网上down下了一个eclipse下的项目，导入到androidStudio中后，结果出现了如下异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\myAllProject\androidstudio_ajlast\321Browser\uCBrowser_1113\src\main\res\layout\above_slidingmenu.xml
Error:(111, 30) No resource found that matches the given name (at &#39;src&#39; with value &#39;@drawable/menubar_tabcenter_d&#39;).

Error:(20, 38) No resource found that matches the given name (at &#39;src&#39; with value &#39;@drawable/url_progress_fullscreen&#39;).
D:\myAllProject\androidstudio_ajlast\321Browser\uCBrowser_1113\src\main\res\drawable\search_btn_bg.xml
Error:(5, 87) No resource found that matches the given name (at &#39;drawable&#39; with value &#39;@drawable/search_engines_switcher_item_bg_p&#39;).
Error:(6, 87) No resource found that matches the given name (at &#39;drawable&#39; with value &#39;@drawable/search_engines_switcher_item_bg_p&#39;).
Error:Execution failed for task &#39;:uCBrowser_1113:processDebugResources&#39;.
com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &#39;command &#39;F:\programer\android_sdk\build-tools\23.0.2\aapt.exe&#39;&#39; finished with non-zero exit value 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纠结了很久发现都是.9图片的问题，于是按照网上说的在android的gradle中android标签下加入下面代码，避免了对 .9图片的检查&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aaptOptions.cruncherEnabled = false
aaptOptions.useNewCruncher = false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而会继续报错，原因是图片上的像素定位点没有添加,最后还是一个一个改的。&lt;/p&gt;

&lt;p&gt;问题核心：&lt;/p&gt;

&lt;p&gt;.9图片可以根据ps绘制，同时，android里面也有专门的绘制工具。&lt;br /&gt;
.9图片区别于普通图片主要是通过两点：&lt;br /&gt;
1.特殊的扩展名，供专门的应用识别&lt;br /&gt;
2.图片上下左右4个特殊的黑色像素条，宽一个像素，也可以仅仅是一个点，其中上边和左边像素条标记的分别是图片在横向和纵向的可拉伸区域，至于右边和下边的像素条，网上说是表示“前景能显示的范围”，用了这么久，没见过可以区别的效果，所以也不大理解是什么意思。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Android解压缩zip文件</title>
        <link>http://www.liuschen.com/2016/07/22/zip.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/07/22/zip.html</guid>
        <pubDate>Fri, 22 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;期望:使项目apk包中的大文件批量数据可以单独作为一个apk来管理，所以需要将Android assets文件夹下的zip打包文件解压到SDCard上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解压缩的操作由于比较耗时，所以新开一个线程执行以下函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**将assets对应文件解压到对应的sdcard目录中*/
public void unPress2Sdcard(String fileName){
    try {
        /**目标路径*/
        String destDir = rootPath + File.separator + fileName;
        /**将压缩文件拷贝到内存卡中*/
        mAssetCopyer.copyBigDataToSD(destDir, fileName);
        /**解压文件到目标路径*/
        unzip(destDir, offlinePath);
        /**删除在内存卡上临时存在的压缩文件*/
        FileUtils.deleteFile(destDir);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的先将assets下的zip文件拷贝到SDCard中，这个是直接在网上找的方法拿来用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void copyBigDataToSD(String strOutFileName,String file) throws IOException{
    InputStream myInput;
    OutputStream myOutput = new FileOutputStream(strOutFileName);
    myInput = mContext.getAssets().open(file);
    byte[] buffer = new byte[1024];
    int length = myInput.read(buffer);
    while(length &amp;gt; 0){
        myOutput.write(buffer, 0, length);
        length = myInput.read(buffer);
    }
    myOutput.flush();
    myInput.close();
    myOutput.close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后解压缩操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)  
public static void unzip(String zipFilePath, String unzipFilePath) throws Exception{
    /**验证是否为空*/
    if (isEmpty(zipFilePath) || isEmpty(unzipFilePath)){

    }
    File zipFile = new File(zipFilePath);
    /**创建解压缩文件保存的路径*/
    File unzipFileDir = new File(unzipFilePath);
    if (!unzipFileDir.exists()){
        unzipFileDir.mkdirs();
    }
    //开始解压
    ZipEntry entry = null;
    String entryFilePath = null;
    int count = 0, bufferSize = 1024;
    byte[] buffer = new byte[bufferSize];  
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;  
    ZipFile zip = new ZipFile(zipFile);
    Enumeration&amp;lt;ZipEntry&amp;gt; entries = (Enumeration&amp;lt;ZipEntry&amp;gt;)zip.entries();  
    //循环对压缩包里的每一个文件进行解压
    while(entries.hasMoreElements()){
        entry = entries.nextElement();
        log(&quot;log ing5:&quot;+entry.getName());
        /**这里提示如果当前元素是文件夹时，在目录中创建对应文件夹
         * ，如果是文件，得出路径交给下一步处理*/
        entryFilePath = unzipFilePath + File.separator + entry.getName();
        File file = new File(entryFilePath);
        log(&quot;~~是否是文件夹:&quot;+file.isDirectory());
        if(entryFilePath.endsWith(&quot;/&quot;)){
            if(!file.exists()){
                file.mkdir();
            }
            continue;
        }
        /***这里即是上一步所说的下一步，负责文件的写入，不服来咬(≖ ‿ ≖)✧*/
        bos = new BufferedOutputStream(new FileOutputStream(entryFilePath+&quot;/&quot;));
        bis = new BufferedInputStream(zip.getInputStream(entry));
        while ((count = bis.read(buffer, 0, bufferSize)) != -1){
            bos.write(buffer, 0, count);
        }
        bos.flush();
        bos.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用的也是直接网上down下来的，但是在解压缩操作中遇到的是这一句bos = new BufferedOutputStream(new FileOutputStream(entryFilePath));传入的entryFilePath运行的时候却老提示不是文件夹，于是把中间循环解压元素的代码以及一些冗余的逻辑删除了，改成了现在这样，进入循环先判断是否是文件夹(我这里是靠尾部的字符判断的)，如果是，在目标路径中创建，开始下一循环，不是，就把文件解压到对应路径。&lt;/p&gt;

&lt;p&gt;最后一步删除SDcard下的压缩文件&lt;br /&gt;
FileUtils.deleteFile(destDir);&lt;/p&gt;

&lt;p&gt;注意:源压缩包必须是zip格式的并且是快速压缩，超高压缩算法不同，解析不了，我是在window上用快压打包的。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>程序员编程语录</title>
        <link>http://www.liuschen.com/2016/06/07/person.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/06/07/person.html</guid>
        <pubDate>Tue, 07 Jun 2016 00:00:00 +0800</pubDate>
        <description>&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;一个好的程序员是那种过单行线马路都要往两边看的人。(Doug Linder)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;程序有问题时不要担心。如果所有东西都没问题，你就失业了。(软件工程的Mosher定律)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;程序员的麻烦在于，你无法弄清他在捣腾什么，当你最终弄明白时，也许已经晚了。(超级计算机之父Seymour Cray)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我想大部分人都知道通常一个程序员会具有的美德。当然了，有三种：懒惰，暴躁，傲慢。(Perl语言发明者Larry Wall)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编程时要保持这种心态：就好象将来要维护你这些代码的人是一位残暴的精神病患者，而且他知道你住在哪。(Martin Golding)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个人写的烂软件将会给另一个人带来一份全职工作。(Jessica Gaston)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果建筑工人像程序员写软件那样盖房子，那第一只飞来的啄木鸟就能毁掉人类文明。(Gerald Weinberg)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这世界最有可能毁灭的方式——大多数专家都同意——是次意外。这就是为什么会有我们，我们是计算机专家，我们创造意外。(Nathaniel Borenstein)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们这个行业有个特别奇怪的现象：不仅我们不从失败里吸取教训，同时也不从成功中学习经验。 (Keith  Braithwaite)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一种新技术一旦开始流行，你要么坐上压路机，要么成为铺路石。(Stewart Brand)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没能一次成功，那就叫它1.0版吧。(unknown)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有的程序员都是编剧，所有的计算机都是烂演员。(Anonymous Hack Actor)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工作进度上越早落后，你就会有越充足的时间赶上。(Anonymous Scheduler)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当有这样的一种编程语言出现：它能让程序员用简单的英语编程，你将会发现，程序员都开始不会说英语。(Anonymous Linguist)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么我们没有时间把事情做对，却总有时间把事情做过头？(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;傻瓜都能写出计算机能理解的程序。优秀的程序员写出的是人类能读懂的代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任何你写的代码，超过6个月不去看它，当你再看时，都像是别人写的。(Eagleson’s law)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编程/软件开发语录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;按代码行数来评估软件开发的进度，就如同按重量来评估飞机建造的进度。(Bill Gates)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件就像做爱。一次犯错，你需要用余下一生来维护支持。(Michael Sinz)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在水上行走和按需求文档开发软件都很容易——前提是它们都是冻结状态。(Edward V Berard)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最初90%的代码用去了最初90%的开发时间…余下10%的代码用去了另外90%的开发时间。(Tom Cargill)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注释代码很像清洁你的厕所——你不想干，但如果你做了，这绝对会给你和你的客人带来更愉悦的体验。(Ryan Campbell)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如今的编程是一场程序员和上帝的竞赛，程序员要开发出更大更好、傻瓜都会用到软件。而上帝在努力创造出更大更傻的傻瓜。目前为止，上帝是赢的。(Rick Cook)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件设计最困难的部分…是阻挡新功能的引入。(Donald Norman)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了理解递归，我们首先要理解的是递归。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;世上只有两类编程语言：那些拥有被人诟病的和那些没人用的。(Bjarne Stroustrup)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The best thing about a boolean is even if you are wrong, you are only off by a bit. (Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果Java能实现真的垃圾回收，那大部分的程序都会在执行时删除自己。(Robert Swell)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;理论上，理论和实践是没有差异的。但实践中，是有的。(Jan L. A. van de Snepscheut)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;预备，开火，瞄准：这是最快的软件开发方法。预备，瞄准，瞄准，瞄准，瞄准：这是最慢的软件开发方法。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编程是10%的科学，20%天份，和70%的让这天份符合科学。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;评估一个事情要比去理解你评估了什么容易。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测评不会撒谎，但测评的人会。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;培养员工，即使他们有跳槽的风险。什么都不做而留他们在公司，这样风险更大。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算机科学的目标是做出一个东西，并且保证它至少能坚持到我们将它开发完成。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java之于JavaScript如同Car之于Carpet。 (Chris Heilmann)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;起初就把事情做对是完全没必要的。但最后要把事情做对是绝对必要的。(Andrew Hunt and David Thomas)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数组的起始索引应该从0开始还是从1开始？我的0.5的折中提议被他们未经认真考虑到拒绝了——我认为是这样的。(Stan Kelly-Bootle)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;程序必须是为了给人看而写，给机器去执行只是附带任务。 (Abelson / Sussman)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编程可以很有趣，你可以用它做密码学研究，但两者绝对不能合二为一。(Kreitzberg and Shneiderman)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拷贝-粘贴是一种设计错误。(David Parnas)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算机善于遵循指令，但不善于理解你的思维。(Donald Knuth)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;软件纠错语录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;删除的代码是没有bug的代码。(Jeff Sickel)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果纠错是消除软件bug的过程，那编程一定是把它们放进去的过程。(Edsger Dijkstra)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码纠错要比新编写代码困难一倍。因为，如果你写出了最聪明的代码，按此推算，你将没有更大的智慧来debug它。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;想在自己的代码里找出一个错误是十分困难的。而当你认为你的代码没有错误时，那就更难了。(Steve McConnel)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;软件bug语录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;这不是个bug——这一个未注明的功能特征。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有需求或设计，编程就是一种将bug添加到一个空文本文件里的艺术。(Louis Srygley)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;烂代码并不烂，只是被误解了。(Anonymous Code Behaviorist)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有两种方法能写出没有错误的程序；但只有第三种好用。(Alan J. Perlis)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小心上面代码中的bug；我只知道这些代码是正确的，但没有试过。(Donald Knuth)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;软件产品/成品语录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;软件能够复用前，它必须要可用。(Ralph Johnson)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件通常在beta测试完成不久后发布。Beta在拉丁语中是“还不能用”的意思。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最好的性能改进是将软件从不能用的状态变成可用。(J. Osterhout)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最廉价、最快速、最可信赖的组件是那些还未出现的组件。(Gordon Bell)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I think Microsoft named .Net so it wouldn’t show up in a Unix directory listing. (Oktal)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件和教堂非常相似——建成之后我们就在祈祷。(Sam Redwine)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;除非最后一个用户死掉，软件是不会有完工的时候的。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如今的大部分软件都非常像埃及金字塔，由成千上万的石块一个摞一个构成，没有结构上的集成，是由暴力强制和成千上万的奴隶完成。(Alan Kay)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;摘自网上&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>Android数据库和Bean的交互</title>
        <link>http://www.liuschen.com/2016/04/29/sqlite.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/04/29/sqlite.html</guid>
        <pubDate>Fri, 29 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Android中数据库使用的轻量级的Sqlite数据库，创建数据库的过程，因为系统都封装好了，所以比较简单。只要继承SQLiteOpenHelper即可。然后再写一些增删改查的函数就可以了。&lt;/p&gt;

&lt;p&gt;Android系统对数据的操作，就我的理解，主要是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;网络请求-内存(数据模型)-本地存储
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 JSON数据-本地Bean对象-数据库 则是其中一种通用的路子。&lt;br /&gt;
json到Bean对象以及Bean和数据库的交互转化，虽然可以针对每一种数据模型来实现，但是那样做未免太麻烦，同时也会浪费太多不必要的精力。&lt;br /&gt;
fastjson（阿里工程师开发的）和GSON(谷歌带的)就是很好的实现了json和Bean转化的框架，里面都是用的反射来实现的，其实也只能用反射，只不过牛逼的框架一般做的都很全，在性能上也处理的比较的当，我等也能佩服。&lt;/p&gt;

&lt;p&gt;当然我现在要说的是数据库和Bean的交互，因为时间比较匆忙，也没精力找别人写好的框架用，所以自己就简单的写了个。&lt;/p&gt;

&lt;p&gt;用到了反射，但是因为数据库中的字段名称和我自己的命名习惯不符(数据库字段名是已经定好的),所以便退而求其次，用了注解。首先，定义了一个注解:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DBDataType {
    /**为数据库中的信息，type=0时表示该为主键，-1为默认值，1,2,3,4为预留值，普通值请从5起，
     * 并且表示了该列值在数据库中的添加顺序*/
    int type() default -1;

    /**数据库中的元素名*/
    String elementName() default &quot;&quot;;
    /**数据库中的元素类型*/
    String elementType() default &quot;text&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着在建立的Bean对象中，对每一个field添加注解:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@DBDataType(type = 0, elementName = &quot;ID&quot;)
public String id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中type是字段在数据库建表时的排列顺序，从5开始，0时表示该字段定义为主键，1，2，3，4为预留值，elementName表示该值在表中的字段名，其实还有一个elementType表示字段的属性，默认是文本类型，其他可以指定&lt;/p&gt;

&lt;p&gt;然后就是关键代码，对sql语句进行拼接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {

		/**通过反射获取局部变量*/
		Field[] fields = clazz.getDeclaredFields();
		/**存储列的序号*/
		int[] cloumns = new int[fields.length];
		HashMap&amp;lt;Integer,DBDataType&amp;gt; hashMap = new HashMap&amp;lt;Integer,DBDataType&amp;gt;();
		/**建立序号到每个field对应的注解DBDataType映射关系*/
		for (int i=0;i&amp;lt;fields.length;i++){
			DBDataType dbDataTypes = fields[i].getAnnotation(DBDataType.class);
			int cloumnNumber = dbDataTypes.type();
			cloumns[i] = cloumnNumber;
			hashMap.put(cloumnNumber,dbDataTypes);
		}
		/**
		 * 对序号进行排序
		 * */
		Arrays.sort(cloumns);

		/**开始拼接sql语句*/
		String sqlfont = &quot;create table if not exists &quot; + tableName + &quot; (&quot;;
		String sqlContent = &quot;&quot;;
		String sqlOver = &quot;)&quot;;

		for(int i=0;i&amp;lt;cloumns.length;i++){

			String elementType = hashMap.get(cloumns[i]).elementType();
			String elementName = hashMap.get(cloumns[i]).elementName();

			if(cloumns[i]==0){
				//该值为主键
				sqlContent += elementName + &quot; &quot; + elementType + &quot; primary key&quot; +&quot;,&quot;;
			}else{
				sqlContent += elementName + &quot; &quot; + elementType +((i==cloumns.length-1)?&quot;&quot;:&quot;,&quot;);
			}

		}
		String sql = sqlfont + sqlContent + sqlOver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里传入的clazz为一个Bean对象，就是通过对field进行注解标记的Bean，这些代码是封装到数据库操作类中的，所以之后创建表，只需要传入一个Bean对象即可。对数据库的插入，查询也是，只需用注解和反射去写好一个通用的方法即可。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>荒原日记-习惯</title>
        <link>http://www.liuschen.com/2016/04/25/wildernessdiary-habby.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/04/25/wildernessdiary-habby.html</guid>
        <pubDate>Mon, 25 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;站在现在的角度看过去的自己，不得不说，我，是一个奇怪的小孩。&lt;/p&gt;

&lt;p&gt;“这是一个美丽的世界，关闭。”也许你会好奇我说的这句话的意义，但是正如我所说，我曾经是一个很奇怪的孩子，而这句话就是我常常在心中念叨的一句咒语。它的功用在于它能帮我清除心中的杂念，当然，如果杂念太多那我就还需要点时间好好捋捋。你可能会说，你看，这孩子把自己当机器了，还要关机开机呢。当不当机器不好说，不过强迫症肯定是有的，这个习惯不知道是从什么时候开始的，我也不清楚是从什么时候结束的。我总是强迫自己尽善尽美的处理遇到的任何事情，所以在此期间没丢过东西也没遗忘过什么。像提前设定的程序，日子平平淡淡，却也无味至极，甚至对我来说，知道别人不会这样做，而对这种习惯和未来联系到的日子充满恐惧。&lt;/p&gt;

&lt;p&gt;后来证明，这种担心多余了，甚至现在的我竟然搞不清，我舍弃掉的这个习惯是否一并带走了我更重要的东西，在那个充满幻想的年纪。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>荒原日记-开篇</title>
        <link>http://www.liuschen.com/2016/04/16/wildernessdiary-start.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/04/16/wildernessdiary-start.html</guid>
        <pubDate>Sat, 16 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;我从哪里来，又往哪里去？在我7，8岁的时候，常常在考虑这个问题，因为小，不理解前路漫长，总是觉得人生不过弹指岁月，所以总是充满了对死亡的恐惧。&lt;/p&gt;

&lt;p&gt;都说时间能抚平一切，当我将藏在心中的想法封印，企图在时间之海中将它沉溺，但时间流逝缓缓，却又残酷的否决了我。&lt;/p&gt;

&lt;p&gt;慢慢的，我也逐渐找到了自己的答案，也许每个人来到世上都是为了寻找到这一个答案，只是或许有些人不愿意分享，在喧闹抑或宁静，城市或许乡村，更或许只有当你在午夜，万物沉寂，而你独自一人时才会有机会偶然想起你此刻立于此地的意义。我们每个人都有一个答案，只是有些人一生可能都不会想起。幸运抑或不幸，只是人对自己过往的追问和总结罢了。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Visual Studio开发Android程序</title>
        <link>http://www.liuschen.com/2016/02/21/studio.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/21/studio.html</guid>
        <pubDate>Sun, 21 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;早就听说微软在新版的visual studio上增强了对移动开发的便利，而且提供的Android模拟器比Google提供的性能上要好很多，所以周末就弄了一下，简单说一下遇到的问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;visual-studio-2015&quot;&gt;1.安装Visual Studio 2015&lt;/h1&gt;

&lt;p&gt;安装Visual Studio 2015时，要联网下载很多东西，虽然安装包已经不小了，很显然，安装的要更多。装了近10个小时（只能说我够闲），完了后仍然提示我说android 的sdk和一个git相关的什么东西没装上，最重要的是sdk没装上肯定就不能开发Android了，下载是不现实的，所以就用了我本地存放的sdk,更改sdk路径的设置需要依次点击&lt;/p&gt;

&lt;h3 id=&quot;cross-platform&quot;&gt;工具-选项-Cross Platform&lt;/h3&gt;

&lt;p&gt;就能看到，然后勾选Android SDK前面的选择框就可以更改路径了。&lt;/p&gt;

&lt;p&gt;调试Android程序，如果是真机调试一般选ARM，连接上手机开发者一般就能看到设备了，如果是window的虚拟机则是选x86。&lt;/p&gt;

&lt;h1 id=&quot;window&quot;&gt;2.安装window的虚拟机&lt;/h1&gt;

&lt;p&gt;安装window提供的Android虚拟机需要window对Hyper-V的支持，这个功能家庭版上没有，至少要专业版才行，然后再控制面板中打开该功能，电脑在此期间会重启来完成功能的添加。之后就能安装虚拟机了，如果没有添加该功能直接安装会出错，安装虚拟机要升级到最新版本，安装完后就能使用了。&lt;/p&gt;

&lt;p&gt;window提供的Android虚拟机的基础Hyper-V感觉和workstation以及virtualbox差不多，但是毕竟是在window系统自家提供的功能，相必必有一些过人的地方，只是Android的模拟器虽然速度比Google自己的要快很多，但是总有些似曾相识的感觉，之前用sdk自带的虚拟机，在window上其实也是可以加速的，也就是单独针对x86架构有加速的独立window程序可以安装，和这个差不多，都是针对同一种架构的优化，从这个意义上来讲，其实这个虚拟机对我做开发意义并不是太大。&lt;/p&gt;

&lt;h1 id=&quot;visual-studio-2015-1&quot;&gt;3.Visual Studio 2015编程&lt;/h1&gt;

&lt;p&gt;我最期待的是Visual Studio 2015用c++来架构程序的效果，新建工程时,我发现没有Java构建代码的模板，好像在这里面C#是Java的等效语言，除此之外就是Visual c++，在里面的跨平台中还是找到了一个模板可以构建Java的Android程序，同时也可以建c++共享库，也有纯c++来开发Android的模板，遗憾的是，我看过之后发现这个模板是完全照抄的NDK中的示例源码，可见这并不是visualstudio的主要功能。其中也有Apache Cordova的模板，用网页前端语言构建app的框架，这个可以使代码可以轻松的跨平台，在节省开发成本上具有广泛意义，但传统的仍然认为这种方式在运行速度上仍不理想，所以现在还是以Java+html5混合编程为主。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>C++学习整理</title>
        <link>http://www.liuschen.com/2016/02/19/c++.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/19/c++.html</guid>
        <pubDate>Fri, 19 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;打印字符串&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
extern int pow(int, int);
int main()
{
	int val = 2;
	int exp = 15;
	cout &amp;lt;&amp;lt; &quot;The Powers of 2\n&quot;;
	for ( int cnt=0; cnt &amp;lt;= exp; ++cnt )
	cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &quot;: &quot;
	&amp;lt;&amp;lt; pow(val, cnt) &amp;lt;&amp;lt; endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;inline&quot;&gt;内联函数inline,最好放在头文件中&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;inline int min( int v1, int v2 ) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;extern-c&quot;&gt;链接指示符 extern “c”,告诉编译器函数编写语言类型&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// 单一语句形式的链接指示符
extern &quot;C&quot; void exit(int);
// 复合语句形式的链接指示符
extern &quot;C&quot; {
int printf( const char* ... );
int scanf( const char* ... );
}
// 复合语句形式的链接指示符
extern &quot;C&quot; {
	#include &amp;lt;cmath&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链接指示符不能出现在函数体中，并且如果需要c调用c++程序也需要在前面生命链接指示符,链接指示符如果声明多次，可以只声明一次，自动作用于后面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ---- myMath.h ----
extern &quot;C&quot; double calc( double );
// ---- myMath.C ----
// 在 Math.h 中的calc() 的声明
#include &quot;myMath.h&quot;
// 定义了 extern &quot;C&quot; calc() 函数
// calc() 可以从C 程序中被调用
double calc( double dparm ) { // ...
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Socket编程笔记</title>
        <link>http://www.liuschen.com/2016/02/17/socket.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/17/socket.html</guid>
        <pubDate>Wed, 17 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;android中的socket连接HttpURLConnection来实现的。而HttpClient是对HttpURLConnection做了一层封装，HttpClient6.0之后被废弃了,推荐用HttpURLConnection。而HttpURLConnection继承于HttpConnection，两者都是抽象类，想了解其中的实现原理，就要深入的剖析一下代码，但是其中一些关键的方法如connect()方法却是抽象的，所以需要找到它的实现类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，是找到connect()的实现，最可能的是在URL类中找线索，因为是在url中获取的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;URL url = new URL(httpUrl);//此处有异常抛出
HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，URL中却显示streamHandler中取得的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public URLConnection openConnection() throws IOException {
    return streamHandler.openConnection(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而streamHandler这个实例所属的对象实现的方法仍然是抽象的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected abstract URLConnection openConnection(URL u) throws IOException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说单独知道这个出处还不够，还需要知道streamHandler是在什么时候被赋值的，这时候可以注意到URL中有URLStreamHandlerFactory streamHandlerFactory的工厂声明，点击去发现还是抽象的(晕)，然后顺着streamHandlerFactory就找到了下面的方法，是对streamHandler赋值的关键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; void setupStreamHandler() {
    // Check for a cached (previously looked up) handler for
    // the requested protocol.
    streamHandler = streamHandlers.get(protocol);
    if (streamHandler != null) {
        return;
    }

    // If there is a stream handler factory, then attempt to
    // use it to create the handler.
    if (streamHandlerFactory != null) {
        streamHandler = streamHandlerFactory.createURLStreamHandler(protocol);
        if (streamHandler != null) {
            streamHandlers.put(protocol, streamHandler);
            return;
        }
    }

    // Check if there is a list of packages which can provide handlers.
    // If so, then walk this list looking for an applicable one.
    String packageList = System.getProperty(&quot;java.protocol.handler.pkgs&quot;);
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    if (packageList != null &amp;amp;&amp;amp; contextClassLoader != null) {
        for (String packageName : packageList.split(&quot;\\|&quot;)) {
            String className = packageName + &quot;.&quot; + protocol + &quot;.Handler&quot;;
            try {
                Class&amp;lt;?&amp;gt; c = contextClassLoader.loadClass(className);
                streamHandler = (URLStreamHandler) c.newInstance();
                if (streamHandler != null) {
                    streamHandlers.put(protocol, streamHandler);
                }
                return;
            } catch (IllegalAccessException ignored) {
            } catch (InstantiationException ignored) {
            } catch (ClassNotFoundException ignored) {
            }
        }
    }

    // Fall back to a built-in stream handler if the user didn&#39;t supply one
    if (protocol.equals(&quot;file&quot;)) {
        streamHandler = new FileHandler();
    } else if (protocol.equals(&quot;ftp&quot;)) {
        streamHandler = new FtpHandler();
    } else if (protocol.equals(&quot;http&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;https&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpsHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;jar&quot;)) {
        streamHandler = new JarHandler();
    }
    if (streamHandler != null) {
        streamHandlers.put(protocol, streamHandler);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看注释区分，总共分为4个部分&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;第一部分&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt; streamHandler = streamHandlers.get(protocol);
    if (streamHandler != null) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是取缓存的streamHandler实例，如果已经存在了，就不会往下执行了。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;第二部分&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;if (streamHandlerFactory != null) {
        streamHandler = streamHandlerFactory.createURLStreamHandler(protocol);
        if (streamHandler != null) {
            streamHandlers.put(protocol, streamHandler);
            return;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明显用到了工厂，所以需要知道工厂的出处，是这里:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Sets the stream handler factory for this VM.
 *
 * @throws Error if a URLStreamHandlerFactory has already been installed
 *     for the current VM.
 */
public static synchronized void setURLStreamHandlerFactory(URLStreamHandlerFactory factory) {
    if (streamHandlerFactory != null) {
        throw new Error(&quot;Factory already set&quot;);
    }
    streamHandlers.clear();
    streamHandlerFactory = factory;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得了，这个是公共的设置方法:Sets the stream handler factory for this VM顿时感觉好高大上，总之，不通。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;第三部分&lt;/h1&gt;

&lt;p&gt;在系统属性指定的包中寻找相应的URLStreamHandler处理类，因为没怎么用过这种方法，值得注意，不过不是这里的重点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String packageList = System.getProperty(&quot;java.protocol.handler.pkgs&quot;);
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    if (packageList != null &amp;amp;&amp;amp; contextClassLoader != null) {
        for (String packageName : packageList.split(&quot;\\|&quot;)) {
            String className = packageName + &quot;.&quot; + protocol + &quot;.Handler&quot;;
            try {
                Class&amp;lt;?&amp;gt; c = contextClassLoader.loadClass(className);
                streamHandler = (URLStreamHandler) c.newInstance();
                if (streamHandler != null) {
                    streamHandlers.put(protocol, streamHandler);
                }
                return;
            } catch (IllegalAccessException ignored) {
            } catch (InstantiationException ignored) {
            } catch (ClassNotFoundException ignored) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-3&quot;&gt;第四部分&lt;/h1&gt;

&lt;p&gt;再不成只能做最后的挣扎了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (protocol.equals(&quot;file&quot;)) {
        streamHandler = new FileHandler();
    } else if (protocol.equals(&quot;ftp&quot;)) {
        streamHandler = new FtpHandler();
    } else if (protocol.equals(&quot;http&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;https&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpsHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;jar&quot;)) {
        streamHandler = new JarHandler();
    }
    if (streamHandler != null) {
        streamHandlers.put(protocol, streamHandler);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中https依然是在特定包com.android.okhttp.HttpsHandler中找&lt;br /&gt;
而其他的则是直接new一个对象，这些对象的导入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import libcore.net.url.FileHandler;
import libcore.net.url.FtpHandler;
import libcore.net.url.JarHandler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在androidstudio中显示的是灰色的，表示没有没有提供相关源码，至此，线索全断了，不过通过这些查找也并非没有收获。&lt;/p&gt;

&lt;p&gt;一直以来找的URLStreamHandler streamHandler其实是一个协议流处理器，每一个&lt;br /&gt;
对应一个URLHttpConnection，至于实现它们的源码，限于sdk中源码包没有所以没看到，不过却找到了出处，网上查了一下知道了其中实现也是通过Socket，大体的关系总是理清了。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;总结：&lt;/h1&gt;

&lt;p&gt;1.URLHttpConnection和URLHttpsConnection都继承了URLConnection都是基于应用层对http或https协议的封装，里面通信还是用的socket&lt;/p&gt;

&lt;p&gt;2.URLConnection里面调用的Socket是传输层对应用层提供的抽象接口,是下层黑箱的一个门面，其中包括的协议有传输层的TCP协议和UDP协议，以及网络层的IP协议。当然也可以直接用socket通信，可以在应用层通过socket来架构网络框架，但是需要考虑多线程，以及状态监控（其实用URLConnection也要自己写多线程）等因素，更省流量以及更可控，但是如果要用到http等应用层协议，还是用URLConnection方便些。&lt;/p&gt;

&lt;p&gt;3.每个URLConnection都有一个相对应的URLStreamHandler实例用来处理协议，URL类中还有关于file，ftp,jar对应类型的URLStreamHandler应该也是一些协议的封装的处理器，也就是说每一种协议需要对应一种处理模型。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;最后，温习一下网络模型：&lt;/h1&gt;

&lt;h2 id=&quot;section-6&quot;&gt;应用层-应用层，表示层，会话层&lt;/h2&gt;

&lt;h2 id=&quot;section-7&quot;&gt;传输层-传输层&lt;/h2&gt;

&lt;h2 id=&quot;section-8&quot;&gt;网际互联层-网络层&lt;/h2&gt;

&lt;h2 id=&quot;section-9&quot;&gt;网络接入层-数据链路层，物理层&lt;/h2&gt;

</description>
      </item>
    
      <item>
        <title>git常用命令行</title>
        <link>http://www.liuschen.com/2016/02/16/apk.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/16/apk.html</guid>
        <pubDate>Tue, 16 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;首先将git目录下的cmd配置到环境变量，打开cmd就可以使用git命令，git仓库就是目录下隐藏的.git文件夹&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.bootcss.com/p/git-guide/&quot;&gt;git简易使用说明(外链)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;创建版本库&lt;br /&gt;
git init&lt;/p&gt;

&lt;p&gt;查看分支&lt;br /&gt;
git branch&lt;br /&gt;
git branch -a&lt;/p&gt;

&lt;p&gt;从远端拉取&lt;br /&gt;
git clone 地址&lt;/p&gt;

&lt;p&gt;显示状态&lt;br /&gt;
git status&lt;/p&gt;

&lt;p&gt;修改加入缓存&lt;br /&gt;
git add filename&lt;/p&gt;

&lt;p&gt;修改提交到HEAD(本地库最近版本)&lt;br /&gt;
git commit -m “提交注释内容”&lt;/p&gt;

&lt;p&gt;创建分支并切换  单独切换分支 删除本地分支&lt;br /&gt;
git checkout -b name&lt;br /&gt;
git checkout name&lt;/p&gt;

&lt;p&gt;还没提交到远端的分支可以直接删除&lt;br /&gt;
git branch -d name&lt;/p&gt;

&lt;p&gt;更新不需要密码&lt;br /&gt;
git pull&lt;br /&gt;
提交到远端库&lt;br /&gt;
git push&lt;/p&gt;

&lt;p&gt;本地有一个远端的拷贝，和远端同步&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>android反编译</title>
        <link>http://www.liuschen.com/2016/02/14/apk.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/14/apk.html</guid>
        <pubDate>Sun, 14 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;android程序是apk格式，其实就是一个压缩包，可以直接解压，但是直接解压后可以直接得到资源文件，以及c的动态链接库，但是打开布局文件却是乱码，并且没有的到直接可读的java源码，所以需要用到反编译相关的软件，而android逆向助手就是一个整合了多个反编译工具的软件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog-apk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，反编译apk和反编译dex直接提取的都是smali格式的文件&lt;/p&gt;

&lt;h3 id=&quot;androidjava&quot;&gt;获得android程序源码中java格式的源码：&lt;/h3&gt;
&lt;p&gt;通过dex转成jar格式   通过js-gui可以直接读取其中的内容，如果里面代码经过了混淆，则被混淆过的代码名称均用无意义的英文字母来命名，因为更改了名称，所以该部分代码不能用到反射。&lt;/p&gt;

&lt;h3 id=&quot;androidxml&quot;&gt;获得android程序源码中的xml文件：&lt;/h3&gt;

&lt;p&gt;反编译apk中就能获得xml文件用的APKTool工具&lt;br /&gt;
没有说明出错了, apktool.jar版本没更，跟不上android的版本&lt;br /&gt;
直接替换反编译却又不能出结果&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;结果：&lt;/h3&gt;

&lt;p&gt;直接用里面的apktool d 文件 来解析xml文件&lt;br /&gt;
用完整工具可以解析src中的Java文件&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>