<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>落风的博客</title>
    <link>http://www.liuschen.com</link>
    <description>落风的博客</description>
    
      <item>
        <title>Android反编译smali文件的修改</title>
        <link>http://www.liuschen.com/2017/03/31/smali.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/31/smali.html</guid>
        <pubDate>Fri, 31 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前提到过Android的反编译，知道了Android的apk反编译后依然是一个完整的项目。资源文件易于修改，不提了，这里主要记录一下smali文件的一些特性和修改方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;smali文件是Dalvik虚拟机的指令码，和汇编文件有点像。&lt;/p&gt;

&lt;p&gt;进入到smali包下面,往往会发现诸如R$id.smali等R$*.smali格式的文件，这是自动生成的R文件，也就是资源映射文件，这些文件一旦编译好都是死的，没法变，所以不到万不得已不要smali码和资源文件一起添加，太麻烦。&lt;/p&gt;

&lt;p&gt;包里面的smali文件都是一个名字可以对应多个文件，这是将写在Java中的内部类拆分的结果。后面用${数字}来区分，也可以是${数字}${数字}表示内部类的内部类，只不过这样增加代码复杂度的写法不多见而已。&lt;/p&gt;

&lt;p&gt;然后就可以修改smali码了，需要注意两点:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;了解指令码的含义（&lt;a href=&quot;http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html&quot;&gt;Dalvik操作指令&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;注意代码中的汉字字符会转成Unicode码，所以添加需要将汉字字符会转成Unicode码(&lt;a href=&quot;http://www.cnblogs.com/mq0036/p/4007452.html&quot;&gt;如何转&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里我主要修改一个Handler的内部，它的头如下，这也是所有内部类的共性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.class L该文件的完整路径名;
.super Landroid/os/Handler(父类);
.source &quot;原始从属的Java类.java&quot;

# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = L该文件原始从属的Java类的完整路径名(在哪个类里面定义就是那个类);
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x0
    name = null
.end annotation

# instance fields
.field final synthetic this$0:L该文件原始从属的Java类的完整路径名;

# direct methods
.method constructor &amp;lt;init&amp;gt;(L该文件原始从属的Java类的完整路径名;)V
.locals 0

.prologue
.line 1
iput-object p1, p0, L该文件的完整路径名;-&amp;gt;this$0:L该文件原始从属的Java类的完整路径名;

.line 278
invoke-direct {p0}, Landroid/os/Handler;-&amp;gt;&amp;lt;init&amp;gt;()V

return-void
.end method
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能单看没什么用，还是不能理解，就需要自己写些例子，生成apk反编译对比看看，就会发现规律&lt;/p&gt;

&lt;p&gt;.field故名思议就是变量，而且一般是全局的&lt;/p&gt;

&lt;p&gt;.method和end method之间是方法体，.method constructor &lt;init&gt;表示是该handler内部类的构造方法&lt;/init&gt;&lt;/p&gt;

&lt;p&gt;一个字符串常量v2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const-string v2, &quot;SOMETHING&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建一个对象并存到v4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new-instance v4, L对象完整路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法(这个是要结果的):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invoke-virtual {v1, v2}, Ljava/lang/String;-&amp;gt;equals(Ljava/lang/Object;)Z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法后将结果保存到v2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;move-result-object v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法(这个不要结果，是用来初始化v4这个内部类对象的，v6存储的是默认内部类所属外部类对象，v2存储的是外部类的一个final修饰的参数，都不是正经传入的参数，是编译器处理的结果)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invoke-direct {v4, v6, v2}, Lv4存储的实例对应的类的路径;-&amp;gt;&amp;lt;init&amp;gt;(Lv6存储的实例对应的类的路径;Ljava/lang/String;)V
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;重新打包时经常有错误报v数字不在v1-v15范围内(&lt;a href=&quot;http://www.aichengxu.com/other/2553264.htm&quot;&gt;reason&lt;/a&gt;)，又因为v可以反复使用，所以这个应该是如汇编一样是对寄存器的操作，v1-v15表示寄存器，所以只要明白了类是如何取到的，其他的就好理解了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;if结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if-eqz v1, :cond_1
.
.
:cond_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外部的final定义的对象，内部类是如何取到实例的？首先做如下定义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.local v2, &quot;对象名(在Java中自己起的)&quot;:Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用上面的invoke-direct方法将v2塞进去,然后再内部类中的构造方法里就会有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iput-object p2, p0, L该类完整路径名;-&amp;gt;val$对象名:Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在具体方法中会通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iget-object v2, p0, L该类完整路径名;-&amp;gt;val$对象名:Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到该值，即存储在v2中&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是通过查找字符串来定位修改的大致位置的，然后通过if结构的关键字cond来确定最终的修改坐标，比较粗浅，因为关于smali文件我还有许多不明白的地方，日后再有需要再去详细了解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;还有一点，我发现.line {数字}这种似乎只是记录行号，具体作用不明，随便添加删除也看不出影响，所以修改代码时不用考虑就好。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
      </item>
    
      <item>
        <title>Bootstrap</title>
        <link>http://www.liuschen.com/2017/03/28/Bootstrap.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/28/Bootstrap.html</guid>
        <pubDate>Tue, 28 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://v3.bootcss.com/getting-started/#download&quot;&gt;参考bootstrap起步文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;bootstrap&quot;&gt;下载bootstrap并解压&lt;/h2&gt;

&lt;h2 id=&quot;grunt&quot;&gt;安装编译系统Grunt&lt;/h2&gt;

&lt;p&gt;首先下载并安装 node.js，之前安装cordova时安装过了，省略。&lt;/p&gt;

&lt;p&gt;按装grunt-cli ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入 /bootstrap/ 根目录，然后执行 npm install 命令。npm 将读取 package.json 文件并自动安装此文件中列出的所有被依赖的扩展包。&lt;/p&gt;

&lt;p&gt;如果在安装依赖包或者运行 Grunt 命令时遇到了问题，请首先删除 npm 自动生成的 /node_modules/ 目录，然后，再次运行 npm install 命令（这一步需要翻墙不然会有如下错误）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm ERR! Windows_NT 10.0.14393
npm ERR! argv &quot;F:\\programer2\\nodejs\\node.exe&quot; &quot;F:\\programer2\\nodejs\\node_modules\\npm\\bin\\npm-cli.js&quot; &quot;install&quot;
npm ERR! node v6.10.0
npm ERR! npm  v3.10.10
npm ERR! code ELIFECYCLE

npm ERR! phantomjs@1.9.20 install: `node install.js`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the phantomjs@1.9.20 install script &#39;node install.js&#39;.
npm ERR! Make sure you have the latest version of node.js and npm installed.
npm ERR! If you do, this is most likely a problem with the phantomjs package,
npm ERR! not with npm itself.
npm ERR! Tell the author that this fails on your system:
npm ERR!     node install.js
npm ERR! You can get information on how to open an issue for this project with:
npm ERR!     npm bugs phantomjs
npm ERR! Or if that isn&#39;t available, you can get their info via:
npm ERR!     npm owner ls phantomjs
npm ERR! There is likely additional logging output above.

npm ERR! Please include the following file with any support request:
npm ERR!     F:\programer2\bootstrap\bootstrap-3.3.7\npm-debug.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grunt命令运行却没问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt dist （仅编译 CSS 和 JavaScript 文件）
grunt watch （监测文件的改变，并运行指定的 Grunt 任务）
grunt test （运行测试用例）
grunt docs （编译并测试文档中的资源文件）
grunt （重新构建所有内容并运行测试用例）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以编译javascript和css,文件夹下dest文件夹为生成的直接可以在生产环境中使用的js和css代码&lt;/p&gt;

&lt;p&gt;当然，这个dest文件夹里面的内容也可以直接在官网上下载。&lt;/p&gt;

&lt;h2 id=&quot;bootstrap-1&quot;&gt;bootstrap基本模板&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
    &amp;lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&amp;gt;
    &amp;lt;title&amp;gt;Bootstrap 101 Template&amp;lt;/title&amp;gt;

    &amp;lt;!-- Bootstrap --&amp;gt;
    &amp;lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;

    &amp;lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&amp;gt;
    &amp;lt;!-- WARNING: Respond.js doesn&#39;t work if you view the page via file:// --&amp;gt;
    &amp;lt;!--[if lt IE 9]&amp;gt;
      &amp;lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;![endif]--&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;

    &amp;lt;!-- jQuery (necessary for Bootstrap&#39;s JavaScript plugins) --&amp;gt;
    &amp;lt;script src=&quot;js/jquery-3.2.0.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;!-- Include all compiled plugins (below), or include individual files as needed --&amp;gt;
    &amp;lt;script src=&quot;js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bootstrap-2&quot;&gt;bootstrap控件实例学习&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://v3.bootcss.com/components/&quot;&gt;参考中文文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;学习最方便的途径就是做自己的东西，所以我这里写一个介绍某某平台产品的页面&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/bootstrap.html&quot;&gt;例子URL&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;bootstrap-3&quot;&gt;为什么需要编译bootstrap&lt;/h2&gt;

&lt;p&gt;我们知道，js和css和Java代码不同是不需要编译的，但是bootstrap的编译主要是为了生成javascript和css代码；存储bootstrap样式的代码主要写在less中，通过编译可以生成对应的css代码，从而使更改样式变得简单。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>android反编译还原项目指南</title>
        <link>http://www.liuschen.com/2017/03/21/smali2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/21/smali2.html</guid>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Android反编译工具就不说了，之前已经具体说过，只要会用几个功能，就能解出源码，如果恰巧源码没有进行混淆，那么就赚了，理论上可以还原出项目的开发文件的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先举一个例子，以下是原始代码，某个ListView的adapter的getView方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
	public View getView(int position, View convertView, ViewGroup parent) {
		
		if (getCount() == 0) {
			return null;
		}
		ViewHolder holder = null;
		if (convertView == null) {
			holder=new ViewHolder();
			convertView=mInflater.inflate(R.layout.list_item_updownload, null);
			holder.tv1=(TextView) convertView.findViewById(R.id.listitem_1);
			holder.tv2=(TextView) convertView.findViewById(R.id.listitem_2);
			holder.tv3=(TextView) convertView.findViewById(R.id.listitem_3);
			holder.tv4=(TextView) convertView.findViewById(R.id.listitem_4);
			holder.tv5=(TextView) convertView.findViewById(R.id.listitem_5);
			holder.tv6=(TextView) convertView.findViewById(R.id.listitem_6);
			
			convertView.setTag(holder);
			
		} else {
			holder = (ViewHolder) convertView.getTag();
		}
		holder.tv1.setText(mList.get(position).getNum());
		holder.tv2.setText(mList.get(position).getProjectName());
		holder.tv3.setText(mList.get(position).getZypName());
		holder.tv4.setText(mList.get(position).getZuoyedanwei());
		holder.tv5.setText(mList.get(position).getStartTime());
		holder.tv6.setText(mList.get(position).getEndTime());
		return convertView;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是编译成class文件后反解后对应的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public View getView(int paramInt, View paramView, ViewGroup paramViewGroup)
{
  if (getCount() == 0)
    return null;
  DataUploadActivity.ViewHolder localViewHolder;
  if (paramView == null)
  {
    localViewHolder = new DataUploadActivity.ViewHolder(null);
    paramView = this.mInflater.inflate(2130903048, null);
    DataUploadActivity.ViewHolder.access$1(localViewHolder, (TextView)paramView.findViewById(2131492897));
    DataUploadActivity.ViewHolder.access$2(localViewHolder, (TextView)paramView.findViewById(2131492898));
    DataUploadActivity.ViewHolder.access$3(localViewHolder, (TextView)paramView.findViewById(2131492899));
    DataUploadActivity.ViewHolder.access$4(localViewHolder, (TextView)paramView.findViewById(2131492901));
    DataUploadActivity.ViewHolder.access$5(localViewHolder, (TextView)paramView.findViewById(2131492902));
    DataUploadActivity.ViewHolder.access$6(localViewHolder, (TextView)paramView.findViewById(2131492903));
    paramView.setTag(localViewHolder);
  }
  while (true)
  {
    DataUploadActivity.ViewHolder.access$7(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getNum());
    DataUploadActivity.ViewHolder.access$8(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getProjectName());
    DataUploadActivity.ViewHolder.access$9(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getZypName());
    DataUploadActivity.ViewHolder.access$10(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getZuoyedanwei());
    DataUploadActivity.ViewHolder.access$11(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getStartTime());
    DataUploadActivity.ViewHolder.access$12(localViewHolder).setText(((ZYPbeanUpDownLoad)this.mList.get(paramInt)).getEndTime());
    return paramView;
    localViewHolder = (DataUploadActivity.ViewHolder)paramView.getTag();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出的是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;原始代码的注解不见了&lt;/li&gt;
  &lt;li&gt;资源文件变成了一串数字&lt;/li&gt;
  &lt;li&gt;里面多了很多个$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先来说第三点，因为第三点出现的范围相当广而且需要先进行修改来使项目顺利通过编译。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，当定义一个变量并被赋值，然后再回调方法中被调用，这时由于回调方法内部和定义变量的位置位于不同作用域，所以需要变量前加final修饰，当编译在反编译后的得到的代码将没有final修饰符，该变量作为一个参数传入回调的类中，在类中引用该变量则变为 val$原始类名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此引申，一个回调方法即使没有参数，也会默认传入null，遇到删除就好&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;break的用法，在反编译得到的代码中会遇到break label+数字  的代码，这个其实和goto语句一样是一个跳转语句，千万不要大惊小怪。可见，其实像if这样的条件语句都是翻译成跳转语句执行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;for循环会变成while(true)+if条件判断，if条件语句如果体量过大，会被优化为if-break跳转语句。我遇到的多重嵌套语句，很多都会变成break（这里同goto,因为Java中没有goto,所以用break）+while循环形式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上面例子中的access$数字形式，适用于内部类访问外部类数据成员时，是编译阶段自动生成的&lt;/li&gt;
  &lt;li&gt;switch语句也是有点头疼，反编译出来会变得很错乱，就不要看代码表面的逻辑了，还是会出现一个while循环，而且里面可能有出现的很不可理的return和continue，这是就看对代码上下文理解来整理了，没什么技巧。switch的default会被放在第一个，还有最后的return会被提前&lt;/li&gt;
  &lt;li&gt;还有一个有趣的现象，就是值数字的变量名会被改为诸如i,j,k这种让人混淆的名字。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有诸多小问题，如&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量没有初始化值&lt;/li&gt;
  &lt;li&gt;优化后代码出现大量跟在return或是break后的不可用语句&lt;/li&gt;
  &lt;li&gt;至于资源文件的对照，只能参考反编译出来的R文件批量修改了&lt;/li&gt;
  &lt;li&gt;大多注解都是对应的编译阶段，还有泛型就是为了编译而生的，如果因为缺少而报错需要加上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里还有一个很重要的问题，有时候一大段代码会反编译不出来，反编译的结果是注释掉的代码块，然后提示说是这一段代码有错误。那么，这一大段代码就只有自己根据上下文的逻辑自己写了。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>一些web相关东西(摘自网络)</title>
        <link>http://www.liuschen.com/2017/03/20/something.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/20/something.html</guid>
        <pubDate>Mon, 20 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;js&quot;&gt;1.js框架&lt;/h2&gt;

&lt;h3 id=&quot;bootstrap&quot;&gt;bootstrap&lt;/h3&gt;

&lt;h3 id=&quot;propeller&quot;&gt;Propeller&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Propeller 是一个基于 Bootstrap 和 Google’s Material Design 语言的 CSS 组件框架。它包含 25 个组件，响应敏捷，具有典型 Material Design 动画的特点。该项目可以作为 Bootstrap 主题下载，也可作为完整的框架或独立的组件下载。
BaguetteBox
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;baguetteboxjs&quot;&gt;baguetteBox.js&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;baguetteBox.js 是一个简单简单、易用的 JavaScript lightbox库，它具有一下特点：
纯 JavaScript 实现，无需依赖其他库
支持触摸屏设备手势操作
支持显示标题（说明）
支持响应式图像
支持CSS3过渡
使用 SVG 按钮，没有多余的文件下载
启用 gzip 压缩后仅 2KB
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;whitestorm&quot;&gt;Whitestorm&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Whitestorm 使用 Three.js 引擎开发 3D 网页应用和游戏，它为普通的 Three.js 任务提供封装，使搭建环境，创建对象，添加物件等操作更简单。官方提供了很好的项目教程，以及与 React 集成的工具。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;animatelo&quot;&gt;Animatelo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Animatelo 是极度流行的 Animate.css 库的端口，它用 Web Animations API 克隆代替 CSS 转换。所有原始的 Animate.css 效果都被重建，但现在的 API 是基于 JavaScript 类而不是 CSS 类。该库轻量且不依赖 jQuery，但在旧版浏览器要求 polyfill。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;fusebox&quot;&gt;FuseBox&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;FuseBox 是一个用于 JavaScript 和 CSS 的捆绑加载器，带有 TypeScript，Sass 等可选的附加组件。它以简洁与性能为主，为 webpack 提供替代方案。相关教程：Angular 2 + TypeScript, React + Babel, Vue.js, Electron 等。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;yargs&quot;&gt;Yargs&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Yargs 框架通过使用 Node.js 构建功能全面的命令行应用，它能轻松配置命令，解析多个参数，并设置快捷方式等，还能自动生成帮助菜单。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;webgradients&quot;&gt;WebGradients&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;WebGradients 含有多种漂亮的渐变色，可在任何 HTML 页面轻松应用。你可在项目网站快速预览可用的渐变色，还能一键复制 CSS 到你的项目中去。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sticky-kit&quot;&gt;Sticky-Kit&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Sticky-kit 是一个 jQuery 插件，它允许你在页面附加元素，设置跟随滚动的侧边栏效果。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;scrolldir&quot;&gt;ScrollDir&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ScrollDir 是一个超轻量无依赖的 JavaScript 库，用以检查滚动条的移动，并根据你的选择元素切换 上/下 数据属性。该项目能给你带来平滑的用户体验。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;svgo&quot;&gt;Svgo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;用以优化 SVG 文件的 Node.js 工具，它将它们从非必要的信息中剥离出来，如，编辑器元数据，注释，隐藏元素等。SVGO 具有基于插件的架构，你可自由选择需要删除和保留的内容。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;storejs&quot;&gt;Store.js&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Store.js 是一个跨浏览器的用于高级本地存储的解决方案，它实现了浏览器的本地存储的 JavaScript 封装 API，不是通过 Cookie 和 Flash 技术实现，而是使用 localStorage、globalStorage 和 userData 行为。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;snarkdown&quot;&gt;Snarkdown&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Snarkdown 是一个用 JavaScript 编写的极简的 Markdown 解析器。它不是功能最全的，但可能是最容易实现的一款解析器。Snarkdown 只有 1Kb 大小，且只有一种方法，适合速成项目。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;unfetch&quot;&gt;Unfetch&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Fetch API 能让开发者更好地处理异步请求，它能在大多数浏览器上受支持，但 fetch() 方法在 IE 浏览器中仍不可用。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;scrollanim&quot;&gt;Scrollanim&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Scrollanim 是使用 CSS3 + JavaScript 实现的用于创建滚动动画的库，应用到元素上后，当此元素出现在浏览器可视区域时便会执行对应的动画。Scrollanim 是 Kissui 的一部分，所以使用 Scrollanim 时需要用到 kissui.css。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;neurojs&quot;&gt;Neurojs&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;用于在浏览器中进行深度学习 JavaScript 框架，可以通过强化学习进行全栈神经网络。演示：Demo app
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;reactjs&quot;&gt;ReactJS&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;用于提高js页面刷新性能
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;2.自动化构建工具&lt;/h2&gt;

&lt;p&gt;Jenkins(Java),jekyll(基于模版轻量级博客系统)&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3.自动化运维工具&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ansible.com.cn/docs/intro.html&quot;&gt;ansible&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4.分布式计算&lt;/h2&gt;

&lt;p&gt;Apache Spark&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>linux网络调试</title>
        <link>http://www.liuschen.com/2017/03/16/linux.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/16/linux.html</guid>
        <pubDate>Thu, 16 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个文件是网络连接的文件，可视化的编辑也是修改和创建的这个文件&lt;br /&gt;
vi /etc/sysconfig/network-scripts/ifcfg-networkname修改onBoot=yes&lt;/p&gt;

&lt;p&gt;网络服务的开关&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service network stop
service network start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看网络连接状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl status network.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看关于网络部分的日志&lt;br /&gt;
cat /var/log/messages | grep -n network&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;19746:Mar  6 11:40:58 localhost network: 正在打开接口 eno16777736： 成功激活的连接（D-Bus 激活路径：/org/freedesktop/NetworkManager/ActiveConnection/11）
19747:Mar  6 11:40:58 localhost network: [  确定  ]
19750:Mar  6 11:40:58 localhost systemd: Started LSB: Bring up/down networking.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置开机启动一个NetworkManager服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable NetworkManager-wait-online.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service NetworkManager restart
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>protobuf</title>
        <link>http://www.liuschen.com/2017/03/13/caffe.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/13/caffe.html</guid>
        <pubDate>Mon, 13 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下载protobuf，安装都是很简单的步骤，如果想要将安装文件安装到特定目录，需要在configure的时候加入具体的路径参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --prefix=/home/myprotobuf(自己指定的路径)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用：&lt;/p&gt;

&lt;p&gt;为了方便可以先将目录加入环境变量(这个是临时的)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exprot PATH=/home/myprotobuf/bin/:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将动态连接库的搜索路径加入到系统中（之后编译链接代码时会用到）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export LD_LIBRARY_PATH=/home/myprotobuf/lib:$LD_LIBRARY_PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，建一个文件protobuf_demo.proto，通过命令生成cc文件和头文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protoc --cpp_out=. ./protobuf_demo.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;protobuf_demo.proto记录了目标文件需要配置的元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;message protobuf_demo{

required int32 id = 1;
required string str = 2;
required string hello = 4;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再编写cpp文件并在文件中引用上面生成的C++头文件，我的文件如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &quot;protobuf_demo.pb.h&quot;
#include &amp;lt;google/protobuf/io/coded_stream.h&amp;gt;
#include &amp;lt;google/protobuf/io/zero_copy_stream_impl.h&amp;gt;
#include &amp;lt;google/protobuf/text_format.h&amp;gt;

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

using namespace std;
using google::protobuf::io::FileInputStream;
using google::protobuf::io::FileOutputStream;
using google::protobuf::io::ZeroCopyInputStream;
using google::protobuf::io::CodedInputStream;
using google::protobuf::io::ZeroCopyOutputStream;
using google::protobuf::io::CodedOutputStream;

int main(void)
{
protobuf_demo msg;
const char * filename = &quot;some.prototxt&quot;;
int fd = open(filename,O_RDONLY);
if(fd == -1)
{
  cout &amp;lt;&amp;lt; &quot;File not found:&quot; &amp;lt;&amp;lt; filename &amp;lt;&amp;lt; endl;
}
FileInputStream* input = new FileInputStream(fd);
bool success = google::protobuf::TextFormat::Parse(input,&amp;amp;msg);

cout &amp;lt;&amp;lt; msg.id() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; msg.str() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; msg.hello() &amp;lt;&amp;lt; endl;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译生成可执行文件，然后通过该文件就可以读出当前文件加下some.prototxt的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id: 1888
str: &quot;192.168.0.1
hello: &quot;haha&quot;
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>docker</title>
        <link>http://www.liuschen.com/2017/03/09/docker.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/09/docker.html</guid>
        <pubDate>Thu, 09 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httpsdocsdockercomengineinstallationlinuxcentos&quot;&gt;1.&lt;a href=&quot;https://docs.docker.com/engine/installation/linux/centos/&quot;&gt;安装过程:&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;如果已经安装过客户端，先进行清理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum -y remove docker docker-common container-selinux
sudo yum -y remove docker-selinux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装之前，先更新仓库，添加仓库源地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install -y yum-utils
sudo yum-config-manager \
--add-repo \
https://docs.docker.com/engine/installation/linux/repo_files/centos/docker.repo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果添加仓库失败，可以先执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum-config-manager --enable docker-testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum-config-manager --disable docker-testing
sudo yum-config-manager --enable docker-testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装docker之前，先更新包索引&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum makecache fast
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装docker,可以先列出所有版本，选择需要版本安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum list docker-engine.x86_64  --showduplicates |sort -r
sudo yum -y install docker-engine-&amp;lt;VERSION_STRING&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以直接安装最新版&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum -y install docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动helloword测试镜像,没有会自动下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新docker，先更新包索引，然后安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum makecache fast
sudo yum -y upgrade docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;卸载docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum -y remove docker-engine
sudo rm -rf /var/lib/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不想每次都用sudo来获取管理员权限，可以建立用户组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo groupadd docker //新建组
sudo usermod -aG docker $USER //添加用户
docker run hello-world  //测试
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dockers&quot;&gt;2.配置dockers开机启动&lt;/h2&gt;

&lt;p&gt;systemd(RHEL, CentOS, Fedora, Ubuntu 16.04 and higher)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl enable docker  开机自启动
sudo systemctl disable docker  取消开机自启动
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;upstart(Ubuntu 14.10 and below)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;默认开机自启动，可以通过以下方法关闭
echo manual | sudo tee /etc/init/docker.override
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chkconfi(Oracle Linux 6)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo chkconfig docker on
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;docker&quot;&gt;3.查看docker信息&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo docker version
sudo docker info
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;httpblogcsdnnetzjinhuaarticledetails52041757&quot;&gt;4.&lt;a href=&quot;http://blog.csdn.net/zjin_hua/article/details/52041757&quot;&gt;数据卷&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//创建数据卷
sudo docker run --name data -v /data -t -i centos /bin/bash
//可以找到host主机挂载数据卷对应的目录
docker inspect data
//将主机根目录下的Source文件夹作为共享目录挂载到container根下的web文件夹
sudo docker run --name web -v /source/:/web -t -i centos /bin/bash
//同上，只是挂载文件夹只读
sudo docker run --rm --name test -v /source/:/test:ro -t -i centos /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;5.容器命名&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo docker run -d -t -i --name test centos bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;持久化镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker save -o webapp.tar 6fae60ef3446
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;持久化容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker export 6fae60ef3446 &amp;gt; webapp.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DockerFile的使用&lt;/p&gt;

&lt;p&gt;dockerFile相当于Linux中的shell脚本和window批处理文件，通过自动化的脚本程序自动生成所需的镜像文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t &amp;lt;待生成的镜像名&amp;gt; &amp;lt;dockerfile所在的文件路径&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ENV 设置环境变量&lt;br /&gt;
ADD 往里面拷贝东西&lt;br /&gt;
RUN 运行镜像中的命令&lt;br /&gt;
EXPOSE 暴露端口&lt;br /&gt;
CMD 启动时执行命令，可替代性&lt;/p&gt;

&lt;p&gt;源镜像在文件中通过From来指定&lt;/p&gt;

&lt;h2 id=&quot;docker-help&quot;&gt;6.docker help&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Usage:	docker COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default &quot;/root/.docker&quot;)
  -D, --debug              Enable debug mode
      --help               Print usage
  -H, --host list          Daemon socket(s) to connect to (default [])
  -l, --log-level string   Set the logging level (&quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;fatal&quot;) (default &quot;info&quot;)
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default &quot;/root/.docker/ca.pem&quot;)
      --tlscert string     Path to TLS certificate file (default &quot;/root/.docker/cert.pem&quot;)
      --tlskey string      Path to TLS key file (default &quot;/root/.docker/key.pem&quot;)
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Management Commands:
  container   Manage containers
  image       Manage images
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  volume      Manage volumes

Commands:
  attach      Attach to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container&#39;s changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  diff        Inspect changes on a container&#39;s filesystem
  events      Get real time events from the server
  exec        Run a command in a running container
  export      Export a container&#39;s filesystem as a tar archive
  history     Show the history of an image
  images      List images
  import      Import the contents from a tarball to create a filesystem image
  info        Display system-wide information
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  login       Log in to a Docker registry
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;例子一：鲸语者&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;docker run docker/whalesay cowsay boo-boo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dockerfile脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM docker/whalesay:latest
RUN apt-get -y update &amp;amp;&amp;amp; apt-get install -y fortunes
CMD /usr/games/fortune -a | cowsay
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t docker-whale .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成container并启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run docker-whale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;container启动方式指定的不同，效果不同。&lt;/p&gt;

&lt;h1 id=&quot;docker-1&quot;&gt;docker中网络的配置&lt;/h1&gt;

&lt;p&gt;既然docker是一个虚拟化的轻量解决方案，那么自然我们要考虑它的隔离性和通信问题，如何访问它是我们应用docker的最终问题。&lt;/p&gt;

&lt;p&gt;run容器时通过-P或-p指定绑定端口，如果不指定，docker会随机映射一个49000~49900的端口至容器内部开放的网络端口&lt;/p&gt;

&lt;p&gt;-p可以指定要映射的端口，并且，在一个指定端口上只能绑定一个容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip:hostPort:containerPort  映射指定地址的特定端口
ip::containerPort          映射指定地址的任意端口
hostPort:containerPort     映射所有地址端口，可以-p多次指定
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;容器互联&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--link 链接容器:链接别名
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>网络探测技术初探</title>
        <link>http://www.liuschen.com/2017/03/06/broadcast.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/06/broadcast.html</guid>
        <pubDate>Mon, 06 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;使用组播&lt;/h2&gt;

&lt;p&gt;广播地址就是为一就对了，子网内传播主机号全为一，所有子网内传播，子网号和主机号全为一。&lt;/p&gt;

&lt;p&gt;组播就是以组为单位的广播，以下摘自百度百科：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。
224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；
224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；
224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；
239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。
组播地址
列表如下：
224.0.0.0 基准地址（保留）
224.0.0.1 所有主机的地址 （包括所有路由器地址）
224.0.0.2 所有组播路由器的地址
224.0.0.3 不分配
224.0.0.4 dvmrp路由器
224.0.0.5 所有ospf路由器
224.0.0.6 ospf DR/BDR
224.0.0.7 st路由器
224.0.0.8 st主机
224.0.0.9 rip-2路由器
224.0.0.10 Eigrp路由器
224.0.0.11 活动代理
224.0.0.12 dhcp 服务器/中继代理
224.0.0.13 所有pim路由器
224.0.0.14 rsvp封装
224.0.0.15 所有cbt路由器
224.0.0.16 指定sbm
224.0.0.17 所有sbms
224.0.0.18 vrrp
以太网传输单播ip报文的时候，目的mac地址使用的是接收者的mac地址。但是在传输组播报文时，传输目的不再是一个具体的接收者，而是一个成员不确定的组，所以使用的是组播mac地址。组播mac地址是和组播ip地址对应的。iana（internet assigned number authority）规定，组播mac地址的高24bit为0x01005e，mac 地址的低23bit为组播ip地址的低23bit。
由于ip组播地址的后28位中只有23位被映射到mac地址，这样就会有32个ip组播地址映射到同一mac地址上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前做过一个手机之间互发消息探测存在的APP，是先使用组播发消息，局域网内有设备收到，这个设备就会发送一条UDP数据报来声明存在，发送探测消息的一端接收到这个消息，就回复一条UDP数据报。一来一回，两个设备就都知晓了对方的存在。然而，在实际应用中两个Android设备互相探测是没问题的，但是由电脑端发送组播消息探测手机端却收不到任何回应，调试时知道手机端根本没收到组播消息（电脑端防火墙是关闭着的），因为手机和手机之间的组播就能接收，所以，我怀疑网络底层可能加了某些过滤规则，在加上网上有些说法，组播和广播的消息很容易被屏蔽，所以暂时放弃这种思路。免得所付者巨多，所得者却少之又少。&lt;/p&gt;

&lt;h2 id=&quot;socket&quot;&gt;Socket轮询&lt;/h2&gt;

&lt;p&gt;这种方法有点笨，就是算出局域网的网段，然后向可能的IP地址发起SOCKet连接，如果能连上，就让客户端机器向服务端发起Netty连接请求。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>GBK编码问题</title>
        <link>http://www.liuschen.com/2017/02/26/GBK.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/02/26/GBK.html</guid>
        <pubDate>Sun, 26 Feb 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php&quot;&gt;http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GBK 亦采用双字节表示，总体编码范围为 8140-FEFE，首字节在 81-FE 之间，尾字节在 40-FE 之间&lt;/p&gt;

&lt;p&gt;全部编码分为三大部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;汉字区。包括：&lt;br /&gt;
a. GB 2312 汉字区。即 GBK/2: B0A1-F7FE。收录 GB 2312 汉字 6763 个，按原顺序排列。&lt;br /&gt;
b. GB 13000.1 扩充汉字区。包括：&lt;br /&gt;
(1) GBK/3: 8140-A0FE。收录 GB 13000.1 中的 CJK 汉字 6080 个。&lt;br /&gt;
(2) GBK/4: AA40-FEA0。收录 CJK 汉字和增补的汉字 8160 个。CJK 汉字在前，按 UCS 代码大小排列；增补的汉字（包括部首和构件）在后，按《康熙字典》的页码/字位排列。&lt;br /&gt;
(3) 汉字“〇”安排在图形符号区GBK/5：A996。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图形符号区。包括：&lt;br /&gt;
a. GB 2312 非汉字符号区。即 GBK/1: A1A1-A9FE。其中除 GB 2312 的符号外，还有 10 个小写罗马数字和 GB 12345 增补的符号。计符号 717 个。&lt;br /&gt;
b. GB 13000.1 扩充非汉字区。即 GBK/5: A840-A9A0。BIG-5 非汉字符号、结构符和“〇”排列在此区。计符号 166 个。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户自定义区：分为(1)(2)(3)三个小区。&lt;br /&gt;
(1) AAA1-AFFE，码位 564 个。&lt;br /&gt;
(2) F8A1-FEFE，码位 658 个。&lt;br /&gt;
(3) A140-A7A0，码位 672 个。&lt;br /&gt;
第(3)区尽管对用户开放，但限制使用，因为不排除未来在此区域增补新字符的可能性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中用户自定义区即表示空白部分，在使用GBK编码时，由于我们一般不改动编码，所以用户自定义区是没有定义的，所以如果要检测半编码的字符，假如字符的编码为ABCD&lt;/p&gt;

&lt;p&gt;首先A不能为4,5,6,7,然后就是编码不能在用户定义区的范围内，以下代码是从byte数组中提取60字节来检测是否编码错乱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isErrorGBKCode(byte[] bytes){
	for (int i = 0; i &amp;lt; 30; i++) {
		String hexStringHeader = Integer.toHexString(bytes[i*2]);
		String hexStringTail = Integer.toHexString(bytes[i*2+1]);
		System.out.println(hexStringHeader+&quot;=======&quot;+hexStringTail);
		if(hexStringHeader.length()&amp;lt;8 || hexStringTail.length()&amp;lt;8)
			continue;
		char first = hexStringHeader.charAt(6);
		char second = hexStringHeader.charAt(7);
		char third = hexStringTail.charAt(6);
		char fourth = hexStringTail.charAt(7);

		char[] code = {first,second,third,fourth};
		String codeStr = new String(code);

		/**
		 * (1) AAA1-AFFE，码位 564 个。
		 (2) F8A1-FEFE，码位 658 个。
		 (3) A140-A7A0，码位 672 个。
		 * */
		if(codeStr.matches(&quot;^a[a-f][a-f][1-9a-e]$&quot;))
			return true;
		if(codeStr.matches(&quot;^f[8-9a-f][a-f][1-9a-e]$&quot;))
			return true;
		if(codeStr.matches(&quot;^a[1-7][4-9a]0$&quot;))
			return true;
		if(codeStr.matches(&quot;^[^4-7]]&quot;))
			return true;

	}
	return false;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>FastDFS配置文档</title>
        <link>http://www.liuschen.com/2017/01/16/fastdfs.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/01/16/fastdfs.html</guid>
        <pubDate>Mon, 16 Jan 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;1.简介&lt;/h2&gt;

&lt;p&gt;FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储（不是大文件）和负载均衡的问题。特别适合以文件为载体的在线服务。&lt;/p&gt;

&lt;p&gt;FastDFS有两个重要模块，tracker和storage。tracker负责调度分配文件的访问和负载均衡。storage则负责文件的管理，其中包括文件的存储，同步，和提供文件的访问接口。其中还允许以键值对的形式对文件写入一些元数据。&lt;/p&gt;

&lt;p&gt;tracker和storage可以包括一个或多个服务端，这些服务端可以在不影响对外提供服务的情况下动态的添加和删除。集群中的每个服务器是对等的。&lt;/p&gt;

&lt;h2 id=&quot;linux&quot;&gt;1.Linux部署&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意:一定要下载正确的版本，我最开始下载了v1.27，结果Java端死活上载不了文件，之前的版本是依赖libevent这个库的，而新的版本依赖的是libfastcommon，一定要按照给出的下载地址下载libfastcommon,以防出错，以下步骤为v5.08中的INSTALL文件中给出的步骤，如果亲下载的版本更新，请以FastDFS目录下INSTALL中给出的安装步骤为准。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下载最新版本v5.0.8FastDFS:&lt;a href=&quot;https://sourceforge.net/projects/fastdfs/files/&quot;&gt;https://sourceforge.net/projects/fastdfs/files/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;github-libfastcommon-&quot;&gt;步骤一. 从github上下载 libfastcommon 源码包并且安装它&lt;/h3&gt;

&lt;p&gt;the github address:&lt;br /&gt;
   https://github.com/happyfish100/libfastcommon.git&lt;/p&gt;

&lt;h3 id=&quot;fastdfs&quot;&gt;步骤二.下载 FastDFS源码包（已下载），并且解压&lt;/h3&gt;

&lt;p&gt;tar xzf FastDFS_v5.x.tar.gz&lt;/p&gt;

&lt;h3 id=&quot;fastdfs-1&quot;&gt;步骤三.进入FastDFS目录&lt;/h3&gt;
&lt;p&gt;cd FastDFS&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;步骤四.执行命令:&lt;/h3&gt;

&lt;p&gt;./make.sh&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;步骤五.执行安装命令&lt;/h3&gt;

&lt;p&gt;./make.sh install&lt;/p&gt;

&lt;h3 id=&quot;config&quot;&gt;步骤六.编辑修改config文件&lt;/h3&gt;

&lt;p&gt;config文件是用来启动tracker和storage的，在conf目录下，执行安装命令后在/etc/fdfs/目录下也有备份&lt;/p&gt;

&lt;p&gt;在这一步先做简单的修改，只需要改配置文件的中设置的IP和搜索‘home’,更改需要设置本地存储位置即可&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;步骤七.启动服务器&lt;/h3&gt;

&lt;h4 id=&quot;tracker-&quot;&gt;启动 tracker 程序:&lt;/h4&gt;

&lt;p&gt;/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart&lt;/p&gt;

&lt;h4 id=&quot;in-linux-you-can-start-fdfstrackerd-as-a-service&quot;&gt;in Linux, you can start fdfs_trackerd as a service:&lt;/h4&gt;

&lt;p&gt;/sbin/service fdfs_trackerd start&lt;/p&gt;

&lt;h4 id=&quot;storage-&quot;&gt;启动 storage 程序:&lt;/h4&gt;

&lt;p&gt;/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart&lt;/p&gt;

&lt;h4 id=&quot;in-linux-you-can-start-fdfsstoraged-as-a-service&quot;&gt;in Linux, you can start fdfs_storaged as a service:&lt;/h4&gt;

&lt;p&gt;/sbin/service fdfs_storaged start&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;步骤八.测试启动的程序&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;启动测试程序格式:&lt;/h4&gt;

&lt;p&gt;/usr/bin/fdfs_test 客户端配置文件 操作(download,upload)&lt;/p&gt;

&lt;p&gt;/usr/bin/fdfs_test1 客户端配置文件 操作(download,upload)&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;上传文件示例:&lt;/h4&gt;

&lt;p&gt;/usr/bin/fdfs_test conf/client.conf upload /usr/include/stdlib.h&lt;/p&gt;

&lt;h3 id=&quot;monitor&quot;&gt;步骤九.启动monitor程序&lt;/h3&gt;

&lt;p&gt;/usr/bin/fdfs_monitor 客户端配置文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：启动完后有时需要一点时间才可以访问，如果马上测试返回不成功的话，并不一定是配置错了。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;2.配置文件和启动的一些补充&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于是分布式存储，在一个服务器上可以选择tracker和storage进行部署。&lt;br /&gt;
修改配置文件，FastDFS目录下conf下以conf为扩展名的文件都是配置文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配置tracker.conf和storage.conf中的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;base_path:存储数据和log文件

store_path0:存储文件路径

tracker_server：tracker服务器

group_name=group1:设置storage所属的组，同组磁盘存储单元互相备份
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动tracker：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fdfs_trackerd ./conf/tracker.conf restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动storage：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fdfs_storaged ./conf/storage.conf restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/fdfs_test /etc/fdfs/client.conf upload file
/usr/bin/fdfs_test /etc/fdfs/client.conf download file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出配置信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/fdfs_monitor /etc/fdfs/client.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fdfs_trackerd和fdfs_storaged是安装的可执行文件，如果安装的目录没有加入了环境变量，需要加上全路径，就是上面说的可执行文件的安装路径,新版本的fdfs_trackerd和fdfs_storaged是安装在/usr/bin中，需要加全路径，修改的conf最好也是修改/etc/fdfs下的相关配置文件，便于寻找部署。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;3.搭建反向代理服务器&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;到这一步，不是必须的，但是由于FastDFS新版本不支持HTTP服务了，所以需要自己搭建该服务，同时，也可以解决不同storage之间复制文件时，访问未传输文件导致的错误，nginx能将访问链接重定向到源文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;依然是这个地址：&lt;a href=&quot;https://sourceforge.net/projects/fastdfs/files/&quot;&gt;https://sourceforge.net/projects/fastdfs/files/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载fastdfs-nginx-module&lt;/p&gt;

&lt;p&gt;下载nginx(我下载的是稳定版1.10.2):&lt;a href=&quot;http://nginx.org/en/download.html&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;nginx&quot;&gt;安装nginx&lt;/h3&gt;

&lt;p&gt;解压，fastdfs-nginx-module，内有一个src文件夹，路径假设为$(PATH)&lt;/p&gt;

&lt;p&gt;添加依赖（我没有执行这一步，考虑到安装的环境可能不同，最好一次性将依赖安装，就可以避免下面的一些配置和编译的错误）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl openssl-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切换到nginx目录中，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --add-module=$(PATH)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure: error: the HTTP rewrite module requires the PCRE library.
./configure: error: the HTTP gzip module requires the zlib library.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install pcre-devel
yum install zlib-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行make,如果报错yacc命令未找到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install bison-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:devel表示的是开发版本，与源码编译来相同，有暴露的include和链接库供其他程序编译时调用&lt;/p&gt;

&lt;p&gt;报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fastdfs-nginx-module/src/common.c:29:27: 致命错误：local_ip_func.h：没有那个文件或目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;local_ip_func.h经过搜索发现是fastcommon中的头文件，这里找不到，可能是编译目录未包含，事实上也是如此，编译时包含了/usr/local/include/fastcommon目录，但是local_ip_func.h确是在/usr/include/fastcommon&lt;/p&gt;

&lt;p&gt;所以，只需要生成makefile（这个文件在obj目录下）文件后，添加一下include目录搜索地址即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;将-L/usr/local/lib改为-L/usr/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ALL_INCS中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-I /usr/include/fastdfs \
-I /usr/include \
-I /usr/local/include \
-I /usr/include/fastcommon/ \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译中出现这个问题就是fastcommon的安装路径和nginx中添加插件找寻的目录不一致导致的，当然也可以一开始不要将fastcommon安装在local下.&lt;/p&gt;

&lt;p&gt;编译成功后，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>eclipse配合maven导入项目遇到的问题</title>
        <link>http://www.liuschen.com/2017/01/16/error.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/01/16/error.html</guid>
        <pubDate>Mon, 16 Jan 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;错误一：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Multiple annotations found at this line:
	- cvc-complex-type.2.4.c: The matching wildcard is strict, but no declaration can be found for element &#39;dubbo:application&#39;.
	- schema_reference.4: Failed to read schema document &#39;http://code.alibabatech.com/schema/dubbo/dubbo.xsd&#39;, because 1) could not 
 find the document; 2) the document could not be read; 3) the root element of the document is not &amp;lt;xsd:schema&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决办法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;http://blog.csdn.net/tech4j/article/details/46754751
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;错误二：&lt;/h2&gt;

 	jsp文件报错：The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path&lt;br /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;解决办法：&lt;/h3&gt;

&lt;p&gt;将jre system library改为本机存在的正确的版本，添加serverRuntime&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;错误三：&lt;/h2&gt;

&lt;p&gt;Multiple annotations found at this line:&lt;br /&gt;
	- Plugin execution not covered by lifecycle configuration: org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile (execution: &lt;br /&gt;
	 default-testCompile, phase: test-compile)&lt;/p&gt;

&lt;p&gt;maven-&amp;gt;Lifecycle Mapping载入如下文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;lifecycleMappingMetadata&amp;gt;
  &amp;lt;pluginExecutions&amp;gt;
    &amp;lt;pluginExecution&amp;gt;
      &amp;lt;pluginExecutionFilter&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;goals&amp;gt;
          &amp;lt;goal&amp;gt;compile&amp;lt;/goal&amp;gt;
          &amp;lt;goal&amp;gt;testCompile&amp;lt;/goal&amp;gt;
        &amp;lt;/goals&amp;gt;
        &amp;lt;versionRange&amp;gt;[3.1,)&amp;lt;/versionRange&amp;gt;
      &amp;lt;/pluginExecutionFilter&amp;gt;
      &amp;lt;action&amp;gt;
        &amp;lt;ignore/&amp;gt;
      &amp;lt;/action&amp;gt;
    &amp;lt;/pluginExecution&amp;gt;
  &amp;lt;/pluginExecutions&amp;gt;
&amp;lt;/lifecycleMappingMetadata&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中artifactId的值maven-compiler-plugin，versionRange的值和goal的值根据报的错误不同，做不同改动&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;错误四：&lt;/h2&gt;

&lt;p&gt;Cannot change version of project facet Dynamic Web Module to 2.3&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;解决方法&lt;/h3&gt;

&lt;p&gt;http://www.cnblogs.com/yezhenhan/archive/2011/10/17/2215279.html&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;错误五：&lt;/h2&gt;

&lt;p&gt;One or more constraints have not been satisfied.&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;错误六：&lt;/h2&gt;

&lt;p&gt;安装完tomcat插件后，点击启动tomcat的小猫图标，没有启动tomcat，反而在没有断点的情况下进入了调试。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;解决方法：&lt;/h3&gt;

&lt;p&gt;重新建立工作区，重新导入，重新设置，这个情况出现是由于工作区配置在导入tomcat插件后出现混乱了。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;错误七：&lt;/h2&gt;

&lt;p&gt;重新建立工作区，重新配置，git,maven，tomcat插件都设置好了，项目重新导入没有异常，但启动tomcat时报异常&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.lang.ClassNotFoundException: org.apache.catalina.loader.DevLoader
at java.net.URLClassLoader$1.run(URLClassLoader.java:372)
at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
at java.security.AccessController.doPrivileged(Native Method)
at java.net.URLClassLoader.findClass(URLClassLoader.java:360)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-11&quot;&gt;解决方法：&lt;/h3&gt;

&lt;p&gt;1、在eclipse目录下，找到DevLoader包，位于\eclipse\plugins\com.sysdeo.eclipse.tomcat（tomcat插件） 的DevLoader.zip&lt;/p&gt;

&lt;p&gt;2、复制到apache-tomcat-6.0.x 里的lib里, 并改为DevLoader.jar&lt;/p&gt;

&lt;p&gt;3、重启tomcat.&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;错误八：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1698)
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1544)
at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4219)
at org.apache.catalina.core.StandardContext.start(StandardContext.java:4779)
at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:803)
at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:780)
at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:583)
at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:676)
at org.apache.catalina.startup.HostConfig.deployDescriptors(HostConfig.java:602)
at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:503)
at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1322)
at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:325)
at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:142)
at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1069)
at org.apache.catalina.core.StandardHost.start(StandardHost.java:822)
at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1061)
at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:463)
at org.apache.catalina.core.StandardService.start(StandardService.java:525)
at org.apache.catalina.core.StandardServer.start(StandardServer.java:761)
at org.apache.catalina.startup.Catalina.start(Catalina.java:595)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:483)
at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289)
at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-13&quot;&gt;解决方法：&lt;/h3&gt;

&lt;h2 id=&quot;section-14&quot;&gt;错误九：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;XX cannot be resolved
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-15&quot;&gt;解决方法：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;将编码格式改为UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-16&quot;&gt;错误十：&lt;/h2&gt;

&lt;p&gt;web.xml is missing and &lt;failonmissingwebxml&gt; is set to true、&lt;/failonmissingwebxml&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;解决方法：&lt;/h3&gt;

&lt;p&gt;如果你的项目在 /src/main/webapp/WEB-INF 下有web.xml，但是仍然还是报这个错误，需要两步操作&lt;/p&gt;

&lt;p&gt;1）右击项目，打开Properties对话框，点击Deployment Assembly选项，在右边添加一个文件夹，并且保存设置&lt;/p&gt;

&lt;p&gt;2）在eclispe上方点击Project -&amp;gt;Clean 清理一下这个项目&lt;/p&gt;

&lt;h2 id=&quot;section-18&quot;&gt;错误十一&lt;/h2&gt;

&lt;p&gt;编译项目时，编译到一半，eclipse卡死&lt;/p&gt;

&lt;h3 id=&quot;section-19&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;每次卡死的地方找到是一个js文件，所以，取消掉js的校验&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Window-&amp;gt;Preferences-&amp;gt;Valiation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取消表中关于javascript Client校验的勾选&lt;/p&gt;

&lt;p&gt;删除.project中校验js的配置项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	&amp;lt;buildCommand&amp;gt;
		&amp;lt;name&amp;gt;org.eclipse.wst.jsdt.core.javascriptValidator&amp;lt;/name&amp;gt;
		&amp;lt;arguments&amp;gt;
		&amp;lt;/arguments&amp;gt;
	&amp;lt;/buildCommand&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;br /&gt;
		&lt;nature&gt;org.eclipse.wst.jsdt.core.jsNature&lt;/nature&gt;&lt;/p&gt;

&lt;p&gt;删除项目中的js文件，重新添加&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>intellij尝试</title>
        <link>http://www.liuschen.com/2016/12/28/Intellij.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/12/28/Intellij.html</guid>
        <pubDate>Wed, 28 Dec 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;intellij是Androidstudio的前身，所以开发Androidstudio的插件需要在intellij上进行。&lt;/p&gt;

&lt;p&gt;安装后配置完SDK,JDK后build项目报异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Gradle sync failed: The newly created daemon process has a different context than expected.
		It won&#39;t be possible to reconnect to this daemon. Context mismatch: 
		Java home is different.
		Wanted: DefaultDaemonContext[uid=null,javaHome=F:\programer\IntelliJIDEA\jre,daemonRegistryDir=C:\Users\XX\.gradle\daemon,pid=78516,idleTimeout=null,daemonOpts=-XX:MaxPermSize=256m,-XX:+HeapDumpOnOutOfMemoryError,-Xmx1024m,-Dfile.encoding=GBK,-Duser.country=CN,-Duser.language=zh,-Duser.variant]
		Actual: DefaultDaemonContext[uid=e7392332-8703-4ff8-8fd8-4d9e707ccc63,javaHome=C:\Program Files (x86)\Java\jre1.8.0_101,daemonRegistryDir=C:\Users\XX\.gradle\daemon,pid=105692,idleTimeout=60000,daemonOpts=-XX:MaxPermSize=256m,-XX:+HeapDumpOnOutOfMemoryError,-Xmx1024m,-Dfile.encoding=GBK,-Duser.country=CN,-Duser.language=zh,-Duser.variant]
		Consult IDE log for more details (Help | Show Log)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为安装时，在Intellij目录下安装了jre,而我配置的JDK是我一直是用的那个版本，所以产生冲突了。&lt;/p&gt;

&lt;p&gt;想要开发插件是一个即时的想法，因为担心破坏目前的开发环境，就没再进行下去。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>MAVEN配置</title>
        <link>http://www.liuschen.com/2016/12/26/maven.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/12/26/maven.html</guid>
        <pubDate>Mon, 26 Dec 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;maven&quot;&gt;1.下载maven包&lt;/h3&gt;

&lt;h3 id=&quot;binmavenjava&quot;&gt;2.将文件中的bin目录加入系统环境变量,并在命令行中检查maven和java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mvn -v
java -version
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;apache-maven-303confsettingxml&quot;&gt;3.新建一个文件夹作为本地仓库，修改…\apache-maven-3.0.3\conf\目录下的setting.xml文件中的仓库路径为自己新建的仓库路径&lt;/h3&gt;

&lt;h3 id=&quot;mvn-helpsystem&quot;&gt;4.执行命令mvn help:system，会在仓库中下载一些东西&lt;/h3&gt;

&lt;h3 id=&quot;section&quot;&gt;5.新建项目&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mvn archetype:generate -DgroupId=com.chongshi.test -DartifactId=hello -DpackageName=com.chongshi.test -Dversion=1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会卡在 Generating project in Interactive mode这里，mvn archetype:generate后面需要加这个参数-DarchetypeCatalog=internal&lt;/p&gt;

&lt;h3 id=&quot;cdmvn-clean-compile&quot;&gt;6.创建成功项目后，cd进项目，执行mvn clean compile，第一次执行还会下载些东西，同时也会有编译好的文件生成&lt;/h3&gt;

&lt;h3 id=&quot;mvn-eclipseeclipseeclipse&quot;&gt;7.执行mvn eclipse:eclipse，生成eclipse项目&lt;/h3&gt;

&lt;h3 id=&quot;eclipseeclipsemaven&quot;&gt;8.此时项目已经能导入eclipse了，但是还会报错，因为依赖没有关联，需要配置eclipse的maven&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;window-&amp;gt;preferences-&amp;gt;java-&amp;gt;Build Path-&amp;gt;Classpath Variables
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下新添加一项，M2_REPO,值为Maven本地仓库路径，如果M2_REPO已经存在，并且改不了值，那么Preferences里面应该有Maven的设置，直接在里面改就可以了。&lt;/p&gt;

&lt;h3 id=&quot;maven-1&quot;&gt;9.此时，可以使用maven了。&lt;/h3&gt;

</description>
      </item>
    
      <item>
        <title>flash RTMP 推流</title>
        <link>http://www.liuschen.com/2016/12/19/flash.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/12/19/flash.html</guid>
        <pubDate>Mon, 19 Dec 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;flash曾经盛极一时，而如今却已日渐式微，就连微软和苹果都宣布不再支持flash。但是之前研究直播时用到基于rtmp协议的服务器red5其实就是一个flash直播框架。所以记录下，作为补充备忘，免得以后又做无用之功。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;movieclip&quot;&gt;1.MovieClip&lt;/h2&gt;

&lt;p&gt;影片剪辑，不同于 Sprite 对象，MovieClip 对象拥有一个时间轴。相当于可以直接在代码中编写动画脚本。&lt;/p&gt;

&lt;p&gt;如果修改包含补间动画的 MovieClip 对象的下列任一属性，该 MovieClip 对象中的播放头便会停止：alpha、blendMode、filters、height、opaqueBackground、rotation、scaleX、scaleY、scale9Grid、scrollRect、transform、visible、width、x 或 y。但是，它不会停止在该 MovieClip 对象的任何子 MovieClip 对象中的播放头。&lt;/p&gt;

&lt;h2 id=&quot;flaaction-script&quot;&gt;2.FLA和action script关联&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直接创建一个单独图层存放脚本，右键点击帧选择动作可以为每一帧添加脚本；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个文件夹，命名A，在文件夹中新建A.fla文件和A.as文件，用adobe flash编辑A.fla，点击发布，A.as就会关联发布出去，可以在actionscript高级设置中查看关联。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如果脚本中有访问网络，需要将&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;发布设置-&amp;gt;本地访问安全性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;改为“只访问网络”&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;action-script&quot;&gt;3.action script数据类型&lt;/h2&gt;

&lt;p&gt;String：文本值，例如，一个名称或书中某一章的文字&lt;/p&gt;

&lt;p&gt;Numeric：对于 numeric 型数据，ActionScript 3.0 包含三种特定的数据类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Number：任何数值，包括有小数部分或没有小数部分的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Int：一个整数（不带小数部分的整数）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Uint：一个“无符号”整数，即不能为负数的整数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Boolean：一个 true 或 false 值，例如开关是否开启或两个值是否相等&lt;/p&gt;

&lt;h2 id=&quot;htmlflash&quot;&gt;4.html向flash传递参数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;object id=&quot;forfun&quot; classid=&quot;clsid:&quot; width=&quot;400&quot; height=&quot;300&quot;
codebase=&quot;http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0&quot;&amp;gt;
&amp;lt;param name=&quot;movie&quot; value=&quot;simplest_as3_rtmp_streamer.swf?url=rtmp://192.168.20.189:1935/oflaDemo&amp;amp;stream=str5&quot;&amp;gt;
&amp;lt;param name=&quot;quality&quot; value=&quot;high&quot;&amp;gt;
&amp;lt;param name=&quot;bgcolor&quot; value=&quot;#F0F0F0&quot;&amp;gt;
&amp;lt;param name=&quot;menu&quot; value=&quot;false&quot;&amp;gt;
&amp;lt;param name=&quot;wmode&quot; value=&quot;opaque&quot;&amp;gt;
&amp;lt;param name=&quot;FlashVars&quot; value=&quot;url=rtmp://192.168.20.189:1935/oflaDemo&amp;amp;stream=str5&quot;&amp;gt;
&amp;lt;param name=&quot;allowScriptAccess&quot; value=&quot;sameDomain&quot;&amp;gt;
&amp;lt;embed id=&quot;forfunex&quot; src=&quot;simplest_as3_rtmp_streamer.swf?url=rtmp://192.168.20.189:1935/oflaDemo&amp;amp;stream=str5&quot;
    width=&quot;400&quot;
    height=&quot;300&quot;
    align=&quot;middle&quot;
    quality=&quot;high&quot;
    bgcolor=&quot;#f0fff8&quot;
    menu=&quot;false&quot;
    play=&quot;true&quot;
    loop=&quot;false&quot;
    FlashVars=&quot;url=rtmp://192.168.20.189:1935/oflaDemo&amp;amp;stream=str5&quot;
    allowScriptAccess=&quot;sameDomain&quot;
    type=&quot;application/x-shockwave-flash&quot;
    pluginspage=&quot;http://www.adobe.com/go/getflashplayer&quot;/&amp;gt;
&amp;lt;/object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;falsh中获取参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var url:String = stage.loaderInfo.parameters[&quot;url&quot;];
var stream:String = stage.loaderInfo.parameters[&quot;stream&quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;flash场景的大小可以通过在打开fla，场景中Ctrl+J快捷键修改&lt;/p&gt;

&lt;h2 id=&quot;action-script-rtmp&quot;&gt;5.action script RTMP相关类&lt;/h2&gt;

&lt;p&gt;NetConnection：连接服务器&lt;/p&gt;

&lt;p&gt;NetStream：用来发布和接收流&lt;/p&gt;

&lt;p&gt;Video:用来播放和显示&lt;/p&gt;

&lt;h3 id=&quot;httpblogcsdnnetleixiaohua1020articledetails43936141httpblogcsdnnetleixiaohua1020articledetails43936141&quot;&gt;参考：&lt;a href=&quot;http://blog.csdn.net/leixiaohua1020/article/details/43936141&quot;&gt;http://blog.csdn.net/leixiaohua1020/article/details/43936141&lt;/a&gt;&lt;/h3&gt;
</description>
      </item>
    
      <item>
        <title>JBMP安装</title>
        <link>http://www.liuschen.com/2016/12/12/jbmp.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/12/12/jbmp.html</guid>
        <pubDate>Mon, 12 Dec 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;1.下载&lt;/h2&gt;

&lt;p&gt;JBMP下载地址：&lt;a href=&quot;http://www.jbpm.org/download/download.html&quot;&gt;http://www.jbpm.org/download/download.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ant&quot;&gt;2.安装ant&lt;/h2&gt;

&lt;p&gt;相对简单，需要下载ant包，解压，将bin目录下文件写入环境变量即可，当然前提是必须有java环境，这个是默认的。&lt;/p&gt;

&lt;h2 id=&quot;cmd&quot;&gt;3.解压后cmd切换到目录中，运行&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ant install.demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后成功会出现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;......	
install.demo:

BUILD SUCCESSFUL
Total time: 19 minutes 53 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;4.运行&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ant start.demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会依次&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start.h2.check:
 [echo] Checking if h2 db should be started ...

start.h2:

start.jboss:

start.eclipse:

start.demo:

BUILD SUCCESSFUL
Total time: 25 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;5.访问服务器&lt;/h2&gt;

&lt;p&gt;然后，访问配置服务器：&lt;a href=&quot;http://localhost:9990/console&quot;&gt;http://localhost:9990/console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果不成功或是没有账号密码，可以自己添加，只需要执行&lt;/p&gt;

&lt;p&gt;jbpm-installer\wildfly-10.0.0.Final\bin&lt;/p&gt;

&lt;p&gt;下的add-user.bat,按引导即可。&lt;/p&gt;

&lt;p&gt;访问配置流程部署:&lt;a href=&quot;http://localhost:8080/jbpm-console&quot;&gt;http://localhost:8080/jbpm-console&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>c++学习笔记</title>
        <link>http://www.liuschen.com/2016/12/01/c++-copy.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/12/01/c++-copy.html</guid>
        <pubDate>Thu, 01 Dec 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在网上看到，正好正在学习c++，摘抄下比较在意的点,方便再看&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://man.lupaworld.com/content/develop/c&amp;amp;c++/c/c.htm#_Toc520634028&quot;&gt;来源：http://man.lupaworld.com/content/develop/c&amp;amp;c++/c/c.htm#_Toc520634028&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;1.引用与指针的比较&lt;/h1&gt;

&lt;p&gt;引用是C++中的概念，初学者容易把引用和指针混淆一起。一下程序中，n是m的一个引用（reference），m是被引用物（referent）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int m;
int &amp;amp;n = m; n相当于m的别名（绰号），对n的任何操作就是对m的操作。例如有人名叫王小毛，他的绰号是“三毛”。说“三毛”怎么怎么的，其实就是对王小毛说三道四。所以n既不是m的拷贝，也不是指向m的指针，其实n就是m它自己。 引用的一些规则如下： （1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。 （2）不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。 （3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

以下示例程序中，k被初始化为i的引用。语句k = j并不能将k修改成为j的引用，只是把k的值改变成为6。由于k是i的引用，所以i的值也变成了6。

 int i = 5;
int j = 6;
int &amp;amp;k = i;
k = j;    // k和i的值都变成了6;   
上面的程序看起来象在玩文字游戏，没有体现出引用的价值。引用的主要功能是传递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。
以下是“值传递”的示例程序。由于Func1函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n, 所以n的值仍然是0。
void Func1(int x)
{
	x = x + 10;
}
…
int n = 0;
Func1(n);
cout &amp;lt;&amp;lt; “n = ” &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl;    // n = 0
   
以下是“指针传递”的示例程序。由于Func2函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10。
    void Func2(int *x)
{
	(* x) = (* x) + 10;
}
…
int n = 0;
Func2(&amp;amp;n);
cout &amp;lt;&amp;lt; “n = ” &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl;        // n = 10
 
以下是“引用传递”的示例程序。由于Func3函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10。
void Func3(int &amp;amp;x)
{
	x = x + 10;
}
…
int n = 0;
Func3(n);
cout &amp;lt;&amp;lt; “n = ” &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl;      // n = 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比上述三个示例程序，会发现“引用传递”的性质象“指针传递”，而书写方式象“值传递”。实际上“引用”可以做的任何事情“指针”也都能够做，为什么还要“引用”这东西？&lt;br /&gt;
答案是“用适当的工具做恰如其分的工作”。&lt;br /&gt;
指针能够毫无约束地操作内存中的如何东西，尽管指针功能强大，但是非常危险。就象一把刀，它可以用来砍树、裁纸、修指甲、理发等等，谁敢这样用？&lt;br /&gt;
如果的确只需要借用一下某个对象的“别名”，那么就用“引用”，而不要用“指针”，以免发生意外。比如说，某人需要一份证明，本来在文件上盖上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;2.指针与数组的对比&lt;/h1&gt;

&lt;p&gt;C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。&lt;/p&gt;

&lt;p&gt;数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。&lt;/p&gt;

&lt;p&gt;指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。&lt;br /&gt;
下面以字符串为例比较指针与数组的特性。&lt;/p&gt;

&lt;p&gt;以下示例中，字符数组a的容量是6个字符，其内容为hello\0。a的内容可以改变，如a[0]= ‘X’。指针p指向常量字符串“world”（位于静态存储区，内容为world\0），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char a[] = “hello”;
a[0] = ‘X’;
cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;
char *p = “world”;     // 注意p指向常量字符串
p[0] = ‘X’;             // 编译器不能发现该错误
cout &amp;lt;&amp;lt; p &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;3.计算内存容量&lt;/h1&gt;

&lt;p&gt;用运算符sizeof可以计算出数组的容量（字节数）。示例7-3-3（a）中，sizeof(a)的值是12（注意别忘了’\0’）。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。&lt;br /&gt;
注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char a[] = &quot;hello world&quot;;
char *p  = a;
cout&amp;lt;&amp;lt; sizeof(a) &amp;lt;&amp;lt; endl;   // 12字节
cout&amp;lt;&amp;lt; sizeof(p) &amp;lt;&amp;lt; endl;   // 4字节
计算数组和指针的内存容量
  
void Func(char a[100])
{
    cout&amp;lt;&amp;lt; sizeof(a) &amp;lt;&amp;lt; endl;   // 4字节而不是100字节
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-3&quot;&gt;4.指针参数是如何传递内存的？&lt;/h1&gt;

&lt;p&gt;如果函数的参数是一个指针，不要指望用该指针去申请动态内存。示例7-4-1中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void GetMemory(char *p, int num)
{
    p = (char *)malloc(sizeof(char) * num);
}
void Test(void)
{
    char *str = NULL;
    GetMemory(str, 100);    // str 仍然为 NULL 
    strcpy(str, &quot;hello&quot;);   // 运行错误
}
示例7-4-1 试图用指针参数申请动态内存
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把_p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。&lt;br /&gt;
如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例7-4-2。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void GetMemory2(char **p, int num)
{
    *p = (char *)malloc(sizeof(char) * num);
}
void Test2(void)
{
    char *str = NULL;
    GetMemory2(&amp;amp;str, 100);  // 注意参数是 &amp;amp;str，而不是str
    strcpy(str, &quot;hello&quot;);  
    cout&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    free(str); 
}
示例7-4-2用指向指针的指针申请动态内存
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例7-4-3。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *GetMemory3(int num)
{
    char *p = (char *)malloc(sizeof(char) * num);
    return p;
}
void Test3(void)
{
    char *str = NULL;
    str = GetMemory3(100); 
    strcpy(str, &quot;hello&quot;);
    cout&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    free(str); 
}
示例7-4-3 用函数返回值来传递动态内存
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例7-4-4。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *GetString(void)
{
    char p[] = &quot;hello world&quot;;
    return p;   // 编译器将提出警告
}
void Test4(void)
{
char *str = NULL;
str = GetString();  // str 的内容是垃圾
cout&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
}
示例7-4-4 return语句返回指向“栈内存”的指针
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用调试器逐步跟踪Test4，发现执行str = GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。&lt;br /&gt;
如果把示例7-4-4改写成示例7-4-5，会怎么样？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *GetString2(void)
{
    char *p = &quot;hello world&quot;;
    return p;
}
void Test5(void)
{
    char *str = NULL;
    str = GetString2();
    cout&amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
}
示例7-4-5 return语句返回常量字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数Test5运行虽然不会出错，但是函数GetString2的设计概念却是错误的。因为GetString2内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;5.参数的缺省值&lt;/h1&gt;

&lt;p&gt;有一些参数的值在每次函数调用时都相同，书写这样的语句会使人厌烦。C++语言采用参数的缺省值使书写变得简洁（在编译时，缺省值由编译器自动插入）。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参数缺省值的使用规则：&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;5.1.参数缺省值只能出现在函数的声明中，而不能出现在定义体中。&lt;/h3&gt;
&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Foo(int x=0, int y=0);    // 正确，缺省值出现在函数的声明中
 
void Foo(int x=0, int y=0)        // 错误，缺省值出现在函数的定义体中
{
…
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么会这样？我想是有两个原因：一是函数的实现（定义）本来就与参数是否有缺省值无关，所以没有必要让缺省值出现在函数的定义体中。二是参数的缺省值可能会改动，显然修改函数的声明比修改函数的定义要方便。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;5.2.如果函数有多个参数，参数只能从后向前挨个儿缺省，否则将导致函数调用语句怪模怪样。&lt;/h3&gt;
&lt;p&gt;正确的示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Foo(int x, int y=0, int z=0);
错误的示例如下：
void Foo(int x=0, int y, int z=0);   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意，使用参数的缺省值并没有赋予函数新的功能，仅仅是使书写变得简洁一些。它可能会提高函数的易用性，但是也可能会降低函数的可理解性。所以我们只能适当地使用参数的缺省值，要防止使用不当产生负面效果。示例8-3-2中，不合理地使用参数的缺省值将导致重载函数output产生二义性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
void output( int x);
void output( int x, float y=0.0);
 
void output( int x)
{
    cout &amp;lt;&amp;lt; &quot; output int &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl ;
}
 
void output( int x, float y)
{
    cout &amp;lt;&amp;lt; &quot; output int &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot; and float &quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl ;
}
 
void main(void)
{
    int x=1;
    float y=0.5;
//  output(x);          // error! ambiguous call
    output(x,y);        // output int 1 and float 0.5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数的缺省值将导致重载函数产生二义性&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>c语言微知识点</title>
        <link>http://www.liuschen.com/2016/11/27/C++-point.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/11/27/C++-point.html</guid>
        <pubDate>Sun, 27 Nov 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;c-new&quot;&gt;1.c++ 中如何new一个对象&lt;/h2&gt;

&lt;p&gt;demo* demo0 = new demo();&lt;/p&gt;

&lt;h2 id=&quot;c-&quot;&gt;2.c语言结构体.和-&amp;gt;的区别&lt;/h2&gt;

&lt;p&gt;结构体变量的引用和赋值，有两种形式，一种是用符号”.”，一种是用符号”-&amp;gt;”。结构体指针变量一般用”-&amp;gt;”，非结构体指针变量，也就是一般结构体变量，一般用”.”。&lt;/p&gt;

&lt;h2 id=&quot;c&quot;&gt;3.C++回调函数&lt;/h2&gt;

&lt;p&gt;1.重新定义一个函数指针类型&lt;/p&gt;

&lt;p&gt;typedef void(*pcb)();&lt;/p&gt;

&lt;p&gt;2.将该函数指针作为函数的形参&lt;/p&gt;

&lt;p&gt;virtual void getSomeThing(pcb call);&lt;/p&gt;

&lt;p&gt;3.传入回掉函数&lt;/p&gt;

&lt;p&gt;4.在getSomeThing中执行回调函数call()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Func(char *s)；// 函数原型
void (*pFunc) (char *);//函数指针
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;4.&amp;amp;运算符&lt;/h2&gt;

&lt;p&gt;1.求址运算符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int *p;
int a = 9;
p = &amp;amp;a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.引用（相当于别名,用作引用的名字不能作为其他变量别名）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i = 5;
int j = 6;
int &amp;amp;k = i;
k = j;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;5.宽类型的输出&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;wchar_t c= L&quot;例子&quot;;//需要前面加‘L’
wcout.imbue(locale(&quot;chs&quot;));//设定中文编码格式
wcout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;//输出
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>jni编程中C++/C语言一些问题</title>
        <link>http://www.liuschen.com/2016/11/20/C++-jni.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/11/20/C++-jni.html</guid>
        <pubDate>Sun, 20 Nov 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;uint8t&quot;&gt;1.uint8_t&lt;/h2&gt;
&lt;p&gt;首先，先来看一下jni.h关于j数据类型的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_INTTYPES_H
# include &amp;lt;inttypes.h&amp;gt;      /* C99 */
typedef uint8_t         jboolean;       /* unsigned 8 bits */
typedef int8_t          jbyte;          /* signed 8 bits */
typedef uint16_t        jchar;          /* unsigned 16 bits */
typedef int16_t         jshort;         /* signed 16 bits */
typedef int32_t         jint;           /* signed 32 bits */
typedef int64_t         jlong;          /* signed 64 bits */
typedef float           jfloat;         /* 32-bit IEEE 754 */
typedef double          jdouble;        /* 64-bit IEEE 754 */
#else
typedef unsigned char   jboolean;       /* unsigned 8 bits */
typedef signed char     jbyte;          /* signed 8 bits */
typedef unsigned short  jchar;          /* unsigned 16 bits */
typedef short           jshort;         /* signed 16 bits */
typedef int             jint;           /* signed 32 bits */
typedef long long       jlong;          /* signed 64 bits */
typedef float           jfloat;         /* 32-bit IEEE 754 */
typedef double          jdouble;        /* 64-bit IEEE 754 */
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在inttypes.h中又有如下定义，当然不同环境可能定义略有不同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#if defined(_CHAR_IS_SIGNED)  
typedef char                    int8_t;  
#else  
#if defined(__STDC__)  
typedef signed char             int8_t;  
#endif  
#endif  
typedef short                   int16_t;  
typedef int                     int32_t;  
#ifdef  _LP64  
#define _INT64_TYPE  
typedef long                    int64_t;  
#else   /* _ILP32 */  
#if defined(_LONGLONG_TYPE)  
#define _INT64_TYPE  
typedef long long               int64_t;  
#endif  
#endif  
  
typedef unsigned char           uint8_t;  
typedef unsigned short          uint16_t;  
typedef unsigned int            uint32_t;  
#ifdef  _LP64  
typedef unsigned long           uint64_t;  
#else   /* _ILP32 */  
#if defined(_LONGLONG_TYPE)  
typedef unsigned long long      uint64_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如uint8_t是unsigned char的别名，能直观的体现所表示类型的字节数，以及符号属性，在不同的环境即是所表示的数据类型不同，但是只要在inttypes.h中将这种差异处理了，程序通过调用uint8_t并不会有什么影响，因为它只表示无符号一字节的数据，方便了程序不同平台的移植。在做音视频传输时，帧的数据就是通过uint8_t数组来存储的。&lt;/p&gt;

&lt;h2 id=&quot;env&quot;&gt;2.env&lt;/h2&gt;
&lt;p&gt;注意：jni.h头文件中对于&lt;em&gt;**.c &amp;amp; **&lt;/em&gt;.cpp采用不同的定义&lt;br /&gt;
在C的定义中,env是一个两级指针,而在C++的定义中,env是个一级指针&lt;br /&gt;
C形式需要对env指针进行双重deferencing，而且须将env作为第一个参数传给jni函数,如进行字符串转化时：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C++:env0-&amp;gt;GetStringUTFChars(url, NULL)
C:(*env)-&amp;gt;GetStringUTFChars(env,url, NULL)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;3.类型转换&lt;/h2&gt;

&lt;p&gt;C++ char const* 类型和字符串互相转化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
std::string src1(rootpath);
std::string src2(streamName0);
std::string dest = src1 + src2;
char const* streamName = dest.c_str();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cuintt&quot;&gt;4.C++将uint_t数组输出到文件&lt;/h2&gt;

&lt;p&gt;头文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;fstream&amp;gt;
using namespace std;//这个必须加
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ofstream outfile;
outfile.open(store_path);
for(i=0;i&amp;lt;size;i++){
	outfile&amp;lt;&amp;lt;fReceiveBuffer[i];
}
outfile.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cjava&quot;&gt;5.C++调用Java&lt;/h2&gt;

&lt;p&gt;通过路径找到要调用的java方法所在类&lt;/p&gt;

&lt;p&gt;jclass dpclazz = (env)-&amp;gt;FindClass(“com/JavaJNI”);&lt;/p&gt;

&lt;p&gt;寻找class里面的方法，javap -p -s 获取 ()V&lt;/p&gt;

&lt;p&gt;jmethodID method1 = (env)-&amp;gt;GetMethodID(dpclazz,”调用方法”,”()V”);&lt;/p&gt;

&lt;p&gt;obj1是java对象实例,method1为方法,再后面方法为参数&lt;/p&gt;

&lt;p&gt;(env)-&amp;gt;CallVoidMethod(obj1,method1,。。);&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>RTMP延时问题</title>
        <link>http://www.liuschen.com/2016/11/17/RTMP.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/11/17/RTMP.html</guid>
        <pubDate>Thu, 17 Nov 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;用的是方案一的流媒体传输，如果只传输视频，延时非常严重。分析原因无非两个，一个是推流客户端的问题，一个是播放器的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在window上收流时发现，延时主要发生在两个函数上&lt;/p&gt;

&lt;h1 id=&quot;avformatopeninput&quot;&gt;1.avformat_open_input&lt;/h1&gt;

&lt;h1 id=&quot;avformatfindstreaminfo&quot;&gt;2.avformat_find_stream_info&lt;/h1&gt;

&lt;p&gt;这个是用来解析流信息的，可以在之前设置这个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifmt_ctx-&amp;gt;probesize = 100 * 1024;
ifmt_ctx-&amp;gt;max_analyze_duration = 5 * AV_TIME_BASE;

if ((ret = avformat_find_stream_info(ifmt_ctx, 0)) &amp;lt; 0) {
	printf( &quot;Failed to retrieve input stream information&quot;);
	goto end;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以大大提高解析速度&lt;/p&gt;

&lt;p&gt;其实用ffplay播放时，通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-fflags nobuffer -analyzeduration 1000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数已经解决了这个问题，但是播放延迟还在，那么就有可能是客户端的问题了，之前是通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	recorder = new FFmpegFrameRecorder(url, width, height, 1);
    recorder.setVideoBitrate(2000000);
    recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264);
    recorder.setFormat(&quot;flv&quot;);
    recorder.setFrameRate(10);
    recorder.setVideoOption(&quot;tune&quot;,&quot;zerolatency&quot;);
    recorder.setVideoOption(&quot;preset&quot;,&quot;ultrafast&quot;);
    recorder.setGopSize(GOP_LENGTH_IN_FRAMES);
    recorder.setVideoQuality(28);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单纯设置了视频的参数，但是通过阅读FFmpegFrameRecorder源码，发现音视频参数都设置了初始值，所以可能是默认仍然传输了音频。所以添加了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    recorder.setAudioBitrate(0);
    recorder.setAudioChannels(-1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;果然本来延时10多秒，恢复到了正常范围，延迟大约1s左右。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>ffmpeg/ffplay命令记录（转载，整理）</title>
        <link>http://www.liuschen.com/2016/11/16/ffplay.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/11/16/ffplay.html</guid>
        <pubDate>Wed, 16 Nov 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;打出来的视频信息，但是没有播放，但是会输出视频帧到当前目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -i &quot;rtmp://192.168.24.142/oflaDemo/st6 live=1&quot; -f image2 -vf fps=fps=1 out%d.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;播放RMTP直播流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffplay -i &quot;rtmp://192.168.24.142/oflaDemo/st6 live=1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fplay播放yuv文件命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffplay -f rawvideo -video_size 1920x1080 a.yuv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置播放没有缓冲区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffplay -x 240 -y 320 109.flv -fflags nobuffer


ffplay -i &quot;rtmp://192.168.24.142/oflaDemo/st5 live=1&quot; -fflags nobuffer -analyzeduration 1000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出本机可用设备&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -list_devices true -f dshow -i dummy 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;播放本机USB摄像头捕捉数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffplay -f dshow -i video=&quot;USB Camera&quot; -f dshow -i audio=&quot;音频设备&quot;
ffplay -f vfwcap -i 0
//设置分辨率和帧率播放
ffplay -s 424x240 -r 5 -f dshow -i video=&quot;USB Camera&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将USB摄像头捕捉的数据编码成H264保存到文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -f dshow -i video=&quot;USB Camera&quot; -vcodec libx264 camera.mkv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将USB摄像头数据通过RTMP协议发送出去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -f dshow -i video=&quot;USB Camera&quot; -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://localhost/oflaDemo/livestream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看设备选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -list_options true -f dshow -i video=&quot;USB Camera&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分离视频音频流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -i input_file -vcodec copy -an output_file_video　　//分离视频流
ffmpeg -i input_file -acodec copy -vn output_file_audio　　//分离音频流
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;视频解复用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg –i test.mp4 –vcodec copy –an –f m4v test.264
ffmpeg –i test.avi –vcodec copy –an –f m4v test.264
//这个m4v是表示mp4的格式，如果是flv就需要写成flv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;视频转码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg –i test.mp4 –vcodec h264 –s 352*278 –an –f m4v test.264              //转码为码流原始文件
ffmpeg –i test.mp4 –vcodec h264 –bf 0 –g 25 –s 352*278 –an –f m4v test.264  //转码为码流原始文件
ffmpeg –i test.avi -vcodec mpeg4 –vtag xvid –qsame test_xvid.avi            //转码为封装文件
//-bf B帧数目控制，-g 关键帧间隔控制，-s 分辨率控制
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;视频封装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;视频剪切&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg –i test.avi –r 1 –f image2 image-%3d.jpeg        //提取图片
ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi    //剪切视频
//-r 提取图像的频率，-ss 开始时间，-t 持续时间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;视频录制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg –i rtsp://192.168.3.205:5555/test –vcodec copy out.avi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;YUV序列播放&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffplay -f rawvideo -video_size 1920x1080 input.yuv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;YUV序列转AVI&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg –s w*h –pix_fmt yuv420p –i input.yuv –vcodec mpeg4 output.avi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采集usb摄像头视频命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -t 20 -f vfwcap -i 0 -r 8 -f mp4 cap1111.mp4

具体说明如下：我们采集10秒，采集设备为vfwcap类型设备，第0个vfwcap采集设备（如果系统有多个vfw的视频采集设备，可以通过-i num来选择），每秒8帧，输出方式为文件，格式为mp4。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最简单的抓屏：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -f gdigrab -i desktop out.mpg 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从屏幕的（10,20）点处开始，抓取640x480的屏幕，设定帧率为5 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -f gdigrab -framerate 5 -offset_x 10 -offset_y 20 -video_size 640x480 -i desktop out.mpg 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;录屏推流播放&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//录屏RTMP推流
ffmpeg -f gdigrab  -i desktop  -vcodec libx264 -f flv rtmp://192.168.1.14/oflaDemo/str5

//直播RTMP推流
ffmpeg -f dshow -i video=&quot;USB Camera&quot; -f dshow -i audio=&quot;麦克风 (Conexant SmartAudio HD)&quot; -r 5 -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -acodec libmp3lame -f flv rtmp://192.168.1.14/oflaDemo/str5

//延迟较小的播放
ffplay -i &quot;rtmp://192.168.1.14/oflaDemo/str5 live=1&quot; -fflags nobuffer -analyzeduration 1000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gdigrab是基于GDI的抓屏设备，可以用于抓取屏幕的特定区域。&lt;/p&gt;

&lt;p&gt;gdigrab通过设定不同的输入URL，支持两种方式的屏幕抓取：&lt;/p&gt;

&lt;p&gt;（1）“desktop”：抓取整张桌面。或者抓取桌面中的一个特定的区域。&lt;/p&gt;

&lt;p&gt;（2）“title={窗口名称}”：抓取屏幕中特定的一个窗口。&lt;/p&gt;

&lt;p&gt;设置编码方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;音频：-acodec libmp3lame
视频：-vcodec libx264
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ffmpeg从视频中生成gif图片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -i capx.mp4 -t 10 -s 320x240 -pix_fmt rgb24 jidu1.gif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ffmpeg将图片转换为视频&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;指定编码，帧率和码率，图片在当前目录下需要按照自然数排序命名
ffmpeg -f image2 -i c:\temp\d.jpg -vcodec libx264 -r 10 -b 200k  test.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将文件当做直播送至live&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -re -i localFile.mp4 -c copy -f flv rtmp://server/live/streamName
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将直播媒体保存至本地文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -i rtmp://server/live/streamName -c copy dump.flv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将其中一个直播流，视频改用h264压缩，音频不变，送至另外一个直播服务流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv rtmp://server/live/h264Stream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将其中一个直播流，视频改用h264压缩，音频改用faac压缩，送至另外一个直播服务流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -i rtmp://server/live/originalStream -c:a libfaac -ar 44100 -ab 48k -c:v libx264 -vpre slow -vpre baseline -f flv rtmp://server/live/h264Stream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将其中一个直播流，视频不变，音频改用faac压缩，送至另外一个直播服务流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -i rtmp://server/live/originalStream -acodec libfaac -ar 44100 -ab 48k -vcodec copy -f flv rtmp://server/live/h264_AAC_Stream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将一个高清流，复制为几个不同视频清晰度的流重新发布，其中音频不变&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -re -i rtmp://server/live/high_FMLE_stream -acodec copy -vcodec x264lib -s 640×360 -b 500k -vpre medium -vpre baseline rtmp://server/live/baseline_500k -acodec copy -vcodec x264lib -s 480×272 -b 300k -vpre medium -vpre baseline rtmp://server/live/baseline_300k -acodec copy -vcodec x264lib -s 320×200 -b 150k -vpre medium -vpre baseline rtmp://server/live/baseline_150k -acodec libfaac -vn -ab 48k rtmp://server/live/audio_only_AAC_48k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;功能一样，只是采用-x264opts选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -re -i rtmp://server/live/high_FMLE_stream -c:a copy -c:v x264lib -s 640×360 -x264opts bitrate=500:profile=baseline:preset=slow rtmp://server/live/baseline_500k -c:a copy -c:v x264lib -s 480×272 -x264opts bitrate=300:profile=baseline:preset=slow rtmp://server/live/baseline_300k -c:a copy -c:v x264lib -s 320×200 -x264opts bitrate=150:profile=baseline:preset=slow rtmp://server/live/baseline_150k -c:a libfaac -vn -b:a 48k rtmp://server/live/audio_only_AAC_48k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将当前摄像头及音频通过DSSHOW采集，视频h264、音频faac压缩后发布&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -r 25 -f dshow -s 640×480 -i video=”video source name”:audio=”audio source name” -vcodec libx264 -b 600k -vpre slow -acodec libfaac -ab 128k -f flv rtmp://server/application/stream_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将一个JPG图片经过h264压缩循环输出为mp4视频&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg.exe -i INPUT.jpg -an -vcodec libx264 -coder 1 -flags +loop -cmp +chroma -subq 10 -qcomp 0.6 -qmin 10 -qmax 51 -qdiff 4 -flags2 +dct8x8 -trellis 2 -partitions +parti8x8+parti4x4 -crf 24 -threads 0 -r 25 -g 25 -y OUTPUT.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将普通流视频改用h264压缩，音频不变，送至高清流服务(新版本FMS live=1)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv “rtmp://server/live/h264Stream live=1〃
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
  </channel>
</rss>