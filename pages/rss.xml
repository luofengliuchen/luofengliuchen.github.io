<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>落风的博客</title>
    <link>http://www.liuschen.com</link>
    <description>落风的博客</description>
    
      <item>
        <title>Proguard</title>
        <link>http://www.liuschen.com/2016/08/05/proguard.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/08/05/proguard.html</guid>
        <pubDate>Fri, 05 Aug 2016 00:00:00 +0800</pubDate>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout: post&lt;br /&gt;
title: Androidstudio下的代码混淆&lt;br /&gt;
category: 技术&lt;br /&gt;
keywords: 混淆&lt;br /&gt;
—&lt;/p&gt;

&lt;p&gt;首先在项目的build.gradle中Android标签下添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signingConfigs {
    release {
        keyAlias &#39;xxx&#39;
        keyPassword &#39;xxx&#39;
        storeFile file(&#39;xxx&#39;)
        storePassword &#39;xxx&#39;
    }
}

buildTypes {
    release {
        signingConfig signingConfigs.release
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中第二个是混淆的设置，第一个配置的是数字签名的路径以及密码等信息，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signingConfig signingConfigs.release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;个是依赖于这项配置的，不然会报错&lt;/p&gt;

&lt;p&gt;然后，就是配置混淆的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-ignorewarnings
-optimizationpasses 5          # 指定代码的压缩级别
-dontusemixedcaseclassnames   # 是否使用大小写混合
-dontpreverify           # 混淆时是否做预校验
-verbose                # 混淆时是否记录日志


-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*  # 混淆时所采用的算法

-keep public class * extends android.app.Activity      # 保持哪些类不被混淆
-keep public class * extends android.app.Application   # 保持哪些类不被混淆
-keep public class * extends android.app.Service       # 保持哪些类不被混淆
-keep public class * extends android.content.BroadcastReceiver  # 保持哪些类不被混淆
-keep public class * extends android.content.ContentProvider    # 保持哪些类不被混淆
-keep public class * extends android.app.backup.BackupAgentHelper # 保持哪些类不被混淆
-keep public class * extends android.preference.Preference        # 保持哪些类不被混淆
-keep public class com.android.vending.licensing.ILicensingService    # 保持哪些类不被混淆

-keep class javax.security.** { *; }


-keepclasseswithmembernames class * {  # 保持 native 方法不被混淆
    native &amp;lt;methods&amp;gt;;
}
-keepclasseswithmembers class * {   # 保持自定义控件类不被混淆
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet);
}
-keepclasseswithmembers class * {# 保持自定义控件类不被混淆
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet, int);
}
-keepclassmembers class * extends android.app.Activity { # 保持自定义控件类不被混淆
    public void *(android.view.View);
}
-keepclassmembers enum * {     # 保持枚举 enum 类不被混淆
    public static **[] values();
    public static ** valueOf(java.lang.String);
}
-keep class * implements android.os.Parcelable { # 保持 Parcelable 不被混淆
    public static final android.os.Parcelable$Creator *;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下，系统的控件不必要混淆，如activity，service等，其次由于默在Androidstudio中默认已经将libs包中的jar添加了，重复添加反而会报错，最后项目中用到反射的地方一定不能混淆。&lt;br /&gt;
添加完后却还是报错了，先添加了-dontwarn，然并没什么用，然后加了-ignorewarnings忽略警告，成功生成apk,只是一定要注意确保警告中的地方没被项目调用，否则实际运行时还会出错，后果更严重。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Nine</title>
        <link>http://www.liuschen.com/2016/08/02/nine.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/08/02/nine.html</guid>
        <pubDate>Tue, 02 Aug 2016 00:00:00 +0800</pubDate>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout: post&lt;br /&gt;
title: .9图片的用法绘制以及作用&lt;br /&gt;
category: 技术&lt;br /&gt;
keywords: .9图片&lt;br /&gt;
—&lt;/p&gt;

&lt;p&gt;问题:&lt;/p&gt;

&lt;p&gt;今天从网上down下了一个eclipse下的项目，导入到androidStudio中后，结果出现了如下异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\myAllProject\androidstudio_ajlast\321Browser\uCBrowser_1113\src\main\res\layout\above_slidingmenu.xml
Error:(111, 30) No resource found that matches the given name (at &#39;src&#39; with value &#39;@drawable/menubar_tabcenter_d&#39;).

Error:(20, 38) No resource found that matches the given name (at &#39;src&#39; with value &#39;@drawable/url_progress_fullscreen&#39;).
D:\myAllProject\androidstudio_ajlast\321Browser\uCBrowser_1113\src\main\res\drawable\search_btn_bg.xml
Error:(5, 87) No resource found that matches the given name (at &#39;drawable&#39; with value &#39;@drawable/search_engines_switcher_item_bg_p&#39;).
Error:(6, 87) No resource found that matches the given name (at &#39;drawable&#39; with value &#39;@drawable/search_engines_switcher_item_bg_p&#39;).
Error:Execution failed for task &#39;:uCBrowser_1113:processDebugResources&#39;.
com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &#39;command &#39;F:\programer\android_sdk\build-tools\23.0.2\aapt.exe&#39;&#39; finished with non-zero exit value 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纠结了很久发现都是.9图片的问题，于是按照网上说的在android的gradle中android标签下加入下面代码，避免了对 .9图片的检查&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aaptOptions.cruncherEnabled = false
aaptOptions.useNewCruncher = false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而会继续报错，原因是图片上的像素定位点没有添加,最后还是一个一个改的。&lt;/p&gt;

&lt;p&gt;问题核心：&lt;/p&gt;

&lt;p&gt;.9图片可以根据ps绘制，同时，android里面也有专门的绘制工具。&lt;br /&gt;
.9图片区别于普通图片主要是通过两点：&lt;br /&gt;
1.特殊的扩展名，供专门的应用识别&lt;br /&gt;
2.图片上下左右4个特殊的黑色像素条，宽一个像素，也可以仅仅是一个点，其中上边和左边像素条标记的分别是图片在横向和纵向的可拉伸区域，至于右边和下边的像素条，网上说是表示“前景能显示的范围”，用了这么久，没见过可以区别的效果，所以也不大理解是什么意思。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Android解压缩zip文件</title>
        <link>http://www.liuschen.com/2016/07/22/zip.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/07/22/zip.html</guid>
        <pubDate>Fri, 22 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;期望:使项目apk包中的大文件批量数据可以单独作为一个apk来管理，所以需要将Android assets文件夹下的zip打包文件解压到SDCard上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解压缩的操作由于比较耗时，所以新开一个线程执行以下函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**将assets对应文件解压到对应的sdcard目录中*/
public void unPress2Sdcard(String fileName){
    try {
        /**目标路径*/
        String destDir = rootPath + File.separator + fileName;
        /**将压缩文件拷贝到内存卡中*/
        mAssetCopyer.copyBigDataToSD(destDir, fileName);
        /**解压文件到目标路径*/
        unzip(destDir, offlinePath);
        /**删除在内存卡上临时存在的压缩文件*/
        FileUtils.deleteFile(destDir);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的先将assets下的zip文件拷贝到SDCard中，这个是直接在网上找的方法拿来用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void copyBigDataToSD(String strOutFileName,String file) throws IOException{
    InputStream myInput;
    OutputStream myOutput = new FileOutputStream(strOutFileName);
    myInput = mContext.getAssets().open(file);
    byte[] buffer = new byte[1024];
    int length = myInput.read(buffer);
    while(length &amp;gt; 0){
        myOutput.write(buffer, 0, length);
        length = myInput.read(buffer);
    }
    myOutput.flush();
    myInput.close();
    myOutput.close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后解压缩操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)  
public static void unzip(String zipFilePath, String unzipFilePath) throws Exception{
    /**验证是否为空*/
    if (isEmpty(zipFilePath) || isEmpty(unzipFilePath)){

    }
    File zipFile = new File(zipFilePath);
    /**创建解压缩文件保存的路径*/
    File unzipFileDir = new File(unzipFilePath);
    if (!unzipFileDir.exists()){
        unzipFileDir.mkdirs();
    }
    //开始解压
    ZipEntry entry = null;
    String entryFilePath = null;
    int count = 0, bufferSize = 1024;
    byte[] buffer = new byte[bufferSize];  
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;  
    ZipFile zip = new ZipFile(zipFile);
    Enumeration&amp;lt;ZipEntry&amp;gt; entries = (Enumeration&amp;lt;ZipEntry&amp;gt;)zip.entries();  
    //循环对压缩包里的每一个文件进行解压
    while(entries.hasMoreElements()){
        entry = entries.nextElement();
        log(&quot;log ing5:&quot;+entry.getName());
        /**这里提示如果当前元素是文件夹时，在目录中创建对应文件夹
         * ，如果是文件，得出路径交给下一步处理*/
        entryFilePath = unzipFilePath + File.separator + entry.getName();
        File file = new File(entryFilePath);
        log(&quot;~~是否是文件夹:&quot;+file.isDirectory());
        if(entryFilePath.endsWith(&quot;/&quot;)){
            if(!file.exists()){
                file.mkdir();
            }
            continue;
        }
        /***这里即是上一步所说的下一步，负责文件的写入，不服来咬(≖ ‿ ≖)✧*/
        bos = new BufferedOutputStream(new FileOutputStream(entryFilePath+&quot;/&quot;));
        bis = new BufferedInputStream(zip.getInputStream(entry));
        while ((count = bis.read(buffer, 0, bufferSize)) != -1){
            bos.write(buffer, 0, count);
        }
        bos.flush();
        bos.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用的也是直接网上down下来的，但是在解压缩操作中遇到的是这一句bos = new BufferedOutputStream(new FileOutputStream(entryFilePath));传入的entryFilePath运行的时候却老提示不是文件夹，于是把中间循环解压元素的代码以及一些冗余的逻辑删除了，改成了现在这样，进入循环先判断是否是文件夹(我这里是靠尾部的字符判断的)，如果是，在目标路径中创建，开始下一循环，不是，就把文件解压到对应路径。&lt;/p&gt;

&lt;p&gt;最后一步删除SDcard下的压缩文件&lt;br /&gt;
FileUtils.deleteFile(destDir);&lt;/p&gt;

&lt;p&gt;注意:源压缩包必须是zip格式的并且是快速压缩，超高压缩算法不同，解析不了，我是在window上用快压打包的。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>程序员编程语录</title>
        <link>http://www.liuschen.com/2016/06/07/person.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/06/07/person.html</guid>
        <pubDate>Tue, 07 Jun 2016 00:00:00 +0800</pubDate>
        <description>&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;一个好的程序员是那种过单行线马路都要往两边看的人。(Doug Linder)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;程序有问题时不要担心。如果所有东西都没问题，你就失业了。(软件工程的Mosher定律)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;程序员的麻烦在于，你无法弄清他在捣腾什么，当你最终弄明白时，也许已经晚了。(超级计算机之父Seymour Cray)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我想大部分人都知道通常一个程序员会具有的美德。当然了，有三种：懒惰，暴躁，傲慢。(Perl语言发明者Larry Wall)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编程时要保持这种心态：就好象将来要维护你这些代码的人是一位残暴的精神病患者，而且他知道你住在哪。(Martin Golding)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个人写的烂软件将会给另一个人带来一份全职工作。(Jessica Gaston)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果建筑工人像程序员写软件那样盖房子，那第一只飞来的啄木鸟就能毁掉人类文明。(Gerald Weinberg)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这世界最有可能毁灭的方式——大多数专家都同意——是次意外。这就是为什么会有我们，我们是计算机专家，我们创造意外。(Nathaniel Borenstein)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们这个行业有个特别奇怪的现象：不仅我们不从失败里吸取教训，同时也不从成功中学习经验。 (Keith  Braithwaite)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一种新技术一旦开始流行，你要么坐上压路机，要么成为铺路石。(Stewart Brand)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没能一次成功，那就叫它1.0版吧。(unknown)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有的程序员都是编剧，所有的计算机都是烂演员。(Anonymous Hack Actor)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工作进度上越早落后，你就会有越充足的时间赶上。(Anonymous Scheduler)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当有这样的一种编程语言出现：它能让程序员用简单的英语编程，你将会发现，程序员都开始不会说英语。(Anonymous Linguist)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么我们没有时间把事情做对，却总有时间把事情做过头？(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;傻瓜都能写出计算机能理解的程序。优秀的程序员写出的是人类能读懂的代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任何你写的代码，超过6个月不去看它，当你再看时，都像是别人写的。(Eagleson’s law)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编程/软件开发语录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;按代码行数来评估软件开发的进度，就如同按重量来评估飞机建造的进度。(Bill Gates)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件就像做爱。一次犯错，你需要用余下一生来维护支持。(Michael Sinz)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在水上行走和按需求文档开发软件都很容易——前提是它们都是冻结状态。(Edward V Berard)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最初90%的代码用去了最初90%的开发时间…余下10%的代码用去了另外90%的开发时间。(Tom Cargill)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注释代码很像清洁你的厕所——你不想干，但如果你做了，这绝对会给你和你的客人带来更愉悦的体验。(Ryan Campbell)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如今的编程是一场程序员和上帝的竞赛，程序员要开发出更大更好、傻瓜都会用到软件。而上帝在努力创造出更大更傻的傻瓜。目前为止，上帝是赢的。(Rick Cook)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件设计最困难的部分…是阻挡新功能的引入。(Donald Norman)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了理解递归，我们首先要理解的是递归。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;世上只有两类编程语言：那些拥有被人诟病的和那些没人用的。(Bjarne Stroustrup)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The best thing about a boolean is even if you are wrong, you are only off by a bit. (Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果Java能实现真的垃圾回收，那大部分的程序都会在执行时删除自己。(Robert Swell)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;理论上，理论和实践是没有差异的。但实践中，是有的。(Jan L. A. van de Snepscheut)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;预备，开火，瞄准：这是最快的软件开发方法。预备，瞄准，瞄准，瞄准，瞄准：这是最慢的软件开发方法。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编程是10%的科学，20%天份，和70%的让这天份符合科学。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;评估一个事情要比去理解你评估了什么容易。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测评不会撒谎，但测评的人会。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;培养员工，即使他们有跳槽的风险。什么都不做而留他们在公司，这样风险更大。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算机科学的目标是做出一个东西，并且保证它至少能坚持到我们将它开发完成。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java之于JavaScript如同Car之于Carpet。 (Chris Heilmann)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;起初就把事情做对是完全没必要的。但最后要把事情做对是绝对必要的。(Andrew Hunt and David Thomas)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数组的起始索引应该从0开始还是从1开始？我的0.5的折中提议被他们未经认真考虑到拒绝了——我认为是这样的。(Stan Kelly-Bootle)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;程序必须是为了给人看而写，给机器去执行只是附带任务。 (Abelson / Sussman)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编程可以很有趣，你可以用它做密码学研究，但两者绝对不能合二为一。(Kreitzberg and Shneiderman)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拷贝-粘贴是一种设计错误。(David Parnas)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算机善于遵循指令，但不善于理解你的思维。(Donald Knuth)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;软件纠错语录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;删除的代码是没有bug的代码。(Jeff Sickel)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果纠错是消除软件bug的过程，那编程一定是把它们放进去的过程。(Edsger Dijkstra)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码纠错要比新编写代码困难一倍。因为，如果你写出了最聪明的代码，按此推算，你将没有更大的智慧来debug它。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;想在自己的代码里找出一个错误是十分困难的。而当你认为你的代码没有错误时，那就更难了。(Steve McConnel)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;软件bug语录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;这不是个bug——这一个未注明的功能特征。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有需求或设计，编程就是一种将bug添加到一个空文本文件里的艺术。(Louis Srygley)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;烂代码并不烂，只是被误解了。(Anonymous Code Behaviorist)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有两种方法能写出没有错误的程序；但只有第三种好用。(Alan J. Perlis)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小心上面代码中的bug；我只知道这些代码是正确的，但没有试过。(Donald Knuth)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;软件产品/成品语录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;软件能够复用前，它必须要可用。(Ralph Johnson)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件通常在beta测试完成不久后发布。Beta在拉丁语中是“还不能用”的意思。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最好的性能改进是将软件从不能用的状态变成可用。(J. Osterhout)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最廉价、最快速、最可信赖的组件是那些还未出现的组件。(Gordon Bell)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I think Microsoft named .Net so it wouldn’t show up in a Unix directory listing. (Oktal)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件和教堂非常相似——建成之后我们就在祈祷。(Sam Redwine)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;除非最后一个用户死掉，软件是不会有完工的时候的。(Anonymous)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如今的大部分软件都非常像埃及金字塔，由成千上万的石块一个摞一个构成，没有结构上的集成，是由暴力强制和成千上万的奴隶完成。(Alan Kay)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;摘自网上&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>Android数据库和Bean的交互</title>
        <link>http://www.liuschen.com/2016/04/29/sqlite.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/04/29/sqlite.html</guid>
        <pubDate>Fri, 29 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Android中数据库使用的轻量级的Sqlite数据库，创建数据库的过程，因为系统都封装好了，所以比较简单。只要继承SQLiteOpenHelper即可。然后再写一些增删改查的函数就可以了。&lt;/p&gt;

&lt;p&gt;Android系统对数据的操作，就我的理解，主要是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;网络请求-内存(数据模型)-本地存储
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 JSON数据-本地Bean对象-数据库 则是其中一种通用的路子。&lt;br /&gt;
json到Bean对象以及Bean和数据库的交互转化，虽然可以针对每一种数据模型来实现，但是那样做未免太麻烦，同时也会浪费太多不必要的精力。&lt;br /&gt;
fastjson（阿里工程师开发的）和GSON(谷歌带的)就是很好的实现了json和Bean转化的框架，里面都是用的反射来实现的，其实也只能用反射，只不过牛逼的框架一般做的都很全，在性能上也处理的比较的当，我等也能佩服。&lt;/p&gt;

&lt;p&gt;当然我现在要说的是数据库和Bean的交互，因为时间比较匆忙，也没精力找别人写好的框架用，所以自己就简单的写了个。&lt;/p&gt;

&lt;p&gt;用到了反射，但是因为数据库中的字段名称和我自己的命名习惯不符(数据库字段名是已经定好的),所以便退而求其次，用了注解。首先，定义了一个注解:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DBDataType {
    /**为数据库中的信息，type=0时表示该为主键，-1为默认值，1,2,3,4为预留值，普通值请从5起，
     * 并且表示了该列值在数据库中的添加顺序*/
    int type() default -1;

    /**数据库中的元素名*/
    String elementName() default &quot;&quot;;
    /**数据库中的元素类型*/
    String elementType() default &quot;text&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着在建立的Bean对象中，对每一个field添加注解:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@DBDataType(type = 0, elementName = &quot;ID&quot;)
public String id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中type是字段在数据库建表时的排列顺序，从5开始，0时表示该字段定义为主键，1，2，3，4为预留值，elementName表示该值在表中的字段名，其实还有一个elementType表示字段的属性，默认是文本类型，其他可以指定&lt;/p&gt;

&lt;p&gt;然后就是关键代码，对sql语句进行拼接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {

		/**通过反射获取局部变量*/
		Field[] fields = clazz.getDeclaredFields();
		/**存储列的序号*/
		int[] cloumns = new int[fields.length];
		HashMap&amp;lt;Integer,DBDataType&amp;gt; hashMap = new HashMap&amp;lt;Integer,DBDataType&amp;gt;();
		/**建立序号到每个field对应的注解DBDataType映射关系*/
		for (int i=0;i&amp;lt;fields.length;i++){
			DBDataType dbDataTypes = fields[i].getAnnotation(DBDataType.class);
			int cloumnNumber = dbDataTypes.type();
			cloumns[i] = cloumnNumber;
			hashMap.put(cloumnNumber,dbDataTypes);
		}
		/**
		 * 对序号进行排序
		 * */
		Arrays.sort(cloumns);

		/**开始拼接sql语句*/
		String sqlfont = &quot;create table if not exists &quot; + tableName + &quot; (&quot;;
		String sqlContent = &quot;&quot;;
		String sqlOver = &quot;)&quot;;

		for(int i=0;i&amp;lt;cloumns.length;i++){

			String elementType = hashMap.get(cloumns[i]).elementType();
			String elementName = hashMap.get(cloumns[i]).elementName();

			if(cloumns[i]==0){
				//该值为主键
				sqlContent += elementName + &quot; &quot; + elementType + &quot; primary key&quot; +&quot;,&quot;;
			}else{
				sqlContent += elementName + &quot; &quot; + elementType +((i==cloumns.length-1)?&quot;&quot;:&quot;,&quot;);
			}

		}
		String sql = sqlfont + sqlContent + sqlOver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里传入的clazz为一个Bean对象，就是通过对field进行注解标记的Bean，这些代码是封装到数据库操作类中的，所以之后创建表，只需要传入一个Bean对象即可。对数据库的插入，查询也是，只需用注解和反射去写好一个通用的方法即可。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>荒原日记-习惯</title>
        <link>http://www.liuschen.com/2016/04/25/wildernessdiary-habby.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/04/25/wildernessdiary-habby.html</guid>
        <pubDate>Mon, 25 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;站在现在的角度看过去的自己，不得不说，我，是一个奇怪的小孩。&lt;/p&gt;

&lt;p&gt;“这是一个美丽的世界，关闭。”也许你会好奇我说的这句话的意义，但是正如我所说，我以前是一个很奇怪的孩子，而这句话就是我常常在心中念叨的一句咒语。它的功用在于它能帮我清除心中的杂念，当然，如果杂念太多那我就还需要点时间好好捋捋。你可能会说，你看，这孩子把自己当机器了，还要关机开机呢。当不当机器不好说，不过强迫症肯定是有的，这个习惯不知道是从什么时候开始的，我也不清楚是从什么时候结束的。我总是强迫自己尽善尽美的处理遇到的任何事情，所以在此期间没丢过东西也没遗忘过什么。像提前设定的程序，日子平平淡淡，却也无味至极，甚至对我来说，知道别人不会这样做，而对这种习惯和未来联系到的日子充满恐惧。&lt;/p&gt;

&lt;p&gt;后来证明，这种担心多余了，甚至现在的我竟然搞不清，我舍弃掉的这个习惯是否一并带走了我更重要的东西。我试着和过去划清界限，并不是要证明我的进步或是堕落，只是我想，该静下心好好重新的认识一下自己了，不是自我剖析，而是以朋友的身份~&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>荒原日记-开篇</title>
        <link>http://www.liuschen.com/2016/04/16/wildernessdiary-start.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/04/16/wildernessdiary-start.html</guid>
        <pubDate>Sat, 16 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;我从哪里来，又往哪里去？在我7，8岁的时候，常常在考虑这个问题，因为小，不理解前路漫长，总是觉得人生不过弹指岁月，所以总是充满了对死亡的恐惧。&lt;/p&gt;

&lt;p&gt;都说时间能抚平一切，当我将藏在幼小心中的想法封印，企图在时间之海中将它沉溺，缓缓流逝的时间却告诉我，它可以使炽烈的热恋冷却，将绝对冰点的感情消融，却无法使我遗忘自己追问本源的这种淡淡的想法。&lt;/p&gt;

&lt;p&gt;慢慢的，我也逐渐找到了自己的答案，也许每个人来到世上都是为了寻找到这一个答案，只是或许有些人不愿意分享，在喧闹的城市抑或宁静的乡村，只有当你在午夜，万物沉寂，而你独自一人时才会有机会偶然想起你此刻立于此地的意义。我们每个人都有一个答案，只是有些人一生可能都不会想起。幸运抑或不幸，只是人对自己过往的追问和总结罢了。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Visual Studio开发Android程序</title>
        <link>http://www.liuschen.com/2016/02/21/studio.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/21/studio.html</guid>
        <pubDate>Sun, 21 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;早就听说微软在新版的visual studio上增强了对移动开发的便利，而且提供的Android模拟器比Google提供的性能上要好很多，所以周末就弄了一下，简单说一下遇到的问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;visual-studio-2015&quot;&gt;1.安装Visual Studio 2015&lt;/h1&gt;

&lt;p&gt;安装Visual Studio 2015时，要联网下载很多东西，虽然安装包已经不小了，很显然，安装的要更多。装了近10个小时（只能说我够闲），完了后仍然提示我说android 的sdk和一个git相关的什么东西没装上，最重要的是sdk没装上肯定就不能开发Android了，下载是不现实的，所以就用了我本地存放的sdk,更改sdk路径的设置需要依次点击&lt;/p&gt;

&lt;h3 id=&quot;cross-platform&quot;&gt;工具-选项-Cross Platform&lt;/h3&gt;

&lt;p&gt;就能看到，然后勾选Android SDK前面的选择框就可以更改路径了。&lt;/p&gt;

&lt;p&gt;调试Android程序，如果是真机调试一般选ARM，连接上手机开发者一般就能看到设备了，如果是window的虚拟机则是选x86。&lt;/p&gt;

&lt;h1 id=&quot;window&quot;&gt;2.安装window的虚拟机&lt;/h1&gt;

&lt;p&gt;安装window提供的Android虚拟机需要window对Hyper-V的支持，这个功能家庭版上没有，至少要专业版才行，然后再控制面板中打开该功能，电脑在此期间会重启来完成功能的添加。之后就能安装虚拟机了，如果没有添加该功能直接安装会出错，安装虚拟机要升级到最新版本，安装完后就能使用了。&lt;/p&gt;

&lt;p&gt;window提供的Android虚拟机的基础Hyper-V感觉和workstation以及virtualbox差不多，但是毕竟是在window系统自家提供的功能，相必必有一些过人的地方，只是Android的模拟器虽然速度比Google自己的要快很多，但是总有些似曾相识的感觉，之前用sdk自带的虚拟机，在window上其实也是可以加速的，也就是单独针对x86架构有加速的独立window程序可以安装，和这个差不多，都是针对同一种架构的优化，从这个意义上来讲，其实这个虚拟机对我做开发意义并不是太大。&lt;/p&gt;

&lt;h1 id=&quot;visual-studio-2015-1&quot;&gt;3.Visual Studio 2015编程&lt;/h1&gt;

&lt;p&gt;我最期待的是Visual Studio 2015用c++来架构程序的效果，新建工程时,我发现没有Java构建代码的模板，好像在这里面C#是Java的等效语言，除此之外就是Visual c++，在里面的跨平台中还是找到了一个模板可以构建Java的Android程序，同时也可以建c++共享库，也有纯c++来开发Android的模板，遗憾的是，我看过之后发现这个模板是完全照抄的NDK中的示例源码，可见这并不是visualstudio的主要功能。其中也有Apache Cordova的模板，用网页前端语言构建app的框架，这个可以使代码可以轻松的跨平台，在节省开发成本上具有广泛意义，但传统的仍然认为这种方式在运行速度上仍不理想，所以现在还是以Java+html5混合编程为主。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>C++学习整理</title>
        <link>http://www.liuschen.com/2016/02/19/c++.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/19/c++.html</guid>
        <pubDate>Fri, 19 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;打印字符串&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
extern int pow(int, int);
int main()
{
	int val = 2;
	int exp = 15;
	cout &amp;lt;&amp;lt; &quot;The Powers of 2\n&quot;;
	for ( int cnt=0; cnt &amp;lt;= exp; ++cnt )
	cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &quot;: &quot;
	&amp;lt;&amp;lt; pow(val, cnt) &amp;lt;&amp;lt; endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;inline&quot;&gt;内联函数inline,最好放在头文件中&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;inline int min( int v1, int v2 ) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;extern-c&quot;&gt;链接指示符 extern “c”,告诉编译器函数编写语言类型&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// 单一语句形式的链接指示符
extern &quot;C&quot; void exit(int);
// 复合语句形式的链接指示符
extern &quot;C&quot; {
int printf( const char* ... );
int scanf( const char* ... );
}
// 复合语句形式的链接指示符
extern &quot;C&quot; {
	#include &amp;lt;cmath&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链接指示符不能出现在函数体中，并且如果需要c调用c++程序也需要在前面生命链接指示符,链接指示符如果声明多次，可以只声明一次，自动作用于后面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ---- myMath.h ----
extern &quot;C&quot; double calc( double );
// ---- myMath.C ----
// 在 Math.h 中的calc() 的声明
#include &quot;myMath.h&quot;
// 定义了 extern &quot;C&quot; calc() 函数
// calc() 可以从C 程序中被调用
double calc( double dparm ) { // ...
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Socket编程笔记</title>
        <link>http://www.liuschen.com/2016/02/17/socket.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/17/socket.html</guid>
        <pubDate>Wed, 17 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;android中的socket连接HttpURLConnection来实现的。而HttpClient是对HttpURLConnection做了一层封装，HttpClient6.0之后被废弃了,推荐用HttpURLConnection。而HttpURLConnection继承于HttpConnection，两者都是抽象类，想了解其中的实现原理，就要深入的剖析一下代码，但是其中一些关键的方法如connect()方法却是抽象的，所以需要找到它的实现类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，是找到connect()的实现，最可能的是在URL类中找线索，因为是在url中获取的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;URL url = new URL(httpUrl);//此处有异常抛出
HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，URL中却显示streamHandler中取得的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public URLConnection openConnection() throws IOException {
    return streamHandler.openConnection(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而streamHandler这个实例所属的对象实现的方法仍然是抽象的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected abstract URLConnection openConnection(URL u) throws IOException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说单独知道这个出处还不够，还需要知道streamHandler是在什么时候被赋值的，这时候可以注意到URL中有URLStreamHandlerFactory streamHandlerFactory的工厂声明，点击去发现还是抽象的(晕)，然后顺着streamHandlerFactory就找到了下面的方法，是对streamHandler赋值的关键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; void setupStreamHandler() {
    // Check for a cached (previously looked up) handler for
    // the requested protocol.
    streamHandler = streamHandlers.get(protocol);
    if (streamHandler != null) {
        return;
    }

    // If there is a stream handler factory, then attempt to
    // use it to create the handler.
    if (streamHandlerFactory != null) {
        streamHandler = streamHandlerFactory.createURLStreamHandler(protocol);
        if (streamHandler != null) {
            streamHandlers.put(protocol, streamHandler);
            return;
        }
    }

    // Check if there is a list of packages which can provide handlers.
    // If so, then walk this list looking for an applicable one.
    String packageList = System.getProperty(&quot;java.protocol.handler.pkgs&quot;);
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    if (packageList != null &amp;amp;&amp;amp; contextClassLoader != null) {
        for (String packageName : packageList.split(&quot;\\|&quot;)) {
            String className = packageName + &quot;.&quot; + protocol + &quot;.Handler&quot;;
            try {
                Class&amp;lt;?&amp;gt; c = contextClassLoader.loadClass(className);
                streamHandler = (URLStreamHandler) c.newInstance();
                if (streamHandler != null) {
                    streamHandlers.put(protocol, streamHandler);
                }
                return;
            } catch (IllegalAccessException ignored) {
            } catch (InstantiationException ignored) {
            } catch (ClassNotFoundException ignored) {
            }
        }
    }

    // Fall back to a built-in stream handler if the user didn&#39;t supply one
    if (protocol.equals(&quot;file&quot;)) {
        streamHandler = new FileHandler();
    } else if (protocol.equals(&quot;ftp&quot;)) {
        streamHandler = new FtpHandler();
    } else if (protocol.equals(&quot;http&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;https&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpsHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;jar&quot;)) {
        streamHandler = new JarHandler();
    }
    if (streamHandler != null) {
        streamHandlers.put(protocol, streamHandler);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看注释区分，总共分为4个部分&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;第一部分&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt; streamHandler = streamHandlers.get(protocol);
    if (streamHandler != null) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是取缓存的streamHandler实例，如果已经存在了，就不会往下执行了。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;第二部分&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;if (streamHandlerFactory != null) {
        streamHandler = streamHandlerFactory.createURLStreamHandler(protocol);
        if (streamHandler != null) {
            streamHandlers.put(protocol, streamHandler);
            return;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明显用到了工厂，所以需要知道工厂的出处，是这里:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Sets the stream handler factory for this VM.
 *
 * @throws Error if a URLStreamHandlerFactory has already been installed
 *     for the current VM.
 */
public static synchronized void setURLStreamHandlerFactory(URLStreamHandlerFactory factory) {
    if (streamHandlerFactory != null) {
        throw new Error(&quot;Factory already set&quot;);
    }
    streamHandlers.clear();
    streamHandlerFactory = factory;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得了，这个是公共的设置方法:Sets the stream handler factory for this VM顿时感觉好高大上，总之，不通。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;第三部分&lt;/h1&gt;

&lt;p&gt;在系统属性指定的包中寻找相应的URLStreamHandler处理类，因为没怎么用过这种方法，值得注意，不过不是这里的重点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String packageList = System.getProperty(&quot;java.protocol.handler.pkgs&quot;);
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    if (packageList != null &amp;amp;&amp;amp; contextClassLoader != null) {
        for (String packageName : packageList.split(&quot;\\|&quot;)) {
            String className = packageName + &quot;.&quot; + protocol + &quot;.Handler&quot;;
            try {
                Class&amp;lt;?&amp;gt; c = contextClassLoader.loadClass(className);
                streamHandler = (URLStreamHandler) c.newInstance();
                if (streamHandler != null) {
                    streamHandlers.put(protocol, streamHandler);
                }
                return;
            } catch (IllegalAccessException ignored) {
            } catch (InstantiationException ignored) {
            } catch (ClassNotFoundException ignored) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-3&quot;&gt;第四部分&lt;/h1&gt;

&lt;p&gt;再不成只能做最后的挣扎了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (protocol.equals(&quot;file&quot;)) {
        streamHandler = new FileHandler();
    } else if (protocol.equals(&quot;ftp&quot;)) {
        streamHandler = new FtpHandler();
    } else if (protocol.equals(&quot;http&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;https&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpsHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;jar&quot;)) {
        streamHandler = new JarHandler();
    }
    if (streamHandler != null) {
        streamHandlers.put(protocol, streamHandler);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中https依然是在特定包com.android.okhttp.HttpsHandler中找&lt;br /&gt;
而其他的则是直接new一个对象，这些对象的导入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import libcore.net.url.FileHandler;
import libcore.net.url.FtpHandler;
import libcore.net.url.JarHandler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在androidstudio中显示的是灰色的，表示没有没有提供相关源码，至此，线索全断了，不过通过这些查找也并非没有收获。&lt;/p&gt;

&lt;p&gt;一直以来找的URLStreamHandler streamHandler其实是一个协议流处理器，每一个&lt;br /&gt;
对应一个URLHttpConnection，至于实现它们的源码，限于sdk中源码包没有所以没看到，不过却找到了出处，网上查了一下知道了其中实现也是通过Socket，大体的关系总是理清了。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;总结：&lt;/h1&gt;

&lt;p&gt;1.URLHttpConnection和URLHttpsConnection都继承了URLConnection都是基于应用层对http或https协议的封装，里面通信还是用的socket&lt;/p&gt;

&lt;p&gt;2.URLConnection里面调用的Socket是传输层对应用层提供的抽象接口,是下层黑箱的一个门面，其中包括的协议有传输层的TCP协议和UDP协议，以及网络层的IP协议。当然也可以直接用socket通信，可以在应用层通过socket来架构网络框架，但是需要考虑多线程，以及状态监控（其实用URLConnection也要自己写多线程）等因素，更省流量以及更可控，但是如果要用到http等应用层协议，还是用URLConnection方便些。&lt;/p&gt;

&lt;p&gt;3.每个URLConnection都有一个相对应的URLStreamHandler实例用来处理协议，URL类中还有关于file，ftp,jar对应类型的URLStreamHandler应该也是一些协议的封装的处理器，也就是说每一种协议需要对应一种处理模型。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;最后，温习一下网络模型：&lt;/h1&gt;

&lt;h2 id=&quot;section-6&quot;&gt;应用层-应用层，表示层，会话层&lt;/h2&gt;

&lt;h2 id=&quot;section-7&quot;&gt;传输层-传输层&lt;/h2&gt;

&lt;h2 id=&quot;section-8&quot;&gt;网际互联层-网络层&lt;/h2&gt;

&lt;h2 id=&quot;section-9&quot;&gt;网络接入层-数据链路层，物理层&lt;/h2&gt;

</description>
      </item>
    
      <item>
        <title>git常用命令行</title>
        <link>http://www.liuschen.com/2016/02/16/apk.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/16/apk.html</guid>
        <pubDate>Tue, 16 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;首先将git目录下的cmd配置到环境变量，打开cmd就可以使用git命令，git仓库就是目录下隐藏的.git文件夹&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.bootcss.com/p/git-guide/&quot;&gt;git简易使用说明(外链)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;创建版本库&lt;br /&gt;
git init&lt;/p&gt;

&lt;p&gt;查看分支&lt;br /&gt;
git branch&lt;br /&gt;
git branch -a&lt;/p&gt;

&lt;p&gt;从远端拉取&lt;br /&gt;
git clone 地址&lt;/p&gt;

&lt;p&gt;显示状态&lt;br /&gt;
git status&lt;/p&gt;

&lt;p&gt;修改加入缓存&lt;br /&gt;
git add filename&lt;/p&gt;

&lt;p&gt;修改提交到HEAD(本地库最近版本)&lt;br /&gt;
git commit -m “提交注释内容”&lt;/p&gt;

&lt;p&gt;创建分支并切换  单独切换分支 删除本地分支&lt;br /&gt;
git checkout -b name&lt;br /&gt;
git checkout name&lt;/p&gt;

&lt;p&gt;还没提交到远端的分支可以直接删除&lt;br /&gt;
git branch -d name&lt;/p&gt;

&lt;p&gt;更新不需要密码&lt;br /&gt;
git pull&lt;br /&gt;
提交到远端库&lt;br /&gt;
git push&lt;/p&gt;

&lt;p&gt;本地有一个远端的拷贝，和远端同步&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>android反编译</title>
        <link>http://www.liuschen.com/2016/02/14/apk.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/14/apk.html</guid>
        <pubDate>Sun, 14 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;android程序是apk格式，其实就是一个压缩包，可以直接解压，但是直接解压后可以直接得到资源文件，以及c的动态链接库，但是打开布局文件却是乱码，并且没有的到直接可读的java源码，所以需要用到反编译相关的软件，而android逆向助手就是一个整合了多个反编译工具的软件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog-apk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，反编译apk和反编译dex直接提取的都是smali格式的文件&lt;/p&gt;

&lt;h3 id=&quot;androidjava&quot;&gt;获得android程序源码中java格式的源码：&lt;/h3&gt;
&lt;p&gt;通过dex转成jar格式   通过js-gui可以直接读取其中的内容，如果里面代码经过了混淆，则被混淆过的代码名称均用无意义的英文字母来命名，因为更改了名称，所以该部分代码不能用到反射。&lt;/p&gt;

&lt;h3 id=&quot;androidxml&quot;&gt;获得android程序源码中的xml文件：&lt;/h3&gt;

&lt;p&gt;反编译apk中就能获得xml文件用的APKTool工具&lt;br /&gt;
没有说明出错了, apktool.jar版本没更，跟不上android的版本&lt;br /&gt;
直接替换反编译却又不能出结果&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;结果：&lt;/h3&gt;

&lt;p&gt;直接用里面的apktool d 文件 来解析xml文件&lt;br /&gt;
用完整工具可以解析src中的Java文件&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>html5内嵌入android</title>
        <link>http://www.liuschen.com/2016/02/05/html5-2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/05/html5-2.html</guid>
        <pubDate>Fri, 05 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;首先Android的目录中建立一个assets文件夹，将canvas.html文件放入其中，然后添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	WebView webview = (WebView) findViewById(R.id.wv);
    webview.getSettings().setJavaScriptEnabled(true);
    webview.setBackgroundColor(Color.TRANSPARENT);
    webview.loadUrl(&quot;file:///android_asset/canvas2.html&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地也需要加入权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以在就可以写一些js代码来嵌入Android应用，所以我又写了一个简单的loading用来做嵌入Android的测试：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog-web-html5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/luofengliuchen/AndroidWebTest&quot;&gt;Android测试Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;loading本来是想做的像玉器一样的，但是太耗费时间，所以配色上可能不太理想。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/loading.html&quot;&gt;loading动画网页预览&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>HTML5绘图学习记录</title>
        <link>http://www.liuschen.com/2016/02/04/html5-1.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/04/html5-1.html</guid>
        <pubDate>Thu, 04 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;首先先要导入jquery.min.js&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1.绘制矩形，线条，圆形&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//获取canvas对象
var canvas  = $(&quot;#mycanvas&quot;);
//的到2D context
var context = canvas.get(0).getContext(&quot;2d&quot;);

//矩形
context.fillStyle = &quot;rgb(255,0,0)&quot;;
context.strokeStyle = &quot;rgb(0,255,0)&quot;;
context.fillRect(40,40,100,100);
context.strokeRect(140,140,100,100);

//直线
context.beginPath();
context.moveTo(240,240);
context.lineTo(600,500);
context.closePath();
context.stroke();

//绘制圆形
context.beginPath();
context.arc(500,500,50,0,Math.PI/2,false);
context.lineTo(500,500);
context.closePath();
context.stroke();

//绘制字体
var text  = &quot;this is html5&quot;;
context.font = &quot;italic 30px serif&quot;;
context.fillText(text,40,300);	
context.lineWidth = 1;
context.strokeText(text,40,400);

//擦除操作
context.clearRect(200,200,100,100);

//擦除操作
context.clearRect(200,200,100,100);
//context.clearRect(0,0,canvas.width(),canvas.height());

//重置所有canvas上的元素
canvas.attr(&quot;width&quot;,canvas.width());
canvas.attr(&quot;height&quot;,canvas.height());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/canvas.html&quot;&gt;HTML5练习1&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.绘图状态的保存，画布变换，阴影，渐变和贝塞尔曲线&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;保存和应用就是一个对栈进行存取的操作，存的是画布的状态信息，如颜色，阴影，变换信息等等，先进后出，后进先出&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;context.save();
context.restore();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;变换，对画布的操作，只对之后绘制的图形产生影响，可以把画布当成有多个图层，每次绘制都会新开一个图层，而变换就是对之后新开图层产生影响，绘制目标完后可以对画布进行还原&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//平移
context.translate(100,100);
//缩放，注意缩放中心
context.scale(1,1.5);
//缩放，注意旋转中心
context.rotate(Math.PI/12);

//全局阿尔法值
context.globalAlpha = 0.5;
//合成模式，PS上的混合模式
context.globalCompositeOperation = &quot;xor&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;渐变的应用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//线性渐变
context.restore();
var gradient = context.createLinearGradient(0,0,0,canvas.height());
gradient.addColorStop(0,&quot;rgb(0,0,0)&quot;);
gradient.addColorStop(1,&quot;rgb(255,0,0)&quot;);
context.fillStyle = gradient;
context.fillRect(100,100,100,100);

//放射渐变
var canvasCentreX = canvas.width()/2;
var canvasCentreY = canvas.height()/2;
var gradient = context.createRadialGradient(canvasCentreX,canvasCentreY,0,canvasCentreX,canvasCentreY,250);
gradient.addColorStop(0,&quot;rgb(0,0,0)&quot;);
gradient.addColorStop(1,&quot;rgb(150,150,150)&quot;);
context.fillStyle = gradient;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;贝塞尔曲线&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//一阶贝塞尔曲线
context.lineWidth = 15;
context.beginPath();
context.moveTo(200,200);
context.quadraticCurveTo(350,200,450,450);
context.stroke();
//三阶贝塞尔曲线
context.lineWidth = 15;
context.beginPath();
context.moveTo(200,200);
context.bezierCurveTo(350,200,450,450,800,500);
context.stroke();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/canvas2.html&quot;&gt;HTML5练习2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;3.把绘制的图像导出，并应用到其他地方&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var dataURL = canvas.get(0).toDataURL();
var img = $(&quot;&amp;lt;img&amp;gt;&amp;lt;/img&amp;gt;&quot;);
img.attr(&quot;src&quot;,dataURL);
canvas.replaceWith(img);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/canvas3.html&quot;&gt;HTML5练习3&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;4.对图片进行处理&lt;/h2&gt;

&lt;p&gt;在画布上绘制图片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var image = new Image();
image.src = &quot;example.jpg&quot;;
$(image).load(function(e) {
	//显示图像
    context.drawImage(image,0,0);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;对图片进行处理，可以对每个像素点进行操作，图片大的话，不推荐&lt;/h3&gt;

&lt;h3 id=&quot;section-7&quot;&gt;对图片马赛克化，风格化处理，是将图片分割，每个格子取一个像素点，用该颜色画一个图形取代原来的格子&lt;/h3&gt;

&lt;h3 id=&quot;section-8&quot;&gt;对图片作灰度处理是将图片每一个像素点，取通道均值赋给各个通道&lt;/h3&gt;

&lt;h3 id=&quot;section-9&quot;&gt;对图片反相是将各个通道值被255减之后赋回给各个通道&lt;/h3&gt;

&lt;h3 id=&quot;section-10&quot;&gt;之前的模糊算法是将每个像素点和周边像素点的值做正态分布加权平均然后再赋回给该像素点，做的运算更复杂&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/drawpicture.html&quot;&gt;HTML5练习4&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;5.动画&lt;/h2&gt;

&lt;h3 id=&quot;section-12&quot;&gt;加一个定时器，然后对画布进行绘制-擦除-绘制循环就是动画&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/anim.html&quot;&gt;HTML5练习5&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>HTML5绘图学习</title>
        <link>http://www.liuschen.com/2016/02/03/html5.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/03/html5.html</guid>
        <pubDate>Wed, 03 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;这几天花了点儿时间了解了下HTML5，为现有的工作拓宽一下思路，都说HTML5如何强大，之前只是听说，并没有太多的体会。用后才发现的确没有夸张，众所周知，过去网页上要想播放视频都是需要有flash插件的支持的，而flash插件则是由Adobe公司提供的，Adobe公司在图形图像处理方面表现出众，过去一直很关注它的几款产品的更新。一两年时间没注意，才发现Adobe竟然已经停止产品的迭代，转主要做服务了。而HTML5出来也很长时间了，我也是才深入的体会到它的强大，毕竟它取代了在网页上长久以来占据核心地位的flash。&lt;/p&gt;

&lt;p&gt;而对于我，主要发现有3点便利的地方:&lt;/p&gt;

&lt;p&gt;1.html5绘图后可以直接保存成为图片，好方便；&lt;/p&gt;

&lt;p&gt;2.html5绘图API的原理同android绘图一样，很多地方共通；&lt;/p&gt;

&lt;p&gt;3.html5可以对图片做处理，可以对视频做处理，可以做动画，可以写游戏，而不需要另加插件，大大提升了网页的拓展性；&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>想要冬眠的狐狸</title>
        <link>http://www.liuschen.com/2016/01/31/fox3.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/31/fox3.html</guid>
        <pubDate>Sun, 31 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;有人说它在笑，你说呢&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>擅长卖萌的狐狸</title>
        <link>http://www.liuschen.com/2016/01/31/fox2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/31/fox2.html</guid>
        <pubDate>Sun, 31 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;萌神小白狐，其实有两只，一只在前台接客（卖萌），另一只嘛，在后台装石头（睡觉），对，就是后面白色的那个大鹅卵石。&lt;/p&gt;

  &lt;p&gt;看见了没！它狐狸尾巴渐渐露出来了。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyj.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyl.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greym.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyo.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyr.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greys.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyt.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyw.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>正在找东西的狐狸</title>
        <link>http://www.liuschen.com/2016/01/31/fox1.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/31/fox1.html</guid>
        <pubDate>Sun, 31 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;如果不是在动物园看到的，我还以为这货是狗呢，扒洞贼溜。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>梦花</title>
        <link>http://www.liuschen.com/2016/01/27/dream-flower.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/27/dream-flower.html</guid>
        <pubDate>Wed, 27 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;想写些小说,但是老实说,写出来老是缺少画面感,并且多半时候今天写了，明天就会看得不顺，所以作罢了好多次，但是如果一直不写，也就谈不上进步。所有权当练习表达了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;初生一觉醒来，发现自己正坐在大巴里，大巴没动，看着正在陆续上来找座位的同学，初生明白了自己还没走，是要去哪里，一时之间却始终想不起来。&lt;/p&gt;

&lt;p&gt;现在好像正值仲夏，烈日当空，蝉声的嘶鸣催动的空气中的燥热，在四处恣意的流动，弯曲了光线，仿佛用肉眼就能看到空气中那细小的流苏，灼人肌肤，燥人心房。&lt;/p&gt;

&lt;p&gt;初生想不起来自己是要去哪里，回家？亦或是离去，游玩？也可能是逃离。&lt;/p&gt;

&lt;p&gt;初生又打了个盹儿，梦里他看到一片圆形的雨云突然遮蔽了天空，四周顿时变得阴暗。初生来不及思考，只是见那雨云越来越厚，四周的空气也变的厚重起来，令他喘不过气。如果说此时的他的痛苦能够让他忘记思考，那么接下来他看到的也足以令他忘记这种苦痛的了，周遭的空气变得越发的重，突然，不可思议的事情发生了，初生隔着窗子外的建筑开始发生变化，掉落的砖瓦开始，重新砌好，因为年久剥落的涂料开始一点点的重新回到墙上，渐渐的，整个建筑焕然一新，只是这个过程却丝毫没有半分减缓的迹象，却仿佛更快了，建筑逐渐低矮，最后全部变成了堆积在一旁的砖瓦。又是一栋建筑在飞散的灰尘中瞬间立起，由旧变新，最后变化的速度太快，以至于仿佛本来是电影被点了快进一般却突然被人索性拖着进度条直溜的就朝尾声奔去了。&lt;/p&gt;

&lt;p&gt;初生隐隐约约明白了发生了什么。他睁开眼，大脑柔乎了一阵儿，仔细的观察了一下四周，一个激灵上来，瞬间清醒了好多，才明白眼前发生的不是梦。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实就是我昨天做的梦，因为梦里很玄妙的样子，印象很深，不是有妙笔生花一说吗？这可以叫妙梦生花，故曰:梦花。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>我对瀑布开发模式和敏捷开发模式的理解</title>
        <link>http://www.liuschen.com/2016/01/27/project-mode.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/27/project-mode.html</guid>
        <pubDate>Wed, 27 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;瀑布开发模式就是一种最常用的开发模型，因为这种开发方式不但简单直观而且大大便利了项目管理的运作。 瀑布开发模式可以令项目管理人员非常方便地把整个项目置于自己的掌握之下。瀑布开发模式限制了开发期间团队间的交互，评估起来相当方便，由于开发计划稳定而且几乎不会发生经常性的变化从而有效地简化了项目开发的管理工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;敏捷开发则是多种软件开发项目管理方法的集合，其中包括了XP、Scrum等十几种开发模式，这些开发方法有些共同点，比如重视响应变更，重视实现客户的价值，重视开发人员的自身发展等等，核心原则是主张简单，拥抱变化，快速反馈并注重开发的目的性，轻装前行，高质量的工作，使投资最大化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;严格瀑布开发模式，各个环节会依次有条不紊的进行，开发的生命周期时间上往往很好把控，所以它的优点是易于管理和掌控进度。但是因为开发的效果只有在项目完成后才能看到，对用户的反馈往往会滞后，并且如果项目前面环节没有做的很好，到了项目后期这种问题就会被指数性的放大，甚至到达bug的层面。各个开发团队之前缺乏交流也会是整个项目效率低下的一个原因。&lt;/p&gt;

&lt;p&gt;这种开发模式很受传统行业公司的青睐，原因大概就是这种管理模式符合传统项目的美学，严谨，规范，对时间的绝对把握，但是我个人却认为这种美学却不大符合互联网的思维。&lt;/p&gt;

&lt;p&gt;敏捷开发则是瀑布开发模式在互联网思维的进化，说是进化也许有些不妥，因为瀑布开发模式重在管理，易于驾驭，而敏捷开发，则是剥离了管理的外壳，把精力完全放在了个人，产品，和客户需求这个最重要的3个要素之上，并不好驾驭，如果你要管理整个项目，就必须要参与其中，并且具有指导其他成员的能力。&lt;/p&gt;

</description>
      </item>
    
  </channel>
</rss>