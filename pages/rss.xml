<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>落风的博客</title>
    <link>http://www.liuschen.com</link>
    <description>落风的博客</description>
    
      <item>
        <title>混淆点义</title>
        <link>http://www.liuschen.com/2017/10/07/point2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/10/07/point2.html</guid>
        <pubDate>Sat, 07 Oct 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;not-found&quot;&gt;1.NOT FOUND&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;java.lang.NoClassDefFoundError是运行阶段无法加载到类&lt;/p&gt;

  &lt;p&gt;java.lang.ClassNotfoundException是编译阶段无法找到类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;2.代理模式和装饰模式&lt;/h2&gt;

&lt;p&gt;代码类似，都是两个类实现同一个接口，一个类实际功能操作，传给另一个作为代理或是装饰的类；&lt;/p&gt;

&lt;p&gt;功能不同，装饰旨在增加功能（不妨碍直接访问功能类的方法），代理则重在控制访问（会在访问功能类的方法中添加访问规则）&lt;/p&gt;

&lt;h2 id=&quot;jdk&quot;&gt;3.JDK动态代理:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;定义代理对象接口以及代理对象实现&lt;/p&gt;

    &lt;p&gt;如：UserService userService = new UserServiceImpl();&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实现InvocationHandler接口，将代理对象传入(其中Invoke方法可以实现代理功能//通过反射)&lt;/p&gt;

    &lt;p&gt;如：MyInvocationHandler invocationHandler = new MyInvocationHandler(userService);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据目标对象生成代理对象(classLoader只要选对就行，加载普通类用的同一种classLoader)&lt;/p&gt;

    &lt;p&gt;如：UserService proxy = (UserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(),  &lt;br /&gt;
              userService.getClass().getInterfaces(), invocationHandler);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据需要调用代理对象的方法&lt;/p&gt;

    &lt;p&gt;如：proxy.getXXX()&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CGLib代理(针对目标类没有实现目标接口的代理):&lt;/p&gt;

&lt;p&gt;动态生成子类，需要外部包，适合不频繁创建类的代理&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>oracle数据库入门</title>
        <link>http://www.liuschen.com/2017/09/27/GoogleMap.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/09/27/GoogleMap.html</guid>
        <pubDate>Wed, 27 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;oracle&quot;&gt;安装Oracle数据库&lt;/h2&gt;

&lt;p&gt;访问安装的Oracle数据库：&lt;/p&gt;

&lt;p&gt;1.https://localhost:1158/em&lt;/p&gt;

&lt;p&gt;2.命令行输入sqlplus&lt;/p&gt;

&lt;h2 id=&quot;oracle-1&quot;&gt;oracle数据库服务&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Oracle ORCL VSS Writer Service：Oracle卷映射拷贝写入服务，VSS（Volume Shadow Copy Service）能够让存储基础设备（比如磁盘，阵列等）创建高保真的时间点映像，即映射拷贝（shadow copy）。它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统的系统能。（非必须启动）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OracleDBConsoleorcl：Oracle数据库控制台服务，orcl是Oracle的实例标识，默认的实例为orcl。在运行Enterprise Manager（企业管理器OEM）的时候，需要启动这个服务。（非必须启动）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OracleJobSchedulerORCL：Oracle作业调度（定时器）服务，ORCL是Oracle实例标识。（非必须启动）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OracleMTSRecoveryService：服务端控制。该服务允许数据库充当一个微软事务服务器MTS、COM/COM+对象和分布式环境下的事务的资源管理器。（非必须启动)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OracleOraDb11g_home1ClrAgent：Oracle数据库.NET扩展服务的一部分。 （非必须启动）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OracleOraDb11g_home1TNSListener：监听器服务，服务只有在数据库需要远程访问的时候才需要。（非必须启动）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OracleServiceORCL：数据库服务(数据库实例)，是Oracle核心服务该服务，是数据库启动的基础， 只有该服务启动，Oracle数据库才能正常启动。(必须启动)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只用Oracle自带的sql*plus的话，只要启动OracleServiceORCL即可，要是使用PL/SQL Developer等第三方工具的话，OracleOraDb11g_home1TNSListener服务也要开启。OracleDBConsoleorcl是进入基于web的EM必须开启的，其余服务很少用。&lt;/p&gt;

&lt;h1 id=&quot;plsql&quot;&gt;PLSQL远程访问数据库&lt;/h1&gt;

&lt;p&gt;PLSQL Developer\instantclient_11_2下的文件tnsnames.ora配置数据库的访问地址&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;问题&lt;/h1&gt;

&lt;p&gt;如果通过浏览器访问不到数据库了，那么需要在服务管理器中（window）依次关闭，然后依次重启以下服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OracleOraDb11g_home1TNSListener
OracleDbConsoleorcl
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Google离线地图</title>
        <link>http://www.liuschen.com/2017/09/23/GoogleMap.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/09/23/GoogleMap.html</guid>
        <pubDate>Sat, 23 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;1.初始化地图&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;map = new google.maps.Map(document.getElementById(&#39;map&#39;), {
      center: {lat: -34.397, lng: 150.644},
      zoom: 8
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.还可以添加地图选项：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;map = new google.maps.Map(document.getElementById(&#39;map_canvas&#39;), mapOptions);
 var mapOptions = {
      zoom: 16,
      center: myLatlng,
	  mapTypeControl: true,
      mapTypeControlOptions: {
		  style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
		mapTypeIds: [
		&#39;localMap&#39; ]  //定义地图类型
	  },
	  //平移控制器
	  panControl: false,
	  //缩放控制器
	  zoomControl: false,
	  //地图切换
	  mapTypeControl: true,
	  scaleControl: false,
	  //街道视图控制（小人）
	  streetViewControl: false,
	  //鹰眼图
	  overviewMapControl: true
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3.绑定本地地图&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;map.mapTypes.set(&#39;localMap&#39;, localMapType);   //绑定本地地图类型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;localMapType是返回的瓦片，可以这样获取：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function LocalMapType() {}
  
    LocalMapType.prototype.tileSize = new google.maps.Size(256, 256);
    LocalMapType.prototype.maxZoom = 16;   //地图显示最大级别
    LocalMapType.prototype.name = &quot;本地地图&quot;;
    LocalMapType.prototype.alt = &quot;显示本地地图数据&quot;;
	//设置地图瓦片的边框和颜色，当前为不可见，因为width为0
    LocalMapType.prototype.getTile = function(coord, zoom, ownerDocument) {
		var div = ownerDocument.createElement(&#39;div&#39;);
		div.innerHTML = &#39;&amp;lt;img name=&quot;&quot; src=&quot;./maptile/googlemaps/roadmap/&#39; + zoom + &#39;/&#39; + coord.x + &#39;/&#39; + coord.y+&#39;.jpg&quot;/&amp;gt;&#39;; 
		div.style.width = this.tileSize.width + &#39;px&#39;;
		div.style.height = this.tileSize.height + &#39;px&#39;;
		div.style.fontSize = &#39;10&#39;;
		div.style.borderStyle = &#39;solid&#39;;
		div.style.borderWidth = &#39;0px&#39;;
		div.style.borderColor = &#39;#AAAAAA&#39;;
		//瓦片背景颜色
		div.style.backgroundColor = &#39;#E5E3DF&#39;;
	  return div;
    };
  var localMapType = new LocalMapType();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;5.基本的一个坐标点对象：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var myLatlng = new google.maps.LatLng(39.97094, 116.37234);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;6.指定显示本地地图&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;map.setMapTypeId(&#39;localMap&#39;);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;7.设置可拖曳地图：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;map.setOptions({draggable: true});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;8.获取地图边界：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mapRangeBound = map.getBounds();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;map&quot;&gt;9.map上添加事件，如下为点击事件：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;map.addListener(&#39;click&#39;, function(event) {})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mapdiv&quot;&gt;10.为map瓦块div添加点击事件：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;google.maps.event.addDomListener(mapDiv, &#39;click&#39;, function() {});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-7&quot;&gt;11.点击事件：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;google.maps.event.addListener
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;12.代码拖动地图：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;map.panTo(new google.maps.LatLng(39.97094, 116.37234));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;13.拖动地图事件：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;map.addListener(&#39;center_changed&#39;, function() {
      // 3 seconds after the center of the map has changed, pan back to the
      // marker.
      window.setTimeout(function() {
        map.panTo(marker.getPosition());
      }, 3000);
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;marker&quot;&gt;14.点击marker改变地图显示等级和中心：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;marker.addListener(&#39;click&#39;, function() {
      map.setZoom(8);
      map.setCenter(marker.getPosition());
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-10&quot;&gt;15.添加消息显示框：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function attachSecretMessage(marker, secretMessage) {
    var infowindow = new google.maps.InfoWindow({
      content: secretMessage
    });
	
    marker.addListener(&#39;click&#39;, function() {
      infowindow.open(marker.get(&#39;map&#39;), marker);
    });
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-11&quot;&gt;注意:&lt;/h2&gt;

&lt;p&gt;google.maps.event.addListener是为其他对象添加事件，而map.addListener是为map本身添加对象&lt;/p&gt;

&lt;p&gt;google.maps.event是事件对象，可以通过获取到很多东西。如坐标还可能是图形对象，具体看情况，以下就是图形对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	google.maps.event.addListener(drawingManager, &#39;circlecomplete&#39;, function(circle) {
  var radius = circle.getRadius();
});

google.maps.event.addListener(drawingManager, &#39;overlaycomplete&#39;, function(event) {
  if (event.type == &#39;circle&#39;) {
    var radius = event.overlay.getRadius();
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置位置没有加单位导致不能用，在地图上绘图时，google.maps.Map 事件（如 click 和 mousemove）将被禁用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;google地图的点击事件会有遮挡和屏蔽的效果。所以如果处于绘图模式map的点击等一系列效果会被屏蔽。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>GPS坐标区域判定2</title>
        <link>http://www.liuschen.com/2017/09/20/gps2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/09/20/gps2.html</guid>
        <pubDate>Wed, 20 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;1.两点之间距离&lt;/h1&gt;

&lt;p&gt;通过手动算法计算：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static double getEarthDistance(double lat1,double lon1,
                             double lat2, double lon2){
    double φ1 = Math.toRadians(lat1);
    double φ2 = Math.toRadians(lat2);
    double Δφ = Math.toRadians(lat2-lat1);
    double Δλ =  Math.toRadians(lon2-lon1);

    double a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ/2) * Math.sin(Δλ/2);

    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    double d = EARTH_RADIUS_KM * c;
    return d;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过android中现成的方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static void computeDistanceAndBearing(double lat1, double lon1,
    double lat2, double lon2, float[] results) {
    // Based on http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf
    // using the &quot;Inverse Formula&quot; (section 4)

    int MAXITERS = 20;
    // Convert lat/long to radians
    lat1 *= Math.PI / 180.0;
    lat2 *= Math.PI / 180.0;
    lon1 *= Math.PI / 180.0;
    lon2 *= Math.PI / 180.0;

    double a = 6378137.0; // WGS84 major axis
    double b = 6356752.3142; // WGS84 semi-major axis
    double f = (a - b) / a;
    double aSqMinusBSqOverBSq = (a * a - b * b) / (b * b);

    double L = lon2 - lon1;
    double A = 0.0;
    double U1 = Math.atan((1.0 - f) * Math.tan(lat1));
    double U2 = Math.atan((1.0 - f) * Math.tan(lat2));

    double cosU1 = Math.cos(U1);
    double cosU2 = Math.cos(U2);
    double sinU1 = Math.sin(U1);
    double sinU2 = Math.sin(U2);
    double cosU1cosU2 = cosU1 * cosU2;
    double sinU1sinU2 = sinU1 * sinU2;

    double sigma = 0.0;
    double deltaSigma = 0.0;
    double cosSqAlpha = 0.0;
    double cos2SM = 0.0;
    double cosSigma = 0.0;
    double sinSigma = 0.0;
    double cosLambda = 0.0;
    double sinLambda = 0.0;

    double lambda = L; // initial guess
    for (int iter = 0; iter &amp;lt; MAXITERS; iter++) {
        double lambdaOrig = lambda;
        cosLambda = Math.cos(lambda);
        sinLambda = Math.sin(lambda);
        double t1 = cosU2 * sinLambda;
        double t2 = cosU1 * sinU2 - sinU1 * cosU2 * cosLambda;
        double sinSqSigma = t1 * t1 + t2 * t2; // (14)
        sinSigma = Math.sqrt(sinSqSigma);
        cosSigma = sinU1sinU2 + cosU1cosU2 * cosLambda; // (15)
        sigma = Math.atan2(sinSigma, cosSigma); // (16)
        double sinAlpha = (sinSigma == 0) ? 0.0 :
            cosU1cosU2 * sinLambda / sinSigma; // (17)
        cosSqAlpha = 1.0 - sinAlpha * sinAlpha;
        cos2SM = (cosSqAlpha == 0) ? 0.0 :
            cosSigma - 2.0 * sinU1sinU2 / cosSqAlpha; // (18)

        double uSquared = cosSqAlpha * aSqMinusBSqOverBSq; // defn
        A = 1 + (uSquared / 16384.0) * // (3)
            (4096.0 + uSquared *
             (-768 + uSquared * (320.0 - 175.0 * uSquared)));
        double B = (uSquared / 1024.0) * // (4)
            (256.0 + uSquared *
             (-128.0 + uSquared * (74.0 - 47.0 * uSquared)));
        double C = (f / 16.0) *
            cosSqAlpha *
            (4.0 + f * (4.0 - 3.0 * cosSqAlpha)); // (10)
        double cos2SMSq = cos2SM * cos2SM;
        deltaSigma = B * sinSigma * // (6)
            (cos2SM + (B / 4.0) *
             (cosSigma * (-1.0 + 2.0 * cos2SMSq) -
              (B / 6.0) * cos2SM *
              (-3.0 + 4.0 * sinSigma * sinSigma) *
              (-3.0 + 4.0 * cos2SMSq)));

        lambda = L +
            (1.0 - C) * f * sinAlpha *
            (sigma + C * sinSigma *
             (cos2SM + C * cosSigma *
              (-1.0 + 2.0 * cos2SM * cos2SM))); // (11)

        double delta = (lambda - lambdaOrig) / lambda;
        if (Math.abs(delta) &amp;lt; 1.0e-12) {
            break;
        }
    }

    float distance = (float) (b * A * (sigma - deltaSigma));
    results[0] = distance;
    if (results.length &amp;gt; 1) {
        float initialBearing = (float) Math.atan2(cosU2 * sinLambda,
            cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
        initialBearing *= 180.0 / Math.PI;
        results[1] = initialBearing;
        if (results.length &amp;gt; 2) {
            float finalBearing = (float) Math.atan2(cosU1 * sinLambda,
                -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);
            finalBearing *= 180.0 / Math.PI;
            results[2] = finalBearing;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;2.判断一点是否在不规则多边形中&lt;/h1&gt;

&lt;p&gt;判断一点是否在多边形中，常用的是射线法，个人觉得也是最简单的一种，因为比较角度和面积都会牵扯到正负的判断，而射线法则不需要。规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;以给定的点为起点，向任意方向做一条射线。如果射线与给定的多边形的交点为奇数则该点在多边形内部（点不再多边形边上且不与顶点重合），为偶数则为点在多边形外（0是偶数）。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单单这样看的话，也并不简单，首先应该先建立坐标系，然后取一条过点的射线，列出函数表达式，然后因为已知多边形各各点的坐标，求出每条边的函数，遍历每条边，计算与射线的交点并计算交点是否在多边形的边上。如果在，算作一个交点。最后算出总的交点个数即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;特殊情况：当所选取的射线与一条边重合时，如果点不在重合线段上，算作两个交点，如果在，算作一个交点，并且排除相邻两边的计算，排除以上情况后，如果射线过多边形的一个顶点，那么依旧算作两个交点，并且排除过该顶点的另一条边的计算。其余的按照正常计算即可。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体问题具体分析，gps坐标是地理坐标，是在一个球体上表示，如果求一个点是否在指定图形区域内，如果要在笛卡尔坐标系中计算，就需要将坐标投影到平面上，可以用web墨卡托坐标系，在平面坐标系中求得多边形距离给定点最近的一点的坐标，将此点再次转化为gps坐标，然后计算给定点与该点的距离即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;之所以做两次转化是因为平面坐标系计算距离不准确，而且维度不同误差很大，所以平面坐标系将点到多边形转化为点到点的计算，然后可以在球面坐标系中用现成的方法来计算
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，以上方法还是太麻烦了，因为是应用计算，完全不必要，只需要取一个特殊的射线即可，我取的是 给定点指向北极点（将极点看作无穷远）的射线。那么只需要3步骤即可：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.判断射线是否与多边形边重合&lt;/li&gt;
  &lt;li&gt;2.判断给定点是否与多边形顶点重合&lt;/li&gt;
  &lt;li&gt;3.判断多边形每条边是否与射线相交（遍历，以下是对多边形每条线段的处理）&lt;/li&gt;
  &lt;li&gt;3.1.线段两个端点的纬度如果大于给定点，经度如果一个大于一个小于给定点则相交，记为一个交点。&lt;/li&gt;
  &lt;li&gt;3.2.如果线段两端点经度一个大于一个小于给定点，同时纬度一个大于一个小于给定点，那么就需要通过平行相交的比例关系判断与射线所在直线的交点是否是在射线上。如果在，记为一个交点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体算法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 判断点是否在图形区域内
 * 原理:射线法，取点所在的经线作为射线来判断
 *
 * 特殊情况：
 * 1.射线与n条边重合
 * 2.射线与经过n个顶点
 * @param point 点的经纬度，0/1   latitude/ longitude 纬度/经度
 * @param polygon 多边形的点集合，0/1   latitude/ longitude 纬度/经度
 * */
public static boolean isPointInPolygon(double[] point,double[][] polygon){
    /**参考射线取点所在经线自该点向南极发射的一条射线*/
    int node = 0;
    for (int i = 0; i &amp;lt; polygon.length; i++) {
        int next = i+1;
        if (i==polygon.length-1)
            next = 0;
        /**首先判断边是否与参考经线重合*/
        if(point[1]==polygon[i][1]&amp;amp;&amp;amp;polygon[i][1]==polygon[next][1]){
            if((point[0]&amp;gt;=polygon[i][0]&amp;amp;&amp;amp;point[0]&amp;lt;=polygon[next][0])||(point[0]&amp;lt;=polygon[i][0]&amp;amp;&amp;amp;point[0]&amp;gt;=polygon[next][0])){
                /**在线段内*/
                return true;
            }else if(point[0]&amp;lt;polygon[i][0]&amp;amp;&amp;amp;point[0]&amp;lt;polygon[next][0]){
                /**在线段外的射线上*/
                System.out.println(&quot;~~点在线段延长线上:&quot;+i);
                node+=2;
            }else{
                /**在线段外，并且不在射线上*/
            }
        }else if(point[1]==polygon[i][1]){
            /**判断顶点是否在参考经线之上*/
            if(point[0]==polygon[i][0]){
                /**点与图形顶点重合*/
                return true;
            }else if(point[0]&amp;lt;polygon[i][0]){
                node+=2;
            }
        }else{
            /**判断边是否与射线相交*/

            /**这种计算的先决条件是线段两点必须分布在当前位置点所在经线的两端*/
            if((polygon[i][1]&amp;gt;point[1]&amp;amp;&amp;amp;polygon[next][1]&amp;gt;point[1])||(polygon[i][1]&amp;lt;point[1]&amp;amp;&amp;amp;polygon[next][1]&amp;lt;point[1])){
                /**参考经线不会经过该线段*/
                continue;
            }else{
                /**判断纬度是否需要计算*/
                if(polygon[i][0]&amp;gt;point[0]&amp;amp;&amp;amp; polygon[next][0]&amp;gt;point[0]){
                    System.out.println(&quot;~~纬度判断:&quot;+i);
                    node++;
                }else if(polygon[i][0]&amp;lt;point[0]&amp;amp;&amp;amp; polygon[next][0]&amp;gt;point[0]){
                    /***/
                    double tempLength1 = getDistanceByAndroid(polygon[i][0],polygon[i][1],polygon[i][0],point[1]);
                    double tempLength2 = getDistanceByAndroid(polygon[next][0],polygon[next][1],polygon[next][0],point[1]);
                    /**参考距离*/
                    double tempLength4 = getDistanceByAndroid(point[0],point[1],polygon[next][0],point[1]);

                    double tempLength5 = getDistanceByAndroid(polygon[i][0],point[1],polygon[next][0],point[1]);
                    if((tempLength4/tempLength5)&amp;gt;(tempLength2/(tempLength1+tempLength2))){
                        /**经过一个交点*/
                        System.out.println(&quot;~~夹点判断1:&quot;+i);
                        node++;
                    }
                }else if(polygon[i][0]&amp;gt;point[0]&amp;amp;&amp;amp; polygon[next][0]&amp;lt;point[0]){
                    /***/
                    double tempLength1 = getDistanceByAndroid(polygon[i][0],polygon[i][1],polygon[i][0],point[1]);
                    double tempLength2 = getDistanceByAndroid(polygon[next][0],polygon[next][1],polygon[next][0],point[1]);
                    /**参考距离*/
                    double tempLength3 = getDistanceByAndroid(point[0],point[1],polygon[i][0],point[1]);

                    double tempLength5 = getDistanceByAndroid(polygon[i][0],point[1],polygon[next][0],point[1]);
                    if((tempLength3/tempLength5)&amp;gt;(tempLength1/(tempLength1+tempLength2))){
                        /**经过一个交点*/
                        System.out.println(&quot;~~夹点判断2:&quot;+i);
                        node++;
                    }
                }
                /**
                 * polygon[i][0]&amp;lt;point[0]&amp;amp;&amp;amp; polygon[next][0]&amp;lt;point[0]
                 相交于射线的反向延长线上(最后一种可能，基于性能不做判断)
                 * */
                }
            }
    }
    System.out.println(&quot;~~node:&quot;+node);
    if(node%2==0) return false;
    else return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;3.计算点到多边形的距离&lt;/h1&gt;

&lt;p&gt;直接计算我没有好的方法，我计算的是配合上面判断点是否在多边形内部，然后计算点到各个多边形边的最短距离&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.遍历多边形，得出每条边&lt;/li&gt;
  &lt;li&gt;2.已知给定点到线段端点的长度，以及线段长度，求出点到线段的距离&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法1，已知三边长，求高：&lt;/p&gt;

 	/**&lt;br /&gt;
&lt;pre&gt;&lt;code&gt; * 计算三角上a边上的高
 *@param a a边长
 *@param b b边长
 *@param c c边长
 * */
public static double getTrigCh(double b,double c,double a){
    double p1 = a+c+b;
    double p2 = a+c-b;
    double p3 = b+a-c;
    double p4 = b-a+c;
    double r1 = p1*p2*p3*p4;
    double r2 = Math.sqrt(r1);
    return r2/(2*a);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;算法2，计算点到多边形的距离：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**计算点到多边形之间的距离*/
public static double calculateDistance(double[] point,double[][] polygon){
    double[] distances = new double[polygon.length];
    double[] sideLengths = new double[polygon.length];
    for (int i = 0; i &amp;lt; polygon.length; i++) {
        int next = i+1;
        if (i==polygon.length-1)
            next = 0;
        distances[i] = getDistance(point[0],point[1],polygon[i][0],polygon[i][1]);
        sideLengths[i] = getDistance(polygon[i][0],polygon[i][1],polygon[next][0],polygon[next][1]);
        System.out.println(&quot;~distances[&quot;+i+&quot;]:&quot;+distances[i]);
        System.out.println(&quot;~sideLengths[&quot;+i+&quot;]:&quot;+sideLengths[i]);
    }
    double minDistance = Double.MAX_VALUE;
    for (int i = 0; i &amp;lt; polygon.length; i++) {
        int next = i+1;
        if (i==polygon.length-1)
            next = 0;
        double tampDistance;
        if(distances[i]&amp;gt;distances[next]&amp;amp;&amp;amp;distances[i]&amp;gt;sideLengths[i]){
            tampDistance = distances[next];
        }else if(distances[next]&amp;gt;distances[i]&amp;amp;&amp;amp;distances[next]&amp;gt;sideLengths[i]){
            tampDistance = distances[i];
        }else{
            tampDistance = getTrigCh(distances[i],distances[next],sideLengths[i]);
        }
        System.out.println(&quot;~tampDistance:&quot;+tampDistance);
        minDistance = (minDistance&amp;gt;tampDistance)?tampDistance:minDistance;
    }
    return minDistance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.liuschen.com/code/gpsUtils.html&quot;&gt;更多GPS操作方法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>GPS坐标区域判定1</title>
        <link>http://www.liuschen.com/2017/09/20/gps1.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/09/20/gps1.html</guid>
        <pubDate>Wed, 20 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;相关知识因为总要用到，结果再看时却已经忘的差不多，所以这次温习，记下，备忘。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;地球是一个两极稍扁，赤道略鼓的扁球体&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;坐标系区分&lt;/h1&gt;

&lt;p&gt;首先按坐标类型划分分为:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;地理坐标系(大地坐标系，球面坐标，地理坐标，4326 GCS_WGS_1984,火星坐标和百度坐标属于加偏过的地理坐标)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;投影坐标系(平面坐标，例:102100 WGS_1984_web_mercator_auxiliary_sphere,墨卡托投影坐标系)&lt;/p&gt;

    &lt;p&gt;web_mercator是一个投影坐标系，其参考的基准面是WGS_1984( WGS 1984 是一个长半轴(a)为6378137，短半轴（b）为6356752.314245179 的椭球体，扁率(f)为298.257223563，f=(a-b)/a ),并不是严格意义上的墨卡托投影,&lt;br /&gt;
  Auxiliary Sphere 就是在告知你，这个坐标在投影过程中，将椭球体近似为正球体做投影变换，虽然基准面是WGS 1984 椭球面&lt;br /&gt;
  102100是Esri内部使用ID与之对应EPSG分配的坐标系ID为3857&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中地理坐标系也是一种球面坐标系，是用来定位一点在地球中的位置的。而投影坐标系则是通过点线面来计算长度测算距离面积的。&lt;/p&gt;

&lt;p&gt;通过android手机获取的GPS坐标是经纬度坐标，一般小数位比较长，这是因为做分秒转化时没有除尽导致的，这也说明了Google取到的坐标是时分秒的形式，北京经度都是116。&lt;/p&gt;

&lt;p&gt;时分秒坐标转经纬度坐标：&lt;/p&gt;

&lt;p&gt;经/纬度 = 经/纬度 + 经/纬分/60 + 经/纬秒/3600&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GCJ-02：火星坐标系，我国使用的，所有电子地图必须经过至少一次的加偏

谷歌地图API，高德地图API，腾讯地图API上取到的，都是GCJ-02坐标
百度API上取到的，是BD-09坐标，只适用于百度地图相关产品。
搜狗API上取到的，是搜狗坐标，只适用于搜狗地图相关产品。
谷歌地球，google earth上取到的，是GPS坐标，而且是度分秒形式的经纬度坐标，在国内不允许直接使用。
百度和goole投影选择的都是墨卡托，web_mercator（web墨卡托）是将地球模拟为球体，Spherical Mercator常规墨卡托将地球模拟为椭球体
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;坐标转换&lt;/h1&gt;

&lt;p&gt;坐标转换包括，GPS坐标转火星坐标(中国必须，偏移)，GPS和web墨卡托互相转化(地图显示)，算法，略。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;地图概念区分&lt;/h1&gt;

&lt;p&gt;通常我们使用的定位坐标是GPS坐标，是一种地理坐标，即WGS_1984&lt;/p&gt;

&lt;p&gt;应用到地图中的坐标为平面坐标，即墨卡托坐标系，与上面坐标系不同的是这种坐标系是一种平面坐标系，也就是单位是m或是km&lt;/p&gt;

&lt;p&gt;我再用地图下载器下载的Google地图有未加偏和加偏的地图，这个加偏就是转火星坐标，也就是GCJ-02坐标，这种坐标的本质还是一种地理坐标系，所以还是用度分秒来表示&lt;/p&gt;

&lt;p&gt;arcgis中进行图形判定时会有些转化设置，SpatialReference.create(4326), SpatialReference.create(102100),是将gps坐标转换为地图投影坐标再计算，注意，是由于是图形计算，才需要平面坐标系。&lt;/p&gt;

&lt;p&gt;而我另一篇写的坐标区域判定并不是和arcgis一样纯图形的，是先通过gps来判断内外，然后通过各个点的距离来进行图形计算的，完美绕开了我误解的区域（我曾以为Google的偏移是由于gps转墨卡托坐标引起的）&lt;/p&gt;

&lt;p&gt;参考:&lt;a href=&quot;http://blog.csdn.net/kikitamoon/article/details/46124935&quot;&gt;Web Mercator 公开的小秘密&lt;/a&gt;&lt;br /&gt;
参考:&lt;a href=&quot;http://www.movable-type.co.uk/scripts/latlong.html&quot;&gt;Calculate distance, bearing and more between Latitude/Longitude points&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>PHP开发环境搭建</title>
        <link>http://www.liuschen.com/2017/09/10/php.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/09/10/php.html</guid>
        <pubDate>Sun, 10 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;最近买了个虚拟主机，但是买回来后却发现不支持java程序，只支持PHP，想想也不是想做什么复杂的东西，所以将就着先用用看。毕竟，所有语言都是共通的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;环境安装&lt;/h1&gt;

&lt;p&gt;下载&lt;a href=&quot;http://www.apachelounge.com/download/&quot;&gt;httpd-2.4.29-Win32-VC15&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载&lt;a href=&quot;http://windows.php.net/download#php-5.5&quot;&gt;php-5.6.32-Win32-VC11-x64&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;apache&quot;&gt;Apache配置&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意:下面安装服务必须使用管理员权限，所以打开CMD的时候要用管理员的身份打开&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同java一样，先配置了环境变量，然后打开CMD（必须使用管理员权限），不然不能安装服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首先配置:httpd.conf
ServerRoot &quot;httpd的根目录&quot;
DocumentRoot “根目录下同样位置”
以及其下的Directory路径也配置相同

httpd -k install（将apache注册为window的服务）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经常出现的错误是端口占用，这时候只需要更改默认的端口即可(至少两处)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Errors reported here must be corrected before the service can be started
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句话并不是错误，而是提示如果下面有错误要先解决。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;httpd -k start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动（必须先安装服务），可以访问了，通过127.0.0.1：端口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;继续配置httpd.conf
DirectoryIndex index.html 后添加index.php index.htm
ScriptAlias后目录同样修改为本机的相对应目录，后面Directory里面的当然也要修改
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件尾部最后添加对PHP支持：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoadModule php5_module &quot;本机php路径/php5apache2_4.dll&quot;
AddType application/x-httpd-php .php .html .htm
PHPIniDir &quot;本机php路径&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一句是为了找PHP根目录下的PHP.ini文件，是由php.ini-production重命名后得到，添加后如果提示不能载入php5_module，那么要么是window下的依赖没配置好（单独启动php试试），也可能就是我遇到的版本搭配问题，网上有关于这个问题的解答，我在版本号上的选择是没错的，只是，64位和32位的弄混了。应该下载httpd-2.4.29-Win64-VC15，才对，这是它起名造成的误解。&lt;/p&gt;

&lt;h1 id=&quot;eclipse-for-php&quot;&gt;eclipse for PHP调试环境的搭建&lt;/h1&gt;

&lt;p&gt;配置完调试没反应,修改php.ini文件,在结尾添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;zend_extension = F:\programer4\php-5.6.32-Win32-VC11-x64\ext\php_xdebug.dll
zend_extension_ts = F:\programer4\php-5.6.32-Win32-VC11-x64\ext\php_xdebug.dll
;extension = php_xdebug.dll
[Xdebug]
xdebug.auto_trace = 1
xdebug.show_exception_trace = 1
xdebug.remote_autostart = 1
xdebug.remote_enable = 1
xdebug.collect_vars = 1
xdebug.collect_return = 1
xdebug.collect_params = 1
xdebug.trace_output_dir=”D:/xDebugLog”
xdebug.profiler_output_dir=”D:/xDebugLog”
xdebug.profiler_enable= 1
xdebug.remote_host=localhost
xdebug.remote_port=9000
xdebug.remote_mode = req
xdebug.remote_handler=dbgp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：配置文件中的”；”为注释符号，end_extension要根据自己下载的放出合适的版本（TS线程安全和非线程安全）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xdebug.remote_port=9000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;远程端口要和eclipse中设置一致，&lt;/p&gt;

&lt;p&gt;选中php文件，点击Debug As-&amp;gt;PHP Script执行调试&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;错误&lt;/h1&gt;

&lt;p&gt;使用mysqli连接数据库错误:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Call to undefined function mysqli_connect()错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在php.ini文件中extension=php_mysqli.dll去掉前面的分号，然后再添加extension_dir=&quot;ext&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;万网数据库访问遇到问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using the old insecure authentication. Please use an administration tool to reset your password with the command SET PASSWORD = PASSWORD(&#39;your_existing_password&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新修改数据库密码，并把密码设置为41位加密的&lt;/p&gt;

&lt;p&gt;服务端错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Call to undefined function mysqli_connect()错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始我还以为是同一个问题，后来梳理清楚了，发现解决上面这个问题的方法，只是在eclipse中执行脚本时运行通过了（eclipse中关联php.ini文件了）。但是一旦在服务器上让网页访问还是会出现这个问题。&lt;/p&gt;

&lt;h1 id=&quot;php&quot;&gt;更换PHP版本&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;鉴于阿里云上的PHP没有5.6版本的支持，最终选择7.0版本作为使用版本，因为阿里云最高支持到7.1版本，为了避免麻烦，使用7.0版的。&lt;br /&gt;
配置依照上面配置只是php5换成php7&lt;/p&gt;
&lt;/blockquote&gt;

</description>
      </item>
    
      <item>
        <title>线程实例分析</title>
        <link>http://www.liuschen.com/2017/09/03/thresd2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/09/03/thresd2.html</guid>
        <pubDate>Sun, 03 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;场景一：&lt;/p&gt;

&lt;p&gt;如果在主线程中启动一个子线程，将这个子线程join到主线程上，子线程中再开一个线程池来启动一个新的任务。这个新的任务中设置一个无限循环。当程序执行5分钟后，有多少线程还在执行。程序如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Main {
	public static void main(String[] args){
		try {
		Thread thread;
		thread = new Thread(){
			 @Override
			public void run() {
				 ExecutorService fixPool = Executors.newFixedThreadPool(5);
				 WorkRunable1 runa = new WorkRunable1();
				 //WorkRunable1 runa2 = new WorkRunable1();
				 fixPool.execute(runa);
				 //fixPool.execute(runa2);
				 System.out.println(&quot;该线程已经执行完毕:当前线程为&quot;+Thread.currentThread().getName());
			}
		};
		thread.start();
		thread.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(&quot;主线程已经执行完毕:&quot;+Thread.currentThread().getName());
		
	}
	
	public static class WorkRunable1 implements Runnable{

		@Override
		public void run() {
			while(true){
				try {
					Thread.sleep(3000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;我一直在输出:&quot;+Thread.activeCount());
			}
		}
		
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行显示将会有两个线程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Thread[pool-1-thread-1]
Thread[DestoryJavaVM]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，第一个启动的子线程早已经结束，所以main线程也随之结束。但是，还有线程执行，在主线程结束后启动了DestoryJavaVM，监听是否还有非守护线程执行，如果没有将关闭JVM。&lt;/p&gt;

&lt;p&gt;如果在一个子线程中开一个无限循环，那么执行的线程将会变为2个，分别是：&lt;/p&gt;

&lt;p&gt;主线程，第一个启动的子线程，和持续输出的线程池中的线程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;虽然这个结果一直在实践中被证实，但是没深究过，总是主观以为主线程结束了，其他所有线程理应就跟着完了。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>线程复习笔记</title>
        <link>http://www.liuschen.com/2017/09/03/thread1.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/09/03/thread1.html</guid>
        <pubDate>Sun, 03 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;内容主要来自《Java多线程编程核心技术》 高洪岩著&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;1.线程的生命周期&lt;/h2&gt;

&lt;p&gt;线程是一个动态执行的过程，它也有一个从产生到死亡的过程。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;(1)生命周期的五种状态&lt;/h3&gt;

&lt;h4 id=&quot;new-thread&quot;&gt;新建（new Thread）&lt;/h4&gt;

&lt;p&gt;当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。&lt;br /&gt;
例如：Thread  t1=new Thread();&lt;/p&gt;

&lt;h4 id=&quot;runnable&quot;&gt;就绪（runnable）&lt;/h4&gt;

&lt;p&gt;线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();&lt;/p&gt;

&lt;h4 id=&quot;running&quot;&gt;运行（running）&lt;/h4&gt;

&lt;p&gt;线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。&lt;/p&gt;

&lt;h4 id=&quot;dead&quot;&gt;死亡（dead）&lt;/h4&gt;

&lt;p&gt;当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。&lt;br /&gt;
自然终止：正常运行run()方法后终止&lt;br /&gt;
异常终止：调用stop()方法让一个线程终止运行&lt;/p&gt;

&lt;h4 id=&quot;blocked&quot;&gt;堵塞（blocked）&lt;/h4&gt;

&lt;p&gt;由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。&lt;/p&gt;

&lt;p&gt;正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。&lt;/p&gt;

&lt;p&gt;正在等待：调用wait()方法。（调用motify()方法回到就绪状态）&lt;br /&gt;
被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.常用方法&lt;/h3&gt;
&lt;p&gt;void run()   创建该类的子类时必须实现的方法&lt;br /&gt;
void start() 开启线程的方法&lt;br /&gt;
static void sleep(long t) 释放CPU的执行权，不释放锁&lt;br /&gt;
static void sleep(long millis,int nanos)&lt;br /&gt;
final void wait()释放CPU的执行权，释放锁&lt;br /&gt;
final void notify()&lt;br /&gt;
static void yied()可以对当前线程进行临时暂停（让线程将资源释放出来）&lt;br /&gt;
3.（1）结束线程原理：就是让run方法结束。而run方法中通常会定义循环结构，所以只要控制住循环即可&lt;br /&gt;
(2)方法—-可以boolean标记的形式完成，只要在某一情况下将标记改变，让循环停止即可让线程结束&lt;br /&gt;
（3）public final void join()//让线程加入执行，执行某一线程join方法的线程会被冻结，等待某一线程执行结束，该线程才会恢复到可运行状态&lt;/p&gt;

&lt;p&gt;引用出处:&lt;a href=&quot;http://blog.csdn.net/mayouarebest8621/article/details/6755036&quot;&gt;http://blog.csdn.net/mayouarebest8621/article/details/6755036&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2.方法&lt;/h2&gt;

&lt;p&gt;currentThread():返回调用代码段的线程信息&lt;/p&gt;

&lt;p&gt;isAlive():判断线程是否处于活动状态，start之前调用为false,start之后为true&lt;/p&gt;

&lt;p&gt;sleep():指定毫秒数让当前线程休眠&lt;/p&gt;

&lt;p&gt;getId():取得线程的唯一标识&lt;/p&gt;

&lt;p&gt;suspend()：挂起(也是有死锁的隐患，和锁有关，废除)&lt;/p&gt;

&lt;p&gt;resume():重新开始执行，（和suspend，因为很容易造成资源独占，导致死锁，废除）&lt;/p&gt;

&lt;p&gt;stop():停止（一般线程结束都是在线程中通过流程控制来结束，因为用stop太过暴力，会释放线程所有保有的资源，废除）&lt;/p&gt;

&lt;p&gt;setPriority():设置线程的优先级&lt;/p&gt;

&lt;p&gt;join(重要):当前线程等待新开的线程结束后再结束，多用于主线程和子线程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;子线程.start()
子线程.join()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;join(long),延时，内部用wait()释放锁&lt;br /&gt;
sleep(long),不释放锁&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;join方法会阻塞线程，所以一个线程不能同时开启多个线程然后join,这样用非但不能达到目的，反而会使逻辑变的混乱。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-4&quot;&gt;3.对象监视器(锁)&lt;/h1&gt;

&lt;p&gt;方法内变量为线程安全，实例中变量非线程安全（多个线程可能会访问同一个实例中的变量）&lt;/p&gt;

&lt;p&gt;synchronized修饰方法，先调用该方法在没执行完时会持有锁，使后调用该方法的线程阻塞，直到前一个线程将锁释放。&lt;/p&gt;

&lt;p&gt;synchronized（this）同步代码块，两个线程同时访问一个对象中的同步代码块时，先进入线程释放锁之前，后访问的线程阻塞等待。&lt;/p&gt;

&lt;p&gt;synchronized同步方法和synchronized（this）互相阻塞&lt;/p&gt;

&lt;p&gt;synchronized(非this对象)互相阻塞,互相阻塞表示的是对象监视器相同，在一个线程持有锁，另一个线程调用具有加锁的代码块时就会等待，&lt;strong&gt;wait()方法会释放当前线程的锁，sleep()不会释放锁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;static方法加synchronized持有的是class锁，而普通方法加synchronized持有的是对象锁，所以两者不能同步&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;原子性&lt;/h1&gt;

&lt;p&gt;原子性就是操作的不可分割性，就和加上同步是一个效果，一个线程对一些变量进行操作，操作没有完成就不能有其他线程操作，否则，回写的值就会出现问题，产生脏数据。&lt;/p&gt;

&lt;p&gt;volatile是强制从公共堆栈中取得变量，而不是从线程专有的线程中取得，对它的操作不具备原子性，也就是在不同线程同时写入可能会出错。&lt;/p&gt;

&lt;p&gt;原子类如：AtomicInteger，前有前缀Atomic&lt;/p&gt;

&lt;p&gt;原子类的操作也不一定是线程安全的，因为之外可能有不安全的操作，要综合考虑。&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;等待通知&lt;/h1&gt;

&lt;p&gt;锁对象所属的wait()和notify()方法是等待和唤醒，在同步代码块之中，如果所属同一个锁对象的wait()被多个线程调用，那么调用的线程会释放对象锁，然后进入线程等待池中，等待被唤醒。如果调用notify()会随机唤醒锁对象，多调用几次就能唤醒全部，也可以直接调用notifyAll()&lt;/p&gt;

&lt;h1 id=&quot;threadlocalinheritablethreadlocal&quot;&gt;ThreadLocal和InheritableThreadLocal&lt;/h1&gt;

&lt;p&gt;InheritableThreadLocal继承于前者&lt;/p&gt;

&lt;p&gt;#同步锁&lt;/p&gt;

&lt;p&gt;Lock lock = new ReentrantLock();&lt;br /&gt;
Condition condition = lock.newCondition();&lt;br /&gt;
lock.lock();&lt;/p&gt;

&lt;p&gt;condition.await()&lt;br /&gt;
condition.signal()&lt;br /&gt;
condition.signalAll()&lt;/p&gt;

&lt;p&gt;lock相当于之前的synchronized&lt;br /&gt;
condition相当于之前的锁对象，里面有相关的等待唤醒方法。只是功能更强大。可以建立多个来保证等待与唤醒线程的准确切换。&lt;/p&gt;

&lt;p&gt;公平锁与非公平锁：传入一个boolean来指定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tryLock()立即返回，可以带延时
lock()获取不到，就使当前线程休眠等待
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;reentrantreadwritelock&quot;&gt;ReentrantReadWriteLock读写锁&lt;/h1&gt;

&lt;p&gt;读读共享，写写互斥，读写互斥，写读互斥&lt;/p&gt;

&lt;p&gt;#线程组与线程池&lt;/p&gt;

&lt;p&gt;线程组是为了方便线程的管理&lt;/p&gt;

&lt;p&gt;线程池是为了减少线程创建与销毁的开销&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;单例模式&lt;/h1&gt;

&lt;p&gt;饿汉模式:直接建立对象，获取直接返回&lt;/p&gt;

&lt;p&gt;懒汉模式：为了解决多线程下问题，需要对对象进行双检查，既防止不同线程多次创建实例，又保证了效率&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(obj!=null){
}else{
	synchronized(){
		if(obj==null)
			obj = new Obj();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-8&quot;&gt;守护线程&lt;/h1&gt;

&lt;p&gt;在新建的线程启动前setDaemon(true)即可，在守护线程中新开的线程也是守护线程，守护线程不应访问资源，因为守护线程有中断的危险。当JVM中不存在非守护线程时，就会销毁JVM。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>android权限管理</title>
        <link>http://www.liuschen.com/2017/08/05/AndroidSafe.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/08/05/AndroidSafe.html</guid>
        <pubDate>Sat, 05 Aug 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;android6.0后权限管理上更为严格，原本安装程序时确认的权限信息，也被分散到了调用的地方。也就是说除了在清单文件中声明权限外，对于一些安全敏感的权限而言，需要在调用的时候请求用户手动去开启权限。以内存卡读写权限为例。&lt;/p&gt;

&lt;p&gt;首先，应该在清单文件中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其次，需要在调用的地方手动请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	int permissionCheck = ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE);

    if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 001);
    } else {
		
        String path = Environment.getExternalStorageDirectory().getAbsolutePath();
        File file = new File(path+File.separator+&quot;pdemo5&quot;);
        Toast.makeText(this,&quot;开始执行&quot;,Toast.LENGTH_SHORT).show();
        if (!file.exists()){
            Toast.makeText(this,&quot;文件不存在，创建文件夹&quot;,Toast.LENGTH_SHORT).show();
            file.mkdir();
            if(!file.exists()){
                Toast.makeText(this,&quot;创建失败，文件依旧不存在&quot;,Toast.LENGTH_SHORT).show();
            }else{
                Toast.makeText(this,&quot;文件创建成功&quot;,Toast.LENGTH_SHORT).show();
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后通过以下方法在activity中监听向用户申请权限得到的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {
    switch (requestCode) {
        case 001:
            Toast.makeText(this,&quot;开始执行回调&quot;,Toast.LENGTH_SHORT).show();
            if ((grantResults.length &amp;gt; 0) &amp;amp;&amp;amp; (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {
                Toast.makeText(this,&quot;开始执行回调判断&quot;,Toast.LENGTH_SHORT).show();
            }
            break;
        default:
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中需要实时授权的权限，同组只需要授权一个就行：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CALENDAR（日历）&lt;/li&gt;
  &lt;li&gt;READ_CALENDAR&lt;/li&gt;
  &lt;li&gt;WRITE_CALENDAR&lt;/li&gt;
  &lt;li&gt;CAMERA（相机）&lt;/li&gt;
  &lt;li&gt;CAMERA&lt;/li&gt;
  &lt;li&gt;CONTACTS（联系人）&lt;/li&gt;
  &lt;li&gt;READ_CONTACTS&lt;/li&gt;
  &lt;li&gt;WRITE_CONTACTS&lt;/li&gt;
  &lt;li&gt;GET_ACCOUNTS&lt;/li&gt;
  &lt;li&gt;LOCATION（位置）&lt;/li&gt;
  &lt;li&gt;ACCESS_FINE_LOCATION&lt;/li&gt;
  &lt;li&gt;ACCESS_COARSE_LOCATION&lt;/li&gt;
  &lt;li&gt;MICROPHONE（麦克风）&lt;/li&gt;
  &lt;li&gt;RECORD_AUDIO&lt;/li&gt;
  &lt;li&gt;PHONE（手机）&lt;/li&gt;
  &lt;li&gt;READ_PHONE_STATE&lt;/li&gt;
  &lt;li&gt;CALL_PHONE&lt;/li&gt;
  &lt;li&gt;READ_CALL_LOG&lt;/li&gt;
  &lt;li&gt;WRITE_CALL_LOG&lt;/li&gt;
  &lt;li&gt;ADD_VOICEMAIL&lt;/li&gt;
  &lt;li&gt;USE_SIP&lt;/li&gt;
  &lt;li&gt;PROCESS_OUTGOING_CALLS&lt;/li&gt;
  &lt;li&gt;SENSORS（传感器）&lt;/li&gt;
  &lt;li&gt;BODY_SENSORS&lt;/li&gt;
  &lt;li&gt;SMS（短信）&lt;/li&gt;
  &lt;li&gt;SEND_SMS&lt;/li&gt;
  &lt;li&gt;RECEIVE_SMS&lt;/li&gt;
  &lt;li&gt;READ_SMS&lt;/li&gt;
  &lt;li&gt;RECEIVE_WAP_PUSH&lt;/li&gt;
  &lt;li&gt;RECEIVE_MMS&lt;/li&gt;
  &lt;li&gt;STORAGE（存储卡）&lt;/li&gt;
  &lt;li&gt;READ_EXTERNAL_STORAGE&lt;/li&gt;
  &lt;li&gt;WRITE_EXTERNAL_STORAGE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同一个应用同一种权限正常情况下只会向用户请求一次，如果只在清单中加，而没有在代码中申请权限，那么是得不到相关的安全敏感的权限的，用得不到操作权限的操作操作数据处理信息会导致程序异常退出，但程序退出可能并不是直接由权限缺失导致。&lt;/p&gt;

&lt;p&gt;参考:&lt;a href=&quot;http://blog.csdn.net/yanzhenjie1003/article/details/52503533/&quot;&gt;http://blog.csdn.net/yanzhenjie1003/article/details/52503533/&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>maven2</title>
        <link>http://www.liuschen.com/2017/07/25/maven2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/07/25/maven2.html</guid>
        <pubDate>Tue, 25 Jul 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;maven同gradle以及git,svn等版本控制软件一样，都有局部设置（用户的目录下都有一个默认的.m2/repository/路径作为本地仓库，.m2文件夹中的settings.xml）和全局设置（maven目录下config中的settings.xml）。&lt;/p&gt;

&lt;p&gt;maven的远程仓库分为中央仓库，和私服。中央仓库时默认的，因为新建的pom.xml默认继承了超级pom.xml而这个超级pom.xml配置了中央仓库的地址。可以在pom.xml中配置其他仓库地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;repositories&amp;gt;  
&amp;lt;repository&amp;gt;  
  &amp;lt;id&amp;gt;central&amp;lt;/id&amp;gt;  
  &amp;lt;name&amp;gt;Central Repository&amp;lt;/name&amp;gt;  
  &amp;lt;url&amp;gt;http://repo.maven.apache.org/maven2&amp;lt;/url&amp;gt;  
  &amp;lt;layout&amp;gt;default&amp;lt;/layout&amp;gt;  
  &amp;lt;snapshots&amp;gt;  
    &amp;lt;enabled&amp;gt;false&amp;lt;/enabled&amp;gt;  
  &amp;lt;/snapshots&amp;gt;  
&amp;lt;/repository&amp;gt;  
  	&amp;lt;/repositories&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要将项目发布到远程服务器上可以这样设置:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;distributionManagement&amp;gt;
	&amp;lt;repository&amp;gt;
		&amp;lt;id&amp;gt;releases&amp;lt;/id&amp;gt;
		&amp;lt;name&amp;gt;Nexus Release Repository&amp;lt;/name&amp;gt;
		&amp;lt;url&amp;gt;http://10.168.1.105:8081/nexus/content/repositories/releases/&amp;lt;/url&amp;gt;
	&amp;lt;/repository&amp;gt;
	&amp;lt;snapshotRepository&amp;gt;
		&amp;lt;id&amp;gt;snapshots&amp;lt;/id&amp;gt;
		&amp;lt;name&amp;gt;Nexus Snapshots Repository&amp;lt;/name&amp;gt;
		&amp;lt;url&amp;gt;http://10.168.1.105:8081/nexus/content/repositories/snapshots/&amp;lt;/url&amp;gt;
	&amp;lt;/snapshotRepository&amp;gt;
&amp;lt;/distributionManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要验证身份信息的话，在settings.xml中配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;server&amp;gt;  
	&amp;lt;id&amp;gt;releases&amp;lt;/id&amp;gt;  
	&amp;lt;username&amp;gt;deployment&amp;lt;/username&amp;gt;  
	&amp;lt;password&amp;gt;deployment123&amp;lt;/password&amp;gt;  
&amp;lt;/server&amp;gt;
&amp;lt;server&amp;gt;
	&amp;lt;id&amp;gt;snapshots&amp;lt;/id&amp;gt;  
	&amp;lt;username&amp;gt;deployment&amp;lt;/username&amp;gt;  
	&amp;lt;password&amp;gt;deployment123&amp;lt;/password&amp;gt;  
&amp;lt;/server&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;远程仓库的配置同样也是可以在settings.xml中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;profile&amp;gt;
  &amp;lt;id&amp;gt;jdk-1.4&amp;lt;/id&amp;gt;

  &amp;lt;activation&amp;gt;
    &amp;lt;jdk&amp;gt;1.4&amp;lt;/jdk&amp;gt;
  &amp;lt;/activation&amp;gt;

  &amp;lt;repositories&amp;gt;
    &amp;lt;repository&amp;gt;
      &amp;lt;id&amp;gt;jdk14&amp;lt;/id&amp;gt;
      &amp;lt;name&amp;gt;Repository for JDK 1.4 builds&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;http://www.myhost.com/maven/jdk14&amp;lt;/url&amp;gt;
      &amp;lt;layout&amp;gt;default&amp;lt;/layout&amp;gt;
      &amp;lt;snapshotPolicy&amp;gt;always&amp;lt;/snapshotPolicy&amp;gt;
    &amp;lt;/repository&amp;gt;
  &amp;lt;/repositories&amp;gt;
&amp;lt;/profile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中profile标签中的内容是满足条件时激活该profile,activation表示激活条件，也就是jdk版本是1.4时激活该profile，如果要始终生效，可以添加激活条件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;activeProfiles&amp;gt;  
 &amp;lt;activeProfile&amp;gt;profileTest1&amp;lt;/activeProfile&amp;gt;  
&amp;lt;/activeProfiles&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个激活条件时在settings.xml的根标签中配置的，profileTest1是要激活的profile的id，而profile中的activation是主动选择执行情况&lt;/p&gt;

&lt;p&gt;还可以直接在项目中的pom.xml中配置私服地址（只在本项目起作用）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;repositories&amp;gt;  
    &amp;lt;repository&amp;gt;  
        &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;  
        &amp;lt;name&amp;gt;nexus&amp;lt;/name&amp;gt;  
        &amp;lt;url&amp;gt;http://192.168.1.103:8081/nexus/content/groups/public/&amp;lt;/url&amp;gt;  
        &amp;lt;releases&amp;gt;  
            &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;  
        &amp;lt;/releases&amp;gt;  
        &amp;lt;snapshots&amp;gt;  
            &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;  
        &amp;lt;/snapshots&amp;gt;  
    &amp;lt;/repository&amp;gt;  
&amp;lt;/repositories&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定插件地址:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;pluginRepositories&amp;gt;  
    &amp;lt;pluginRepository&amp;gt;  
        &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;  
        &amp;lt;name&amp;gt;nexus&amp;lt;/name&amp;gt;  
        &amp;lt;url&amp;gt;http://192.168.1.103:8081/nexus/content/groups/public/&amp;lt;/url&amp;gt;  
        &amp;lt;releases&amp;gt;  
            &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;  
        &amp;lt;/releases&amp;gt;  
        &amp;lt;snapshots&amp;gt;  
            &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;  
        &amp;lt;/snapshots&amp;gt;  
    &amp;lt;/pluginRepository&amp;gt;  
&amp;lt;/pluginRepositories&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或是在settdings.xml中配置:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;mvn install 会将项目生成的构件安装到本地Maven仓库，mvn deploy 用来将项目生成的构件分发到远程Maven仓库。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;正式版本在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载。快照版本会主动下载最新。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>数据库测试</title>
        <link>http://www.liuschen.com/2017/07/20/dbtest.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/07/20/dbtest.html</guid>
        <pubDate>Thu, 20 Jul 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;测试MYSQL数据库操作性能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;建立3个相互关联的表:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create table table_test1(id varchar(50) primary key not null,table_c1 varchar(50),table_c2 varchar(40),table_c3 varchar(40),table_c4 varchar(40));

create table table_test2(id varchar(50) primary key not null,table2_c1 varchar(50),table2_c2 varchar(40),table2_c3 varchar(40),table2_c4 varchar(40),test1_id varchar(50) not null,foreign key(test1_id) references table_test1(id));

create table table_test3(id varchar(50) primary key not null,table3_c1 varchar(50),table3_c2 varchar(40),table3_c3 varchar(40),table3_c4 varchar(40),test2_id varchar(50) not null,foreign key(test2_id) references table_test2(id));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个表为主表，第二个表为第一个表的从表，第三个表为第二个表的从表。&lt;/p&gt;

&lt;p&gt;然后通过sql语句插入数据(插入数据的关系为，主表一条数据，从表为10条，从表的从表为100条)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| 插入主表的条目 	| 执行消耗的时间 	| CPU消耗的时间  | 删除表耗时 |
| ------------- |:-------------:| -------------:|----------:|
| 1      		| &amp;lt;1s 			| &amp;lt;1s 			| &amp;lt;1s 		|
| 10      		| &amp;lt;1s      		| &amp;lt;1s			| &amp;lt;1s		|
| 100 			| 5s      		| 5s 			| &amp;lt;1s		|
| 1000 			| 55s      		| 55s 			| 9s		|
| 2000 			| 296s      	| 296s 			| 59s		|
| 3000 			| 1350ss      	| 1350ss 		| 574s		|
| 4000 			| 3741s      	| 3741s 		| 930s		|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入40万条数据（严格来说是444000条）时就已经执行了很长时间，要1个小时多。按照增加的速度，下一次将会好几个小时才能执行完成。那么，如果要在这种情况下插入100w+测试数据没有几天根本跑不下来。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>cordova</title>
        <link>http://www.liuschen.com/2017/07/02/cordova.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/07/02/cordova.html</guid>
        <pubDate>Sun, 02 Jul 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先安装&lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;Node.js&lt;/a&gt;;&lt;/p&gt;

&lt;p&gt;在命令行中安装cordova&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g cordova
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建工程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cordova create hello com.example.hello HelloWorld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完这一步，会在当前目录之下生成一个hello文件夹，文件夹内目录结构:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--hooks(文件夹)
--platforms(空文件夹)
--plugins(空文件夹)
--www(存放网页js代码)
-config.xml(配置文件)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入目录并添加打包平台&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd hello
cordova platform add ios --save
cordova platform add android --save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加平台时可以指定版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cordova platform add android@5.1 --save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时在platforms(空文件夹)和plugins(空文件夹)下都会生成相应内容，如果后面加–save则会在config.xml中添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;engine name=&quot;android&quot; spec=&quot;~5.1.1&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令文档cordova platform –help&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Synopsis

    cordova platform &amp;lt;command&amp;gt; [options]

Manage project platforms

    add &amp;lt;plat-spec&amp;gt; [...].............. Add specified platforms
        --save ........................ Save specified platforms into config.xml after installing them

        --link ........................ When &amp;lt;plat-spec&amp;gt; is a local path, links the platform
                                        library directly instead of making a copy of it (support
                                        varies by platform; useful for platform development)

        --fetch ....................... Fetches the plugin into the project&#39;s node_modules directory.
                                        Uses `npm install` to do the fetching.




    remove &amp;lt;platform&amp;gt; [...] ........... Remove specified platforms
        --save ........................ Delete specified platforms from config.xml after removing them
        --fetch ....................... Removes the plugin from the project&#39;s node_modules directory.
                                        Runs `npm uninstall` under the hood.


    update &amp;lt;plat-spec&amp;gt; ................ Update the version of Cordova used for a specific platform;
                                        update to the latest &amp;lt;version&amp;gt; if no &amp;lt;plat-spec&amp;gt; is specified

        --save ........................ Save the latest versions for specified platforms into config.xml

        --fetch ....................... Fetches the plugin into the project&#39;s node_modules directory.
                                        Uses `npm install` to do the fetching.

    list .............................. List all installed and available platforms
    check ............................. List platforms which can be updated by `cordova platform update`
    save .............................. Save version of all platforms added to config.xml


Syntax
    &amp;lt;plat-spec&amp;gt; : &amp;lt;platform&amp;gt;[@&amp;lt;version&amp;gt;]|&amp;lt;path&amp;gt;|&amp;lt;url&amp;gt;[#&amp;lt;commit-ish&amp;gt;]

    &amp;lt;platform&amp;gt; ........................ Platform name e.g. android, ios, windows etc.
    &amp;lt;version&amp;gt; ......................... Major.minor.patch version specifier using semver
    &amp;lt;path&amp;gt; ............................ Path to a directory containing a platform
    &amp;lt;url&amp;gt; ............................. Url to a git repository containing a platform
    &amp;lt;commit-ish&amp;gt; ...................... Commit/tag/bramch reference. If none is specified, &#39;master&#39; is used

Aliases
    platforms -&amp;gt; platform
    rm -&amp;gt; remove
    ls -&amp;gt; list

Examples
    cordova platform add android ios --save
    cordova platform add android@^5.0.0 --save
    cordova platform add https://github.com/myfork/cordova-android.git#4.0.0 --save
    cordova platform add ../android --save
    cordova platform add ../cordova-android.tgz --save
    cordova platform rm android --save
    cordova platform ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置环境变量ANDROID_HOME(SDK路径)和JAVA_HOME(JDK路径)&lt;/p&gt;

&lt;p&gt;查看环境需求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cordova requirements
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cordova build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译过程，如果选择新版本本地没有相关资源会自动下载，编译后会在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/platforms/android/build/outputs/apk/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目录下生成android版的app&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Kotlin笔记</title>
        <link>http://www.liuschen.com/2017/06/08/kotlin.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/06/08/kotlin.html</guid>
        <pubDate>Thu, 08 Jun 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;初次尝试，安装了IntelliJ IDEA&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;新建Kotlin JVM项目,新建包并新建main.kt&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//sampleStart
fun printSum(a: Int, b: Int): Unit {
    println(&quot;sum of $a and $b is ${a + b}&quot;)
}
//sampleEnd

fun main(args: Array&amp;lt;String&amp;gt;) {
    printSum(-1, 8)
}

fun maxOf(a: Int, b: Int): Int {
    if (a &amp;gt; b) {
        return a
    } else {
        return b
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可见，函数的关键字区别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:fun&lt;/li&gt;
  &lt;li&gt;Python:def&lt;/li&gt;
  &lt;li&gt;Java :没有，直接函数名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;函数参数和返回值：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:类型都放在后面，如参数args: Array&lt;string&gt;类型在参数后面，“：”隔开&lt;/string&gt;&lt;/li&gt;
  &lt;li&gt;Python:没有类型，直接交给程序自己判断&lt;/li&gt;
  &lt;li&gt;Java :类型在前，参数在后&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;返回值为空：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:Unit&lt;/li&gt;
  &lt;li&gt;Python:返回值类型是程序判断，不需要声明&lt;/li&gt;
  &lt;li&gt;Java :void&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出语句的不同:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Kotlin:println,可以直接在$后引用变量，如下：&lt;/p&gt;

    &lt;p&gt;fun printSum(a: Int, b: Int) {&lt;br /&gt;
      println(“sum of $a and $b is ${a + b}”)&lt;br /&gt;
  }&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Python:print,通过占位符引入变量，中间由“%”隔开&lt;/li&gt;
  &lt;li&gt;Java :直接通过“+”来拼接字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变量的声明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:val关键字用来定义只读的局部变量，var用来定义可变变量&lt;/li&gt;
  &lt;li&gt;Python:变量不需要声明，自动判断类型&lt;/li&gt;
  &lt;li&gt;Java :变量需要声明，而且有些时候必须有初始值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kotlin中，写法有点像Python，每句程序的结尾不需要写“;”,通过换行符来区分语句。&lt;br /&gt;
但是python中制表符和空格是会区分开，写程序时如果混用是可能会出错的，KotLin&lt;br /&gt;
目前还没有这种尝试，不知会不会一样。&lt;/p&gt;

&lt;p&gt;Kotlin中的条件语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和java一样，而Python则是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if 条件表达式:
	条件语句
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完全是用过换行与缩进来完成语句的书写的。&lt;/p&gt;

&lt;p&gt;Kotlin新定义了一个？，如Int?表示声明的这个类型值可以为null,这个值可以是返回值，也可以为声明的变量。&lt;/p&gt;

&lt;p&gt;java中的instanceof用来判断一个对象是否是一个类的实例，Kotlin直接用“is”来代替，简单直观。如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换。如（看来obj会在obj is String为true时自动转化为String类型）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun getStringLength(obj: Any): Int? {
    if (obj is String) {
        // `obj` 在该条件分支内自动转换成 `String`
        return obj.length
    }
    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型
    return null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for循环：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kotlin:for(obj in list){}&lt;/li&gt;
  &lt;li&gt;Python:for obj in list:&lt;/li&gt;
  &lt;li&gt;Java :for(Obj obj:list){}//高级for&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kotlin中的when表达式同Java中的不同，更像是Java中的switch语句（其中的函数赋值也同js中的语法很像，但js是弱类型的脚本语言，而Kotlin是同Java一样的强类型的高级编程语言）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun describe(obj: Any): String =
when (obj) {
    1          -&amp;gt; &quot;One&quot;
    &quot;Hello&quot;    -&amp;gt; &quot;Greeting&quot;
    is Long    -&amp;gt; &quot;Long&quot;
    !is String -&amp;gt; &quot;Not a string&quot;
    else       -&amp;gt; &quot;Unknown&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python能够通过for循环直接遍历字符串，Kotlin不能，但是Kotlin中的区间比Python表达的更简洁:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (x in 1..y+1) {
    println(&quot;fits in range&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检测数字在区间之外用“!in”：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (-1 !in 0..list.lastIndex) {
    println(&quot;-1 is out of range&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;倒序遍历:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (i in 4 downTo 1) print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;步长为2的遍历:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (i in 1..4 step 2) print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要创建一个不包括其结束元素的区间:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (i in 1 until 10) {   // i in [1, 10) 排除了 10
 	println(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在Python遍历区间:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in range(1,99):
	print &quot;%d&quot; % i
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>python笔记2</title>
        <link>http://www.liuschen.com/2017/05/20/Python2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/05/20/Python2.html</guid>
        <pubDate>Sat, 20 May 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;1.安装工具包&lt;/h1&gt;

&lt;p&gt;需要安装pandas_datareader和pandas&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install pandas
pip install pandas_datareader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是会出现错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ImportError: cannot import name PandasError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决办法是更换pandas的版本，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -U pandas==0.19.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换掉了我已经安装的0.20.1版本&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;2.股票代码含义&lt;/h1&gt;

&lt;p&gt;沪市A股票买卖的代码是以600、601或603打头&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;3.爬虫&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html&quot;&gt;BeautifulSoup文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装BeautifulSoup用来解析xml/Html文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install beautifulsoup4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引入项目：from bs4 import BeautifulSoup，使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;soup = BeautifulSoup(getHtml(dstUrl), &#39;html.parser&#39;, from_encoding=&#39;utf-8&#39;)
print soup.find_all(&#39;title&#39;)

soup.find_all(&quot;title&quot;)
# [&amp;lt;title&amp;gt;The Dormouse&#39;s story&amp;lt;/title&amp;gt;]

soup.find_all(&quot;p&quot;, &quot;title&quot;)
# [&amp;lt;p class=&quot;title&quot;&amp;gt;&amp;lt;b&amp;gt;The Dormouse&#39;s story&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;]

soup.find_all(&quot;a&quot;)
# [&amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&amp;gt;Elsie&amp;lt;/a&amp;gt;,
#  &amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt;,
#  &amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;]

soup.find_all(id=&quot;link2&quot;)
# [&amp;lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt;]

import re
soup.find(text=re.compile(&quot;sisters&quot;))

data_soup.find_all(attrs={&quot;data-foo&quot;: &quot;value&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过find_all得到的列表中的HTML段都可以再次应用find,find_all过滤&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;4.数据库通信乱码&lt;/h1&gt;

&lt;p&gt;将爬到的数据写入数据库中，发现有几处编码格式会产生影响：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;py文件编码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;window系统，所以是ascii&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;系统编码&lt;/p&gt;

    &lt;p&gt;import sys&lt;br /&gt;
 reload(sys)&lt;br /&gt;
 sys.setdefaultencoding(‘gbk’)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;连接数据库的编码&lt;/p&gt;

    &lt;p&gt;db = MySQLdb.connect(“ip”,”user”,”pwd”,”house_msg”,charset=”gbk”)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写入字符的编码&lt;/p&gt;

    &lt;p&gt;soup = BeautifulSoup(getHtml(dstUrl), ‘html.parser’, from_encoding=’utf-8’)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库本身的字符集编码&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一开始我将所有都改为utf-8格式（为了适应数据库），但是发现py文件本身是ascii编码格式，根本不能写入数据库，即使将当前文件编码改为utf-8，它的引用文件依然会报这个错误，于是将系统编码改为gbk,可写入，但毫无疑问，数据库中表出现了乱码。最好智能将系统编码和连接数据库的编码以及数据库本身的字符集编码都改为了gbk,乱码问题才解决。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;异常：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;UnicodeEncodeError: &#39;gbk&#39; codec can&#39;t encode character u&#39;\xa0&#39; in position 208: illegal multibyte sequence
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python操作数据库写入时，字符串数据中如果有u’\xa0’将不能正确转码，需要string.replace(u’\xa0’,u’‘)替换掉&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Retrofit浅析-OkHttp-rxjava</title>
        <link>http://www.liuschen.com/2017/05/06/retrofit.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/05/06/retrofit.html</guid>
        <pubDate>Sat, 06 May 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;retrofit-okhttp-rxjava&quot;&gt;1.Retrofit-OkHttp-rxjava&lt;/h1&gt;

&lt;p&gt;首先，主体是retrofit，这种配置低耦合，通过converter来连接模块，retrofit2的连接模块有如下(在studio的仓库中搜索到的最新版本)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.squareup.retrofit2:converter-moshi:2.3.0
com.squareup.retrofit2:converter-scalars:2.3.0
com.squareup.retrofit2:converter-simplexml:2.3.0
com.squareup.retrofit2:converter-wire:2.3.0
com.squareup.retrofit2:converter-java8:2.3.0
com.squareup.retrofit2:converter-jackson:2.3.0
com.squareup.retrofit2:converter-protobuf:2.3.0
com.squareup.retrofit2:converter-guava:2.3.0
com.squareup.retrofit2:converter-gson:2.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同rxjava适配需要导入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.squareup.retrofit2:adapter-rxjava:2.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt;2.资源拦截器&lt;/h1&gt;

&lt;p&gt;BasicParamsInterceptor:这是一个独立的类，github上作者项目:&lt;a href=&quot;https://github.com/jkyeo/okhttp-basicparamsinterceptor&quot;&gt;https://github.com/jkyeo/okhttp-basicparamsinterceptor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用来向请求添加公共的参数，但是实际用，可能是因为一个独立文件，并不好使，没细究。&lt;/p&gt;

&lt;p&gt;因为就是一个普通的拦截器，完全可以自己定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OkHttpClient.Builder builder = new OkHttpClient.Builder();
   		builder.connectTimeout(30, TimeUnit.SECONDS);//连接超时时间
    builder.writeTimeout(30, TimeUnit.SECONDS);//写操作 超时时间
    builder.readTimeout(30, TimeUnit.SECONDS);//读操作超时时间
    builder.interceptors().add(new MyInterceptor());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拦截器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyInterceptor implements okhttp3.Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request.Builder builder = chain.request().newBuilder();
		/**为请求添加头*/
        Request requst = builder.addHeader(&quot;Content-type&quot;, &quot;application/json&quot;).build();
        return chain.proceed(requst);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;retrofit&quot;&gt;3.Retrofit使用&lt;/h1&gt;

&lt;p&gt;基础版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Retrofit retrofit = new Retrofit.Builder()
//加入OkHttpClient.Builder支持，这个是内部默认的，默认使用OkHttpClient
            .client(builder.build())
//加入基本url,最好如此，只到端口，后面‘/不能少’
            .baseUrl(&quot;http://192.168.24.76:8080/&quot;)
            .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;升级版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Retrofit retrofit = new Retrofit.Builder()
//加入OkHttpClient.Builder支持，这个是内部默认的，默认使用OkHttpClient
            .client(builder.build())
//加入字符串支持
            .addConverterFactory(ScalarsConverterFactory.create())
//加入gson支持
            .addConverterFactory(GsonConverterFactory.create())
//加入rxJava2支持
            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
//加入基本url,最好如此，只到端口，后面‘/不能少’
            .baseUrl(&quot;http://192.168.24.76:8080/&quot;)
            .build();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;model&quot;&gt;4.请求model&lt;/h1&gt;

&lt;p&gt;Retrofit的参数是通过一个接口的注解来标明，用Java的动态代理来将参数传递进去，很巧妙将参数的定义和参数分开，简化了可见的代码，如下是定义的接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface BlogService {
    @FormUrlEncoded
    @POST(&quot;AndroidService/{id}/android_msg!androidMsg.action&quot;)
    Call&amp;lt;ResponseBody&amp;gt; getBlog(@Path(&quot;id&quot;) int id, @Query(&quot;name&quot;) int name, @Field(&quot;page&quot;) int page);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先知道，post请求方式和get请求方式不同，post是将参数单独编码传递，在URL中是不可见的&lt;/p&gt;

&lt;p&gt;@FormUrlEncoded 和@POST以及参数注解中的@Field是用于定义POST的单独参数编码的，@FormUrlEncoded 和@Field相互依赖，必须同时存在且只能在@POST时才能存在&lt;/p&gt;

&lt;p&gt;@Query定义的是URL中附带的可见参数注解中的是key,参数表示的是value&lt;/p&gt;

&lt;p&gt;发出请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BlogService service = retrofit.create(BlogService.class);
    Call&amp;lt;ResponseBody&amp;gt; call = service.getBlog(2,3,9);
    call.enqueue(new Callback&amp;lt;ResponseBody&amp;gt;() {
        @Override
        public void onResponse(Call&amp;lt;ResponseBody&amp;gt; call, Response&amp;lt;ResponseBody&amp;gt; response) {
            try {
                System.out.println(&quot;成功1:&quot;+new String(response.body().bytes(),&quot;utf-8&quot;));
            } catch (IOException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;成功1.2:&quot;+response.body().contentType());
            System.out.println(&quot;成功1.5:&quot;+response.body().contentLength());
            System.out.println(&quot;成功2:&quot;+response.message());
            System.out.println(&quot;成功3:&quot;+response.toString());
            System.out.println(&quot;成功4:&quot;+response.headers().toString());
            System.out.println(&quot;成功5:&quot;+response.code());
            System.out.println(&quot;成功6:&quot;+response.isSuccessful());
            System.out.println(&quot;成功7:&quot;+response.raw());
        }
        @Override
        public void onFailure(Call&amp;lt;ResponseBody&amp;gt; call, Throwable t) {
            System.out.println(&quot;失败：&quot;+t.toString());
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中可见ResponseBody是一个基础的返回对象，包含了很多东西，以下是测试返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;成功1:{&quot;message&quot;:&quot;success&quot;,&quot;success&quot;:true}
成功1.2:application/json;charset=UTF-8
成功1.5:-1
成功2:OK
成功3:Response{protocol=http/1.1, code=200, message=OK, url=http://192.168.24.76:8080/AndroidService/2/android_msg!androidMsg.action?name=3}
成功4:Server: Apache-Coyote/1.1
 Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
 Date: Tue, 23 May 2017 06:55:27 GMT
成功5:200
成功6:true
成功7:Response{protocol=http/1.1, code=200, message=OK, url=http://192.168.24.76:8080/AndroidService/2/android_msg!androidMsg.action?name=3}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;5.可插拔的的数据转换支持&lt;/h1&gt;

&lt;p&gt;gson支持，当然，需要相应的jar包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addConverterFactory(GsonConverterFactory.create())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将ResponseBody替换成自己定义的返回对象MyResultBean，就会自动解析，不添加上面支持的话会报错（直接down掉）；&lt;/p&gt;

&lt;p&gt;String字符串支持,当然，也需要相应的jar包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.addConverterFactory(ScalarsConverterFactory.create())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将ResponseBody替换成自己定义的返回对象String，就会自动解析，不添加上面支持的话会报错(会走失败的方法):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;失败：java.lang.IllegalStateException: Expected a string but was BEGIN_OBJECT at line 1 column 2 path $
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;rxjava2&quot;&gt;6.RxJava2支持&lt;/h1&gt;

&lt;p&gt;RxJava2是响应式编程框架，因为在Android开发中，请求网络只能在子线程，绘制界面只能在主线程，所以有些操作就需要分开来执行，AsyncTask就是一种解决方案。&lt;/p&gt;

&lt;p&gt;call是retrofit返回的对象，其中的回调方法都是在主线程中执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;call.enqueue(new Callback&amp;lt;String&amp;gt;() {
        @Override
        public void onResponse(Call&amp;lt;String&amp;gt; call, Response&amp;lt;String&amp;gt; response) {
        }
        @Override
        public void onFailure(Call&amp;lt;String&amp;gt; call, Throwable t) {
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加rxjava2支持，将可以把返回对象由原来的call变为Observable，Observable订阅线程执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;observable.subscribeOn(Schedulers.from(Executors.newFixedThreadPool(10)))
            .subscribe(new Observer&amp;lt;String&amp;gt;() {
                @Override
                public void onSubscribe(Disposable d) {

                    System.out.println(&quot;resultBean:&quot;);
                    System.out.println(&quot;当前所在线程为onResponse:&quot;+Thread.currentThread().getName());
                }

                @Override
                public void onNext(String value) {
                    System.out.println(&quot;resultBean:&quot;+value);
                    System.out.println(&quot;当前所在线程为onResponse:&quot;+Thread.currentThread().getName());
                }

                @Override
                public void onError(Throwable e) {
                    System.out.println(&quot;resultBean:&quot;+e.toString());
                    System.out.println(&quot;当前所在线程为onResponse:&quot;+Thread.currentThread().getName());
                }

                @Override
                public void onComplete() {
                    System.out.println(&quot;resultBean:onComplete&quot;);
                    System.out.println(&quot;当前所在线程为onResponse:&quot;+Thread.currentThread().getName());
                }
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中onSubscribe方法在所有方法之前执行，甚至在Okhttp的拦截器之前执行，运行在主线程&lt;/p&gt;

&lt;p&gt;onNext和onerror,onComplete运行在订阅的线程，subscribeOn的传入对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//订阅线程传入的是一个10线程的线程池
Schedulers.from(Executors.newFixedThreadPool(10))
//订阅线程是新开一个线程
Schedulers.newThread()	
/**
订阅线程做io操作，也是新线程，I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。
*/
Schedulers.io()
/**
计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。
*/
Schedulers.computation()
//独立线程：RxSingleScheduler-1
Schedulers.single()
//主线程，会报异常：android.os.NetworkOnMainThreadException
Schedulers.trampoline()
/***/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，如果想要返回的结果在主线程中，就直接用返回的call,如果希望返回的结果订阅在特定子线程，就返回observable对象来使用，rxjava与retrofit结合，observable是被创造好的，不需要重新create，消息也都给定了，只需要定义要发布的线程即可。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>python笔记1</title>
        <link>http://www.liuschen.com/2017/04/25/python.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/04/25/python.html</guid>
        <pubDate>Tue, 25 Apr 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;python语言接近于自然语言，基本语法逻辑和其他语言一样，只是一些小的细节不同，python2.x和python3.x的一些函数也有一些细节的不同。&lt;a href=&quot;http://www.runoob.com/python/&quot;&gt;python2的教程&lt;/a&gt;而我首先用的是python3,所以主要记录一下不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;python3python2&quot;&gt;1.python3和python2差异&lt;/h2&gt;

&lt;p&gt;python3中print后面字符串需要加()&lt;/p&gt;

&lt;p&gt;urllib分为了若干模块，需要分别引用&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2.安装下载&lt;/h2&gt;

&lt;p&gt;选择下载安装最好选择32位的2.x版的Python，原因如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2.x版的存在时间长，教程比较好找，相关blog也很多&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sourceforge.net/projects/mysql-python/?source=typ_redirect&quot;&gt;连接mysql的数据库引擎&lt;/a&gt;，诸如此类的插件库比较好找,换32位的也是因为64位的这个插件支持不好，因为插件是32位的，我安装的mysql也是32位的，避免麻烦&lt;/li&gt;
  &lt;li&gt;PIL是一个图形处理库，也是win32的和数据库连接引擎安装方式一样&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3.正则表达式&lt;/h2&gt;

&lt;p&gt;python的正则表达式主要有3中判断：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;匹配开始位置，如果不匹配返回none：re.match&lt;/li&gt;
  &lt;li&gt;搜索整个字符串:re.search&lt;/li&gt;
  &lt;li&gt;搜索整个字符串并返回一个list:re.findAll&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正则表达式的字符规则不说了，主要需要注意的方面是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;正则表达式前加一个字符’r’&lt;/li&gt;
  &lt;li&gt;正则可以引号嵌套，同时里面可以添加括号
    &lt;ul&gt;
      &lt;li&gt;一个括号的话，查找返回的是括号内的表达式匹配内容&lt;/li&gt;
      &lt;li&gt;多个括号的话，是返回的一个多维列表，列表中每一个对象是一个元组，元组中是对每一个括号内容匹配到的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mysql&quot;&gt;4.Mysql数据库&lt;/h2&gt;

&lt;p&gt;数据库操作比较固定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import MySQLdb

db = MySQLdb.connect(&quot;127.0.0.1&quot;,&quot;user&quot;,&quot;pwd&quot;,&quot;数据库名&quot; )

# 使用cursor()方法获取操作游标 

cursor = db.cursor()

# SQL 语句
sql = &quot;&quot;

try:
   # 执行sql语句
   cursor.execute(sql)
   # 提交到数据库执行
   db.commit()
except:
   # 发生错误时回滚
   db.rollback()

# 关闭数据库连接
db.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;oracle&quot;&gt;4.5.连接Oracle数据库&lt;/h2&gt;

&lt;p&gt;下载数据库驱动:&lt;a href=&quot;https://pypi.python.org/pypi/cx_Oracle/5.3&quot;&gt;https://pypi.python.org/pypi/cx_Oracle/5.3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意下载的python版本的位数和驱动的位数以及安装的oracle数据库位数要一致&lt;/p&gt;

&lt;p&gt;我在本机安装的oracle是64位的，而驱动和python都是32位的，所以总是提示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import cx_Oracle
ImportError: DLL load failed: %1 不是有效的 Win32 应用程序。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后搜索下载一个32位的oci.dll放在python\Lib\site-packages下，问题解决。应该是数据库驱动会访问本机中的oci.dll，一般搜索都会在环境变量目录中和本目录中寻找，python\Lib\site-packages是插件安装目录，所以放在该目录下能被顺利访问到。但是又出现另一个问题，运行到调用数据库的程序会报：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cx_Oracle.InterfaceError: Unable to acquire Oracle environment handle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的处理方法是下载instantclient-basic-win32-11.2.0.1.0.zip，这个是连接数据库的客户端，一定要32位的，不然就没意义了。&lt;br /&gt;
然后拷贝其中的oci.dll, oraociei10.dll, oraocci10.dll到site-package中，当然oci.dll要覆盖之前添加的，因为要保证版本一致才行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db=cx_Oracle.connect(&#39;username&#39;,&#39;password&#39;,&#39;127.0.0.1/orcl&#39;,cx_Oracle.SYSDBA)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始IP的部分用的是本机的IP地址，但是却会报异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cx_Oracle.DatabaseError: ORA-12541: TNS:no listener
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将IP地址改为127.0.0.1能正常访问。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;5.常见错误(注意问题)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;IndentationError: unindent does not match any outer indentation level&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面的空格和制表符不能混用，否则就会出现这类问题，写程序时最好将空白的符号显示出来&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;格式化输出字符串”%s”%x,字符串和实际值用%隔开&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AttributeError: ‘module’ object has no attribute ‘XXX’&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;.pyc是Python的字节码文件，如果新建.py文件时，不要与预留关键字和模块名重复，否则引用就有可能出现问题，实际调用的是.pyc文件，所以解决办法将目录中与模块名重复的.py文件重新命名，并且删除生成的.pyc文件，重新编译即可&lt;br /&gt;
* url中带有‘,’的图片urlretrieve下载不了&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;6.多线程使用&lt;/h2&gt;

&lt;p&gt;基础用thread&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;thread.start_new_thread
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用thread的包装threading&lt;/p&gt;

&lt;p&gt;以上两个都是包里面自带的，还可以使用线程池&lt;/p&gt;

&lt;p&gt;python安装目录下有一个script文件夹，里面有包管理工具pip,可以运行如pip install threadpool安装线程池模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;task_pool = threadpool.ThreadPool(10,10,0,10)
param_list = [(({param1:param1},{param2:param2}))]
	requests = threadpool.makeRequests(线程函数, param_list)
	[task_pool.putRequest(req) for req in requests]
task_pool.wait()

def 线程函数(param1,param2):
	return;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接在主线程中是取不到全局定义的变量的，因为语法原因会被作为新的局部变量，所以如果要在子线程中取全局变量需要在其作用域中加全局声明 global，如要用全局变量context,就需要先&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global Context
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;scrapy&quot;&gt;7.使用Scrapy爬网页&lt;/h2&gt;

&lt;p&gt;安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install Scrapy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完后会有提示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;----------------------------------------
Command &quot;f:\programer2\python27\python.exe -u -c &quot;import setuptools, tokenize;__file__=&#39;c:\\users\\XXX\\appdata\\local
\\temp\\pip-build-98jdcm\\Twisted\\setup.py&#39;;f=getattr(tokenize, &#39;open&#39;, open)(__file__);code=f.read().replace(&#39;\r\n&#39;, &#39;
\n&#39;);f.close();exec(compile(code, __file__, &#39;exec&#39;))&quot; install --record c:\users\luofe\appdata\local\temp\pip-j9ztlc-reco
rd\install-record.txt --single-version-externally-managed --compile&quot; failed with error code 1 in c:\users\luofe\appdata\
local\temp\pip-build-98jdcm\Twisted\
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;似乎是window平台对着个框架有些要求，太麻烦就不配置了，对于我的需求，用多线程自己抓取已经能够满足。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;8.注意&lt;/h2&gt;

&lt;p&gt;空值：None&lt;br /&gt;
空字符：NULL&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;9.图像处理&lt;/h2&gt;

&lt;p&gt;PIL库导入：from PIL import Image, ImageEnhance, ImageDraw,ImageChops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#打开
img = Image.open(&quot;C:\\Users\\luofe\\Pictures\\12.jpg&quot;)
#改变大小
new_img = img.resize((128, 128), Image.BILINEAR) 
#旋转
rot_img = new_img.rotate(45)
#显示
img.show()
#保存
img.save(&quot;name&quot;,&quot;格式&quot;)
#获取尺寸
width, height = img.size  
#绘图，单独开一个图层
draw = ImageDraw.Draw(img)  
draw.line( ( (0,0), (width-1, height-1)), fill=255)
#各种效果
color = ImageEnhance.Color(img)  
color_img = color.enhance(3.0)

sharpness = ImageEnhance.Sharpness(img)  
sharp_img = sharpness.enhance(7.0)

contrast = ImageEnhance.Contrast(img)  
contrast_img = contrast.enhance(2.0)  

brightness = ImageEnhance.Brightness(img)  
bright_img = brightness.enhance(2.0) 

#反相
invert_img = ImageChops.invert(img)
#混合模式，需要两张图
#lighter_image = ImageChops.lighter(image1, image2)
#darker_image = ImageChops.darker(image1, image2)
#difference_image = ImageChops.difference(image1, image2) 
#multiply_image = ImageChops.multiply(image1, image2)
#screen_image = ImageChops.screen(image1, image2)  
#add_image = ImageChops.add(img1, img2, scale, offset)    
#subtract_image = ImageChops.subtract(img1, img2, scale, offset)

#获取像素点
point = img.getpixel((pXX,pYY))
#设置像素点
img.putpixel((pXX,pYY),point)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jupyter-notebook&quot;&gt;10.jupyter notebook&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过pip install jupyter来安装，提示血少C++库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;running install
running build
running build_py
creating build
creating build\lib.win32-2.7
copying scandir.py -&amp;gt; build\lib.win32-2.7
running build_ext
building &#39;_scandir&#39; extension
error: Microsoft Visual C++ 9.0 is required. Get it from http://aka.ms/vcpython27
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载VCForPython27.msi，安装，然后重试，安装成功&lt;/p&gt;

&lt;p&gt;将命令路径添加到环境变量后在cmd窗口键入命令：jupyter notebook，启动会打开一个浏览器文本编辑器，在文本编辑器中可以直接执行代码并生成结果。&lt;/p&gt;

&lt;h2 id=&quot;pythoncaffe&quot;&gt;11.Python与caffe结合&lt;/h2&gt;

&lt;p&gt;下载的caffe是for window版本的，首先，解压，进入目录下Python文件夹中，查看requirement.txt文件夹，根据内容安装依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#和c语言沟通，可以将Python编译成c语言模块使用
Cython&amp;gt;=0.19.2
#Python的一种开源的数值计算扩展，有matlabd的一些功能
numpy&amp;gt;=1.7.1
#也是一种数字计算库
scipy&amp;gt;=0.13.2
#一组用于图像处理的算法的集合，是Python下的一种图形库
scikit-image&amp;gt;=0.9.3
#是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。有点类似MATLAB中的统计图。
matplotlib&amp;gt;=1.3.1
#一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。
ipython&amp;gt;=3.0.0
#HDF5持久化存储的Python版本
h5py&amp;gt;=2.2.0
#一个键值对数据库
leveldb&amp;gt;=0.191
#NetworkX是一个用Python语言开发的图论与复杂网络建模工具，内置了常用的图与复杂网络分析算法，可以方便的进行复杂网络数据分析、仿真建模等工作。
networkx&amp;gt;=1.8.1
#python测试框架
nose&amp;gt;=1.3.0
#Pandas是python的一个数据分析包
pandas&amp;gt;=0.12.0
#python时间处理工具类
python-dateutil&amp;gt;=1.4,&amp;lt;2
#将文件读取到内存，主要用来读取配置文件
protobuf&amp;gt;=2.5.0
#用来解析命令行参数的库
python-gflags&amp;gt;=2.0
#L是一个Python的YAML解析器
pyyaml&amp;gt;=3.10
#PIL图形库
Pillow&amp;gt;=2.3.0
#画图，数据分析的依赖库
six&amp;gt;=1.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是通过&lt;strong&gt;pip install [soft_name]&lt;/strong&gt;，可以直接执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Freemarker基本使用</title>
        <link>http://www.liuschen.com/2017/04/20/Freemarker.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/04/20/Freemarker.html</guid>
        <pubDate>Thu, 20 Apr 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;freemarker&quot;&gt;Freemarker&lt;/h2&gt;

&lt;p&gt;导入Freemarker的jar包&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;生成Java代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 生成Java代码
 * */
public static void generateJavaCode(){
	

	String templateFile = &quot;src/demo_java.ftl&quot;;
	String targetFile = &quot;src/com/luofeng/Person.java&quot;;
	
	Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();

	map.put(&quot;packageName&quot;, &quot;com.luofeng&quot;);
	map.put(&quot;className&quot;, &quot;Person&quot;);
	map.put(&quot;author&quot;, &quot;luofeng&quot;);

	
    List&amp;lt;Attribute&amp;gt; attr_list = new ArrayList&amp;lt;Attribute&amp;gt;();
    attr_list.add(new Attribute(&quot;id&quot;, &quot;Long&quot;));
    attr_list.add(new Attribute(&quot;name&quot;, &quot;String&quot;));
    attr_list.add(new Attribute(&quot;age&quot;, &quot;Integer&quot;));
    attr_list.add(new Attribute(&quot;hobby&quot;, &quot;List&amp;lt;String&amp;gt;&quot;));

    map.put(&quot;attrs&quot;, attr_list);
    
    Configuration configuration = new Configuration();
	
	try {
		Template template = configuration.getTemplate(templateFile);
		template.setEncoding(&quot;UTF-8&quot;);
		Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(targetFile), &quot;UTF-8&quot;));  
        template.process(map, out);
        out.flush();
        out.close();
	} catch (IOException e) {
		e.printStackTrace();
	} catch (TemplateException e) {
		e.printStackTrace();
	}
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java的ftl模板文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package ${packageName};

import java.util.List;

/**
 *  @author ${author}
 */
public class ${className} {
    &amp;lt;#list attrs as attr&amp;gt; 
    private ${attr.value!&quot;meizhi&quot;} ${attr.name};
    &amp;lt;/#list&amp;gt;

    &amp;lt;#list attrs as attr&amp;gt;
    public void set${attr.name?cap_first}(${attr.value!&quot;meizhi&quot;} ${attr.name}){
        this.${attr.name} = ${attr.name};
    }
    public ${attr.value!&quot;meizhi&quot;} get${attr.name?cap_first}(){
        return this.${attr.name};
    }

    &amp;lt;/#list&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;Welcome ${user!&quot;Anonymous&quot;}!&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以为替换的变量设置默认值，因为变量为空会直接崩溃掉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;#if user??&amp;gt;&amp;lt;h1&amp;gt;Welcome ${user}!&amp;lt;/h1&amp;gt;&amp;lt;/#if&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以判断变量是否存在，不存在的话会忽略掉整个代码段&lt;/p&gt;

&lt;h2 id=&quot;html&quot;&gt;生成Html代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 生成Html代码
 * */
public void generateHtmlCode(){
	String templateFile = &quot;src/demo_html.ftl&quot;;
	String targetFile = &quot;src/html.html&quot;;
	
	Map map = new HashMap&amp;lt;String, String&amp;gt;();
	map.put(&quot;message&quot;, &quot;hello world&quot;);
	map.put(&quot;name&quot;, &quot;java小强&quot;);
	
	Configuration configuration = new Configuration();
	
	try {
		Template template = configuration.getTemplate(templateFile);
		template.setEncoding(&quot;UTF-8&quot;);
		Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(targetFile), &quot;UTF-8&quot;));  
        template.process(map, out);
        out.flush();
        out.close();
	} catch (IOException e) {
		e.printStackTrace();
	} catch (TemplateException e) {
		e.printStackTrace();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的ftl模板&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;  
  &amp;lt;head&amp;gt;  
        &amp;lt;title&amp;gt;freemarker是什么&amp;lt;/title&amp;gt;  
    &amp;lt;/head&amp;gt;  
    &amp;lt;body&amp;gt;  
        &amp;lt;h1&amp;gt;${message},${name}&amp;lt;/h1&amp;gt;  
    &amp;lt;/body&amp;gt;  
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，在代码中我设置的编码格式是UTF-8,但是eclipse默认打开文件的编码格式可能是gbk,如果这个全局值不修改，直接打开生成的文件就会乱码，位置是在：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window-&amp;gt;Preferences-&amp;gt;General-&amp;gt;Workspace-&amp;gt;Text file encoding
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>GIT配置</title>
        <link>http://www.liuschen.com/2017/04/03/git2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/04/03/git2.html</guid>
        <pubDate>Mon, 03 Apr 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一直以来，用git和SVN都是懂得基本操作就行了，会克隆推送提交什么的，一直缺少一个全局性的把握，所以一旦设置出现问题就手足无措，即使知道了解决方法，不常用的知识往往也易于忘记。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;git的配置分为，局部，全局和系统，作用域不同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] name [value [value_regex]]
git config [&amp;lt;file-option&amp;gt;] [type] --add name value
git config [&amp;lt;file-option&amp;gt;] [type] --replace-all name value [value_regex]
git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] --get name [value_regex]
git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] --get-all name [value_regex]
git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] --get-regexp name_regex [value_regex]
git config [&amp;lt;file-option&amp;gt;] [type] [-z|--null] --get-urlmatch name URL
git config [&amp;lt;file-option&amp;gt;] --unset name [value_regex]
git config [&amp;lt;file-option&amp;gt;] --unset-all name [value_regex]
git config [&amp;lt;file-option&amp;gt;] --rename-section old_name new_name
git config [&amp;lt;file-option&amp;gt;] --remove-section name
git config [&amp;lt;file-option&amp;gt;] [-z|--null] -l | --list
git config [&amp;lt;file-option&amp;gt;] --get-color name [default]
git config [&amp;lt;file-option&amp;gt;] --get-colorbool name [stdout-is-tty]
git config [&amp;lt;file-option&amp;gt;] -e | --edit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;file-option&gt;就是作用域&lt;/file-option&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; --global              use global config file（全局）
--system              use system config file（系统）
--local               use repository config file（局部）
-f, --file &amp;lt;file&amp;gt;     use given config file（自定义）
--blob &amp;lt;blob-id&amp;gt;      read config from given blob object（自定义）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;例子&lt;/h3&gt;

&lt;p&gt;1.查看仓库配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config -l[-list]
git config –-local -l
git config –-global -l
git config –-system -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.添加配置(键和值不可缺少)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config –-local --add name value
git config –-global --add name value
git config –-system --add name value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.修改配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config –-local  name value
git config –-global  name value
git config –-system  name value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.删除配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config –-local  --unset name
git config –-global  --unset name
git config –-system  --unset name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候修改的时候会提示找不到修改项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: key does not contain a section: –-global[local]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能是文中”–“字符编码的问题，换一种再试&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我系统上没有配置系统配置，但是按照一般套路应该是：&lt;br /&gt;
&lt;strong&gt;系统配置&amp;gt;全局配置&amp;gt;局部配置&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;所以如果要在不同地址分别配置不同库地址，就不要再设置全局地址，否则会被覆盖（主要是针对图形化的客户端），也比较混乱&lt;/p&gt;
&lt;/blockquote&gt;

</description>
      </item>
    
      <item>
        <title>Android反编译smali文件的修改</title>
        <link>http://www.liuschen.com/2017/03/31/smali.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/31/smali.html</guid>
        <pubDate>Fri, 31 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前提到过Android的反编译，知道了Android的apk反编译后依然是一个完整的项目。资源文件易于修改，不提了，这里主要记录一下smali文件的一些特性和修改方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;smali文件是Dalvik虚拟机的指令码，和汇编文件有点像。&lt;/p&gt;

&lt;p&gt;进入到smali包下面,往往会发现诸如R$id.smali等R$*.smali格式的文件，这是自动生成的R文件，也就是资源映射文件，这些文件一旦编译好都是死的，没法变，所以不到万不得已不要smali码和资源文件一起添加，太麻烦。&lt;/p&gt;

&lt;p&gt;包里面的smali文件都是一个名字可以对应多个文件，这是将写在Java中的内部类拆分的结果。后面用${数字}来区分，也可以是${数字}${数字}表示内部类的内部类，只不过这样增加代码复杂度的写法不多见而已。&lt;/p&gt;

&lt;p&gt;然后就可以修改smali码了，需要注意两点:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;了解指令码的含义（&lt;a href=&quot;http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html&quot;&gt;Dalvik操作指令&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;注意代码中的汉字字符会转成Unicode码，所以添加需要将汉字字符会转成Unicode码(&lt;a href=&quot;http://www.cnblogs.com/mq0036/p/4007452.html&quot;&gt;如何转&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里我主要修改一个Handler的内部，它的头如下，这也是所有内部类的共性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.class L该文件的完整路径名;
.super Landroid/os/Handler(父类);
.source &quot;原始从属的Java类.java&quot;

# annotations
.annotation system Ldalvik/annotation/EnclosingClass;
    value = L该文件原始从属的Java类的完整路径名(在哪个类里面定义就是那个类);
.end annotation

.annotation system Ldalvik/annotation/InnerClass;
    accessFlags = 0x0
    name = null
.end annotation

# instance fields
.field final synthetic this$0:L该文件原始从属的Java类的完整路径名;

# direct methods
.method constructor &amp;lt;init&amp;gt;(L该文件原始从属的Java类的完整路径名;)V
.locals 0

.prologue
.line 1
iput-object p1, p0, L该文件的完整路径名;-&amp;gt;this$0:L该文件原始从属的Java类的完整路径名;

.line 278
invoke-direct {p0}, Landroid/os/Handler;-&amp;gt;&amp;lt;init&amp;gt;()V

return-void
.end method
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能单看没什么用，还是不能理解，就需要自己写些例子，生成apk反编译对比看看，就会发现规律&lt;/p&gt;

&lt;p&gt;.field故名思议就是变量，而且一般是全局的&lt;/p&gt;

&lt;p&gt;.method和end method之间是方法体，.method constructor &lt;init&gt;表示是该handler内部类的构造方法&lt;/init&gt;&lt;/p&gt;

&lt;p&gt;一个字符串常量v2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const-string v2, &quot;SOMETHING&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建一个对象并存到v4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new-instance v4, L对象完整路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法(这个是要结果的):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invoke-virtual {v1, v2}, Ljava/lang/String;-&amp;gt;equals(Ljava/lang/Object;)Z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法后将结果保存到v2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;move-result-object v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法(这个不要结果，是用来初始化v4这个内部类对象的，v6存储的是默认内部类所属外部类对象，v2存储的是外部类的一个final修饰的参数，都不是正经传入的参数，是编译器处理的结果)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invoke-direct {v4, v6, v2}, Lv4存储的实例对应的类的路径;-&amp;gt;&amp;lt;init&amp;gt;(Lv6存储的实例对应的类的路径;Ljava/lang/String;)V
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;重新打包时经常有错误报v数字不在v1-v15范围内(&lt;a href=&quot;http://www.aichengxu.com/other/2553264.htm&quot;&gt;reason&lt;/a&gt;)，又因为v可以反复使用，所以这个应该是如汇编一样是对寄存器的操作，v1-v15表示寄存器，所以只要明白了类是如何取到的，其他的就好理解了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;if结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if-eqz v1, :cond_1
.
.
:cond_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外部的final定义的对象，内部类是如何取到实例的？首先做如下定义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.local v2, &quot;对象名(在Java中自己起的)&quot;:Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用上面的invoke-direct方法将v2塞进去,然后再内部类中的构造方法里就会有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iput-object p2, p0, L该类完整路径名;-&amp;gt;val$对象名:Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在具体方法中会通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iget-object v2, p0, L该类完整路径名;-&amp;gt;val$对象名:Ljava/lang/String;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到该值，即存储在v2中&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是通过查找字符串来定位修改的大致位置的，然后通过if结构的关键字cond来确定最终的修改坐标，比较粗浅，因为关于smali文件我还有许多不明白的地方，日后再有需要再去详细了解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;还有一点，我发现.line {数字}这种似乎只是记录行号，具体作用不明，随便添加删除也看不出影响，所以修改代码时不用考虑就好。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
      </item>
    
      <item>
        <title>Bootstrap</title>
        <link>http://www.liuschen.com/2017/03/28/Bootstrap.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2017/03/28/Bootstrap.html</guid>
        <pubDate>Tue, 28 Mar 2017 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;文章链接:&lt;a href=&quot;http://www.liuschen.com&quot;&gt;http://www.liuschen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://v3.bootcss.com/getting-started/#download&quot;&gt;参考bootstrap起步文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;bootstrap&quot;&gt;下载bootstrap并解压&lt;/h2&gt;

&lt;h2 id=&quot;grunt&quot;&gt;安装编译系统Grunt&lt;/h2&gt;

&lt;p&gt;首先下载并安装 node.js，之前安装cordova时安装过了，省略。&lt;/p&gt;

&lt;p&gt;按装grunt-cli ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入 /bootstrap/ 根目录，然后执行 npm install 命令。npm 将读取 package.json 文件并自动安装此文件中列出的所有被依赖的扩展包。&lt;/p&gt;

&lt;p&gt;如果在安装依赖包或者运行 Grunt 命令时遇到了问题，请首先删除 npm 自动生成的 /node_modules/ 目录，然后，再次运行 npm install 命令（这一步需要翻墙不然会有如下错误）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm ERR! Windows_NT 10.0.14393
npm ERR! argv &quot;F:\\programer2\\nodejs\\node.exe&quot; &quot;F:\\programer2\\nodejs\\node_modules\\npm\\bin\\npm-cli.js&quot; &quot;install&quot;
npm ERR! node v6.10.0
npm ERR! npm  v3.10.10
npm ERR! code ELIFECYCLE

npm ERR! phantomjs@1.9.20 install: `node install.js`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the phantomjs@1.9.20 install script &#39;node install.js&#39;.
npm ERR! Make sure you have the latest version of node.js and npm installed.
npm ERR! If you do, this is most likely a problem with the phantomjs package,
npm ERR! not with npm itself.
npm ERR! Tell the author that this fails on your system:
npm ERR!     node install.js
npm ERR! You can get information on how to open an issue for this project with:
npm ERR!     npm bugs phantomjs
npm ERR! Or if that isn&#39;t available, you can get their info via:
npm ERR!     npm owner ls phantomjs
npm ERR! There is likely additional logging output above.

npm ERR! Please include the following file with any support request:
npm ERR!     F:\programer2\bootstrap\bootstrap-3.3.7\npm-debug.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grunt命令运行却没问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt dist （仅编译 CSS 和 JavaScript 文件）
grunt watch （监测文件的改变，并运行指定的 Grunt 任务）
grunt test （运行测试用例）
grunt docs （编译并测试文档中的资源文件）
grunt （重新构建所有内容并运行测试用例）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以编译javascript和css,文件夹下dest文件夹为生成的直接可以在生产环境中使用的js和css代码&lt;/p&gt;

&lt;p&gt;当然，这个dest文件夹里面的内容也可以直接在官网上下载。&lt;/p&gt;

&lt;h2 id=&quot;bootstrap-1&quot;&gt;bootstrap基本模板&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
    &amp;lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&amp;gt;
    &amp;lt;title&amp;gt;Bootstrap 101 Template&amp;lt;/title&amp;gt;

    &amp;lt;!-- Bootstrap --&amp;gt;
    &amp;lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;

    &amp;lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&amp;gt;
    &amp;lt;!-- WARNING: Respond.js doesn&#39;t work if you view the page via file:// --&amp;gt;
    &amp;lt;!--[if lt IE 9]&amp;gt;
      &amp;lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;![endif]--&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;

    &amp;lt;!-- jQuery (necessary for Bootstrap&#39;s JavaScript plugins) --&amp;gt;
    &amp;lt;script src=&quot;js/jquery-3.2.0.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;!-- Include all compiled plugins (below), or include individual files as needed --&amp;gt;
    &amp;lt;script src=&quot;js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bootstrap-2&quot;&gt;bootstrap控件实例学习&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://v3.bootcss.com/components/&quot;&gt;参考中文文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;学习最方便的途径就是做自己的东西，所以我这里写一个介绍某某平台产品的页面&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/bootstrap.html&quot;&gt;例子URL&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;bootstrap-3&quot;&gt;为什么需要编译bootstrap&lt;/h2&gt;

&lt;p&gt;我们知道，js和css和Java代码不同是不需要编译的，但是bootstrap的编译主要是为了生成javascript和css代码；存储bootstrap样式的代码主要写在less中，通过编译可以生成对应的css代码，从而使更改样式变得简单。&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>