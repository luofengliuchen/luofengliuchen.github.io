<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>落风的博客</title>
    <link>http://www.liuschen.com</link>
    <description>落风的博客</description>
    
      <item>
        <title>android反编译</title>
        <link>http://www.liuschen.com/2016/02/14/apk.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/14/apk.html</guid>
        <pubDate>Sun, 14 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;android程序是apk格式，其实就是一个压缩包，可以直接解压，但是直接解压后可以直接得到资源文件，以及c的动态链接库，但是打开布局文件却是乱码，并且没有的到直接可读的java源码，所以需要用到反编译相关的软件，而android逆向助手就是一个整合了多个反编译工具的软件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog-apk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，反编译apk和反编译dex直接提取的都是smali格式的文件&lt;/p&gt;

&lt;h3 id=&quot;androidjava&quot;&gt;获得android程序源码中java格式的源码：&lt;/h3&gt;
&lt;p&gt;通过dex转成jar格式   通过js-gui可以直接读取其中的内容，如果里面代码经过了混淆，则被混淆过的代码名称均用无意义的英文字母来命名，因为更改了名称，所以该部分代码不能用到反射。&lt;/p&gt;

&lt;h3 id=&quot;androidxml&quot;&gt;获得android程序源码中的xml文件：&lt;/h3&gt;

&lt;p&gt;反编译apk中就能获得xml文件用的APKTool工具&lt;br /&gt;
没有说明出错了, apktool.jar版本没更，跟不上android的版本&lt;br /&gt;
直接替换反编译却又不能出结果&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;结果：&lt;/h3&gt;

&lt;p&gt;直接用里面的apktool d 文件 来解析xml文件&lt;br /&gt;
用完整工具可以解析src中的Java文件&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>html5内嵌入android</title>
        <link>http://www.liuschen.com/2016/02/05/html5-2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/05/html5-2.html</guid>
        <pubDate>Fri, 05 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;首先Android的目录中建立一个assets文件夹，将canvas.html文件放入其中，然后添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	WebView webview = (WebView) findViewById(R.id.wv);
    webview.getSettings().setJavaScriptEnabled(true);
    webview.setBackgroundColor(Color.TRANSPARENT);
    webview.loadUrl(&quot;file:///android_asset/canvas2.html&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地也需要加入权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以在就可以写一些js代码来嵌入Android应用，所以我又写了一个简单的loading用来做嵌入Android的测试；&lt;/p&gt;

&lt;p&gt;loading本来是想做的像玉器一样的，但是太耗费时间，所以配色上可能不太理想。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/loading.html&quot;&gt;loading动画&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>HTML5绘图学习记录</title>
        <link>http://www.liuschen.com/2016/02/04/html5-1.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/04/html5-1.html</guid>
        <pubDate>Thu, 04 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;首先先要导入jquery.min.js&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1.绘制矩形，线条，圆形&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//获取canvas对象
var canvas  = $(&quot;#mycanvas&quot;);
//的到2D context
var context = canvas.get(0).getContext(&quot;2d&quot;);

//矩形
context.fillStyle = &quot;rgb(255,0,0)&quot;;
context.strokeStyle = &quot;rgb(0,255,0)&quot;;
context.fillRect(40,40,100,100);
context.strokeRect(140,140,100,100);

//直线
context.beginPath();
context.moveTo(240,240);
context.lineTo(600,500);
context.closePath();
context.stroke();

//绘制圆形
context.beginPath();
context.arc(500,500,50,0,Math.PI/2,false);
context.lineTo(500,500);
context.closePath();
context.stroke();

//绘制字体
var text  = &quot;this is html5&quot;;
context.font = &quot;italic 30px serif&quot;;
context.fillText(text,40,300);	
context.lineWidth = 1;
context.strokeText(text,40,400);

//擦除操作
context.clearRect(200,200,100,100);

//擦除操作
context.clearRect(200,200,100,100);
//context.clearRect(0,0,canvas.width(),canvas.height());

//重置所有canvas上的元素
canvas.attr(&quot;width&quot;,canvas.width());
canvas.attr(&quot;height&quot;,canvas.height());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/canvas.html&quot;&gt;HTML5练习1&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.绘图状态的保存，画布变换，阴影，渐变和贝塞尔曲线&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;保存和应用就是一个对栈进行存取的操作，存的是画布的状态信息，如颜色，阴影，变换信息等等，先进后出，后进先出&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;context.save();
context.restore();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;变换，对画布的操作，只对之后绘制的图形产生影响，可以把画布当成有多个图层，每次绘制都会新开一个图层，而变换就是对之后新开图层产生影响，绘制目标完后可以对画布进行还原&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//平移
context.translate(100,100);
//缩放，注意缩放中心
context.scale(1,1.5);
//缩放，注意旋转中心
context.rotate(Math.PI/12);

//全局阿尔法值
context.globalAlpha = 0.5;
//合成模式，PS上的混合模式
context.globalCompositeOperation = &quot;xor&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;渐变的应用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//线性渐变
context.restore();
var gradient = context.createLinearGradient(0,0,0,canvas.height());
gradient.addColorStop(0,&quot;rgb(0,0,0)&quot;);
gradient.addColorStop(1,&quot;rgb(255,0,0)&quot;);
context.fillStyle = gradient;
context.fillRect(100,100,100,100);

//放射渐变
var canvasCentreX = canvas.width()/2;
var canvasCentreY = canvas.height()/2;
var gradient = context.createRadialGradient(canvasCentreX,canvasCentreY,0,canvasCentreX,canvasCentreY,250);
gradient.addColorStop(0,&quot;rgb(0,0,0)&quot;);
gradient.addColorStop(1,&quot;rgb(150,150,150)&quot;);
context.fillStyle = gradient;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;贝塞尔曲线&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//一阶贝塞尔曲线
context.lineWidth = 15;
context.beginPath();
context.moveTo(200,200);
context.quadraticCurveTo(350,200,450,450);
context.stroke();
//三阶贝塞尔曲线
context.lineWidth = 15;
context.beginPath();
context.moveTo(200,200);
context.bezierCurveTo(350,200,450,450,800,500);
context.stroke();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/canvas2.html&quot;&gt;HTML5练习2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;3.把绘制的图像导出，并应用到其他地方&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var dataURL = canvas.get(0).toDataURL();
var img = $(&quot;&amp;lt;img&amp;gt;&amp;lt;/img&amp;gt;&quot;);
img.attr(&quot;src&quot;,dataURL);
canvas.replaceWith(img);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/canvas3.html&quot;&gt;HTML5练习3&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;4.对图片进行处理&lt;/h2&gt;

&lt;p&gt;在画布上绘制图片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var image = new Image();
image.src = &quot;example.jpg&quot;;
$(image).load(function(e) {
	//显示图像
    context.drawImage(image,0,0);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;对图片进行处理，可以对每个像素点进行操作，图片大的话，不推荐&lt;/h3&gt;

&lt;h3 id=&quot;section-7&quot;&gt;对图片马赛克化，风格化处理，是将图片分割，每个格子取一个像素点，用该颜色画一个图形取代原来的格子&lt;/h3&gt;

&lt;h3 id=&quot;section-8&quot;&gt;对图片作灰度处理是将图片每一个像素点，取通道均值赋给各个通道&lt;/h3&gt;

&lt;h3 id=&quot;section-9&quot;&gt;对图片反相是将各个通道值被255减之后赋回给各个通道&lt;/h3&gt;

&lt;h3 id=&quot;section-10&quot;&gt;之前的模糊算法是将每个像素点和周边像素点的值做正态分布加权平均然后再赋回给该像素点，做的运算更复杂&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/drawpicture.html&quot;&gt;HTML5练习4&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;5.动画&lt;/h2&gt;

&lt;h3 id=&quot;section-12&quot;&gt;加一个定时器，然后对画布进行绘制-擦除-绘制循环就是动画&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/anim.html&quot;&gt;HTML5练习5&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>HTML5绘图学习</title>
        <link>http://www.liuschen.com/2016/02/03/html5.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/03/html5.html</guid>
        <pubDate>Wed, 03 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;这几天花了点儿时间了解了下HTML5，为现有的工作拓宽一下思路，都说HTML5如何强大，之前只是听说，并没有太多的体会。用后才发现的确没有夸张，众所周知，过去网页上要想播放视频都是需要有flash插件的支持的，而flash插件则是由Adobe公司提供的，Adobe公司在图形图像处理方面表现出众，过去一直很关注它的几款产品的更新。一两年时间没注意，才发现Adobe竟然已经停止产品的迭代，转主要做服务了。而HTML5出来也很长时间了，我也是才深入的体会到它的强大，毕竟它取代了在网页上长久以来占据核心地位的flash。&lt;/p&gt;

&lt;p&gt;而对于我，主要发现有3点便利的地方:&lt;/p&gt;

&lt;p&gt;1.html5绘图后可以直接保存成为图片，好方便；&lt;/p&gt;

&lt;p&gt;2.html5绘图API的原理同android绘图一样，很多地方共通；&lt;/p&gt;

&lt;p&gt;3.html5可以对图片做处理，可以对视频做处理，可以做动画，可以写游戏，而不需要另加插件，大大提升了网页的拓展性；&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>卧狐</title>
        <link>http://www.liuschen.com/2016/01/31/fox3.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/31/fox3.html</guid>
        <pubDate>Sun, 31 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>白狐</title>
        <link>http://www.liuschen.com/2016/01/31/fox2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/31/fox2.html</guid>
        <pubDate>Sun, 31 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyj.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyl.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greym.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyo.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyr.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greys.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyt.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyw.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>狐</title>
        <link>http://www.liuschen.com/2016/01/31/fox1.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/31/fox1.html</guid>
        <pubDate>Sun, 31 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>梦花</title>
        <link>http://www.liuschen.com/2016/01/27/dream-flower.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/27/dream-flower.html</guid>
        <pubDate>Wed, 27 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;想写些小说,但是老实说,写出来老是缺少画面感,并且多半时候今天写了，明天就会看得不顺，所以作罢了好多次，但是如果一直不写，也就谈不上进步。所有权当练习表达了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;初生一觉醒来，发现自己正坐在大巴里，大巴没动，看着正在陆续上来找座位的同学，初生明白了自己还没走，是要去哪里，一时之间却始终想不起来。&lt;/p&gt;

&lt;p&gt;现在好像正值仲夏，烈日当空，蝉声的嘶鸣催动的空气中的燥热，在四处恣意的流动，弯曲了光线，仿佛用肉眼就能看到空气中那细小的流苏，灼人肌肤，燥人心房。&lt;/p&gt;

&lt;p&gt;初生想不起来自己是要去哪里，回家？亦或是离去，游玩？也可能是逃离。&lt;/p&gt;

&lt;p&gt;初生又打了个盹儿，梦里他看到一片圆形的雨云突然遮蔽了天空，四周顿时变得阴暗。初生来不及思考，只是见那雨云越来越厚，四周的空气也变的厚重起来，令他喘不过气。如果说此时的他的痛苦能够让他忘记思考，那么接下来他看到的也足以令他忘记这种苦痛的了，周遭的空气变得越发的重，突然，不可思议的事情发生了，初生隔着窗子外的建筑开始发生变化，掉落的砖瓦开始，重新砌好，因为年久剥落的涂料开始一点点的重新回到墙上，渐渐的，整个建筑焕然一新，只是这个过程却丝毫没有半分减缓的迹象，却仿佛更快了，建筑逐渐低矮，最后全部变成了堆积在一旁的砖瓦。又是一栋建筑在飞散的灰尘中瞬间立起，由旧变新，最后变化的速度太快，以至于仿佛本来是电影被点了快进一般却突然被人索性拖着进度条直溜的就朝尾声奔去了。&lt;/p&gt;

&lt;p&gt;初生隐隐约约明白了发生了什么。他睁开眼，大脑柔乎了一阵儿，仔细的观察了一下四周，一个激灵上来，瞬间清醒了好多，才明白眼前发生的不是梦。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实就是我昨天做的梦，因为梦里很玄妙的样子，印象很深，不是有妙笔生花一说吗？这可以叫妙梦生花，故曰:梦花。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>我对瀑布开发模式和敏捷开发模式的理解</title>
        <link>http://www.liuschen.com/2016/01/27/project-mode.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/27/project-mode.html</guid>
        <pubDate>Wed, 27 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;瀑布开发模式就是一种最常用的开发模型，因为这种开发方式不但简单直观而且大大便利了项目管理的运作。 瀑布开发模式可以令项目管理人员非常方便地把整个项目置于自己的掌握之下。瀑布开发模式限制了开发期间团队间的交互，评估起来相当方便，由于开发计划稳定而且几乎不会发生经常性的变化从而有效地简化了项目开发的管理工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;敏捷开发则是多种软件开发项目管理方法的集合，其中包括了XP、Scrum等十几种开发模式，这些开发方法有些共同点，比如重视响应变更，重视实现客户的价值，重视开发人员的自身发展等等，核心原则是主张简单，拥抱变化，快速反馈并注重开发的目的性，轻装前行，高质量的工作，使投资最大化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;严格瀑布开发模式，各个环节会依次有条不紊的进行，开发的生命周期时间上往往很好把控，所以它的优点是易于管理和掌控进度。但是因为开发的效果只有在项目完成后才能看到，对用户的反馈往往会滞后，并且如果项目前面环节没有做的很好，到了项目后期这种问题就会被指数性的放大，甚至到达bug的层面。各个开发团队之前缺乏交流也会是整个项目效率低下的一个原因。&lt;/p&gt;

&lt;p&gt;这种开发模式很受传统行业公司的青睐，原因大概就是这种管理模式符合传统项目的美学，严谨，规范，对时间的绝对把握，但是我个人却认为这种美学却不大符合互联网的思维。&lt;/p&gt;

&lt;p&gt;敏捷开发则是瀑布开发模式在互联网思维的进化，说是进化也许有些不妥，因为瀑布开发模式重在管理，易于驾驭，而敏捷开发，则是剥离了管理的外壳，把精力完全放在了个人，产品，和客户需求这个最重要的3个要素之上，并不好驾驭，如果你要管理整个项目，就必须要参与其中，并且具有指导其他成员的能力。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Android滤镜-快速模糊</title>
        <link>http://www.liuschen.com/2016/01/25/stackblur.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/25/stackblur.html</guid>
        <pubDate>Mon, 25 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;github上有一个stackblur的开源项目，可以对图片进行快速模糊处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有通过Java写的，而我主要看的是通过jni调用的c代码，其实算法都是一样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//bitmapOut ：bitmap图片
//radius模糊半径
//threadCount 线程总数
//threadIndex 第几个处理线程
//round 第几步


JNIEXPORT void JNICALL Java_luofeng_myjnitest_jni_JniHelper_toBlur(JNIEnv* env, jclass clzz, jobject bitmapOut, jint radius, jint threadCount, jint threadIndex, jint round) {
// Properties
AndroidBitmapInfo   infoOut;
void*               pixelsOut;

int ret;

// Get image info
if ((ret = AndroidBitmap_getInfo(env, bitmapOut, &amp;amp;infoOut)) != 0) {
    LOGE(&quot;AndroidBitmap_getInfo() failed ! error=%d&quot;, ret);
    return;
}

// Check image
if (infoOut.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {
    LOGE(&quot;Bitmap format is not RGBA_8888!&quot;);
    LOGE(&quot;==&amp;gt; %d&quot;, infoOut.format);
    return;
}

// Lock all images
if ((ret = AndroidBitmap_lockPixels(env, bitmapOut, &amp;amp;pixelsOut)) != 0) {
    LOGE(&quot;AndroidBitmap_lockPixels() failed ! error=%d&quot;, ret);
    return;
}

int h = infoOut.height;
int w = infoOut.width;
stackblurJob((unsigned char*)pixelsOut, w, h, radius, threadCount, threadIndex, round);
// Unlocks everything
AndroidBitmap_unlockPixels(env, bitmapOut);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，模糊半径是用来确定模糊的程度的，高斯模糊是通过每个像素点和周围像素点运算求平均值来实现的，这个模糊半径就是确定一个点的运算范围的。&lt;/p&gt;

&lt;p&gt;threadCount，threadIndex：外部通过n个线程来同时处理提速的。而内部传入这几个值是为了计算每个线程分别处理的区域的，和多线程下载类似。&lt;/p&gt;

&lt;p&gt;round：为1时是水平模糊，为2时是竖直模糊。&lt;/p&gt;

&lt;p&gt;Java层通过同时启动n个线程来处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static final int EXECUTOR_THREADS = Runtime.getRuntime().availableProcessors();
static final ExecutorService EXECUTOR = Executors.newFixedThreadPool(EXECUTOR_THREADS);

public Bitmap blur(Bitmap original, float radius) {
    Bitmap bitmapOut = original.copy(Bitmap.Config.ARGB_8888, true);

    int cores = EXECUTOR_THREADS;

    ArrayList&amp;lt;NativeTask&amp;gt; horizontal = new ArrayList&amp;lt;NativeTask&amp;gt;(cores);
    ArrayList&amp;lt;NativeTask&amp;gt; vertical = new ArrayList&amp;lt;NativeTask&amp;gt;(cores);
    for (int i = 0; i &amp;lt; cores; i++) {
        horizontal.add(new NativeTask(bitmapOut, (int) radius, cores, i, 1));
        vertical.add(new NativeTask(bitmapOut, (int) radius, cores, i, 2));
    }

    try {
        EXECUTOR.invokeAll(horizontal);
    } catch (InterruptedException e) {
        return bitmapOut;
    }

    try {
        EXECUTOR.invokeAll(vertical);
    } catch (InterruptedException e) {
        return bitmapOut;
    }
    return bitmapOut;
}

private static class NativeTask implements Callable&amp;lt;Void&amp;gt; {
    private final Bitmap _bitmapOut;
    private final int _radius;
    private final int _totalCores;
    private final int _coreIndex;
    private final int _round;

    public NativeTask(Bitmap bitmapOut, int radius, int totalCores, int coreIndex, int round) {
        _bitmapOut = bitmapOut;
        _radius = radius;
        _totalCores = totalCores;
        _coreIndex = coreIndex;
        _round = round;
    }

    @Override
    public Void call() throws Exception {
        JniHelper.toBlur(_bitmapOut, _radius, _totalCores, _coreIndex, _round);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是图片有时可能会很大，由于模糊就是丢失精度的操作，为了提高效率，可以先对图片进行缩放从而丢失部分像素精度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static Bitmap scaleBitmap(Bitmap bitmap,float scale) {
    Matrix matrix = new Matrix();
    matrix.postScale(scale,scale); //长和宽放大缩小的比例
    Bitmap resizeBmp = Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,true);
    return resizeBmp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提高了处理速度，而最终效果区别却不会太大。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/luofengliuchen/MyJniTest/tree/bulr&quot;&gt;Demo地址&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Android绘图-LOGO-实现3</title>
        <link>http://www.liuschen.com/2016/01/22/android-logo.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/22/android-logo.html</guid>
        <pubDate>Fri, 22 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;之前版本首先是对绘制圆环的各种方法进行分析，由于圆环要添加动画效果。所以最终选择了Path和Path相加减的方式得到想要的圆环，前半部分动画效果由于是分开的所以用了3个track来分别处理他们，而用一个handler定时器来触发并维持动画效果。后半部分动画由于是整体动画，所以我选择了对画布整体进行变换操作来实现该退出动画，又由于是对画布进行的操作，所以必须放在绘制图形前面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;再版，特殊情况:将内外圆的圆心统一设置为原点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog_logo.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
之前版本track1和track2以及track3内外圆的圆心是不同的。所以将圆环分成3个部分，才能使每一部分的间隙内外不至于差太大。之前右半部分的位移动画是靠圆心位置来定初始点和终点的。当然内外半径也可以做成动画效果。&lt;/p&gt;

&lt;p&gt;如果内外圆心统一定为原点，依然可以用圆心的移动来做动画,但是这时候环块之间的间隙就会像环的其他部分一样，呈向外发散状，所以这是就需要另外用一个路径将环块之间的间隙切出来。这里就需要用到几何学来画图了。&lt;br /&gt;
&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog_logo2.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图在坐标系统沿着最大半圆的切痕画一条过原点的直线AC，然后平移一段距离得到另一条直线BD，垂直于两条直线的距离为固定的值，即trans，通过函数可以得到两条直线:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public float line1(float x,float degree){
    double dX = new BigDecimal(String.valueOf(x)).doubleValue();
    double dDegree = new BigDecimal(String.valueOf(degree)).doubleValue();
    return (float)((Math.tan(Math.toRadians(dDegree)))*dX);
}


public float line2(float x,float degree,float trans){
    double dX = new BigDecimal(String.valueOf(x)).doubleValue();
    double dDegree = new BigDecimal(String.valueOf(degree)).doubleValue();
    double dTrans = new BigDecimal(String.valueOf(trans)).doubleValue();
    return (float)(Math.tan(Math.toRadians(dDegree))
            *(dX) - dTrans/(Math.sin(Math.toRadians(dDegree))));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算这两条直线是为了取得A,B,C,D点的，而其中X点可以任取，只要大于外圆半径就行，输入的degree是为了切取另外两个地方通用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog_logo3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过自取x从而得到y，就可以的到想要的用来切取圆环的四边形，上图中绘制的是环中最为难切得一个间隙，需要同时对上下两部分圆环进行切取，且比例不一。&lt;/p&gt;

&lt;p&gt;另外，需要注意的有两点：&lt;/p&gt;

&lt;p&gt;一是android中的坐标系y轴正向是向下的，而这个数学上标准的坐标系y轴是向上的，需要考虑并转换。&lt;/p&gt;

&lt;p&gt;二是直线与y轴呈的夹角&amp;amp;越小，取任意的x点，y=xtan&amp;amp;所得到的y偏差越大。因为x值固定，&amp;amp;角越小，y越趋近于无穷大，计算时本来可以忽略的近似误差也变的不可忽略。所以本来设定的trans值固定，但实际却是会随着&amp;amp;角而改变。所以最后对几个间隙分别设置了trans值，使它们外观上变得近似。&lt;/p&gt;

&lt;p&gt;至此，logo绘制完毕，可能通用性不强(中间其实我还是发现不少变化的)，但是做这个动画logo一波三折，中间是改了又改，而解决问题这个过程我想还是值得记录下来的。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>listview焦点冲突</title>
        <link>http://www.liuschen.com/2016/01/18/listview-focus.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/18/listview-focus.html</guid>
        <pubDate>Mon, 18 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;listView中经常出现焦点冲突问题，导致Item不可点击，解决方法是在条目Item的跟布局添加如下属性:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android:descendantFocusability=&quot;blocksDescendants&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该属性有3个值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	beforeDescendants：viewgroup会优先其子类控件而获取到焦点

    afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点

    blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在StringPicker中除了对NumberPicker中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mClazz.getMethod(&quot;setMaxValue&quot;, int.class).invoke(mInstance, values.length - 1);
mClazz.getMethod(&quot;setMinValue&quot;, int.class).invoke(mInstance, 0);
mClazz.getMethod(&quot;setDisplayedValues&quot;, String[].class).invoke(mInstance, new Object[]{values});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有setValue和getValue进行反射调用外，就是对这个属性的设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setDescendantFocusability
值为:
NumberPicker.FOCUS_BLOCK_DESCENDANTS
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>NumberPicker与StringPicker</title>
        <link>http://www.liuschen.com/2016/01/18/android-StringPicker.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/18/android-StringPicker.html</guid>
        <pubDate>Mon, 18 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;NumberPicker是一款开源的控件，被收入goole的android包里面，原本我以为它不支持不连续的数字组合，后来找到了StringPicker看了它的源码才知道里面用的也是NumberPicker。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;StringPicker里面用反射获取了并调用了setDisplayedValues的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	try {
            mClazz.getMethod(&quot;setMaxValue&quot;, int.class).invoke(mInstance, values.length - 1);
            mClazz.getMethod(&quot;setMinValue&quot;, int.class).invoke(mInstance, 0);
            mClazz.getMethod(&quot;setDisplayedValues&quot;, String[].class).invoke(mInstance, new Object[]{values});
        } catch (final Exception e) {
            throw new RuntimeException(e);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用来设置进去一个字符串数组。&lt;br /&gt;
因为setDisplayedValues这个方法并不是私有的所以可以直接调用修改，但是经过初步尝试，嵌入在dialog中的NumberPicker在构造方法中实例化后不能直接调用setDisplayedValues传入数组对其进行赋值操作。在这一步只能通过设置大小极值来获得一个连续区间，同时调用的setDisplayedValues不会起作用。必须将这一步作为一个方法分离，分开调用才能得到StringPicker的效果。&lt;/p&gt;

&lt;p&gt;这时，setValue和getValue的值需要在dialog中进行转换，因为NumberPicker可以直接传入和获取数字，但此时setValue传入的值需要转换成values数组对应元素的序号，同理getValue也是从NumberPicker中获取的序号，需要转化成values中对应的元素。&lt;/p&gt;

&lt;p&gt;单独分离的setValues方法:mElseNum是一个不连续的String数组，作为一个连续数字区间的额外补充。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void setValues(){
    values = new String[mMax-mMin+mElseNum.length+1];
    for (int i=0;i&amp;lt;mMax-mMin+mElseNum.length+1;i++){
        if(mMin+i&amp;lt;=mMax){
            values[i] = String.valueOf(mMin+i);
        }else{
            values[i] = String.valueOf(mElseNum[i-(mMax-mMin)-1]);
        }
    }
    numberPickerView.setMaxValue(mMax + mElseNum.length - mMin);
    numberPickerView.setMinValue(0);
    numberPickerView.setDisplayedValues(values);
    numberPickerView.setValue(currentValue);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Androidstudio下jni的一些问题</title>
        <link>http://www.liuschen.com/2016/01/15/NDK.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/15/NDK.html</guid>
        <pubDate>Fri, 15 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;android NDK 支持纯jni的方式构建app&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此处是AndroidStudio下构建jni程序方法，通用&lt;/p&gt;

&lt;p&gt;成功运行程序后，可以逐渐接触jni代码了。和熟悉AndroidStudio的过程一样，对工具的使用都是一个慢慢累积的过程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;试着将NDK android-ndk-r10e\samples下的代码在androidstudio下跑，果然没那么顺利。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;运行的是native-activity这个项目，遇到了如下错误:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;F:\androidstudio\JNIActivity\app\src\main\jni\main.c
Error:(27, 37) android_native_app_glue.h: No such file or directory
compilation terminated.
make.exe: *** [F:\androidstudio\JNIActivity\app\build\intermediates\ndk\debug\obj/local/arm64-v8a/objs/jniLibs/F_\androidstudio\JNIActivity\app\src\main\jni\main.o] Error 1
Error:Execution failed for task &#39;:app:compileDebugNdk&#39;.
&amp;gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &#39;command &#39;F:\BaiduYunDownload\android-ndk-r10e\ndk-build.cmd&#39;&#39; finished with non-zero exit value 2
Information:BUILD FAILED
Information:Total time: 0.89 secs
Information:2 errors
Information:0 warnings
Information:See complete output in console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网上大部分都是说在Android.mk文件里少了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;include $(BUILD_SHARED_LIBRARY)
$(call import-module,android/native_app_glue)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但我是拷贝的文件里面是有的，并且在已经通过编译的项目中加上上述依赖并引用该库依然没有通过编译。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以要找突破口&lt;br /&gt;
1.Android.mk是Android提供的一种makefile文件，多个模块的项目每个目录中定义对应的Android.mk文件（类似于上面的写法）， &lt;br /&gt;
最后，在根目录放置一个Android.mk文件,需要先明白里面变量的意义:&lt;a href=&quot;http://blog.csdn.net/ly131420/article/details/9619269&quot;&gt;Android.mk释义&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;后来绕过来了Android.mk是eclipse下组织编译JNI的文件，而studio使用gradle来组织编译的&lt;br /&gt;
在项目下的build.gradle文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android {
	defaultConfig {
        ndk {
            moduleName &quot;jniLibs&quot;   // 生成so文件的名字
            ldLibs &quot;EGL&quot;, &quot;GLESv3&quot;, &quot;dl&quot;, &quot;log&quot;	   // Link with these libraries!
            stl &quot;stlport_shared&quot;					  // Use shared stlport library
    }
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即是用来编译的设置，之前在android.mk下的设置并没有起到相应的作用，现在要做的就是如何将引用的外部库添加到这个位置。&lt;br /&gt;
暂时没有想到对应方法。&lt;/p&gt;

&lt;p&gt;最后可以手动编译出.so文件供程序调用。&lt;br /&gt;
然后运行成功了。&lt;/p&gt;

&lt;p&gt;总结:&lt;br /&gt;
当前我运行jni没有通过gradle中的设置实现全自动的编译打包&lt;br /&gt;
还是要切换到jni的目录下先运行ndk-build命令生成so动态库，当然前提是先把ndk-build命令添加到path路径中去会方便些。&lt;/p&gt;

&lt;p&gt;在androidstudio的配置文件中需要加3个地方&lt;/p&gt;

&lt;p&gt;1.gradle.properties中添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.useDeprecatedNdk=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.module下的build.gradle下添加两处代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android {
    defaultConfig {
        ndk {
            moduleName &quot;jniLibs&quot;  // 1.生成so文件的名字，和system.loadlibrary引入的名字相同
        }
    }

	//2.定义jni的so文件的存放目录，缺的话生成so文件程序也找不到
    sourceSets.main {
        jni.srcDirs = [] // This prevents the auto generation of Android.mk
	//        sourceSets.main.jni.srcDirs = []
        jniLibs.srcDir &#39;src/main/libs&#39; // This is not necessary unless you have precompiled libraries in your project.
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Android绘图-LOGO-实现2</title>
        <link>http://www.liuschen.com/2016/01/14/draw-a-logo.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/14/draw-a-logo.html</guid>
        <pubDate>Thu, 14 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;首先对半圆的绘制考虑到之前版本并不能精确的满足绘制的要求（内圆和外圆并不一定是同心圆，用Path.FillType.EVEN_ODD来实现的话可能会产生多余的部分），要是能够像ps中单纯对路径进行相加相减就好了。所幸在Path中找到了一个Op的枚举类型（和FillType距离不远），最终就是用Path的这个属性完美的解决了这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@TargetApi(Build.VERSION_CODES.LOLLIPOP)
private void drawRing(Canvas canvas, Paint paint,float interX, float innerY,float outerX, float outerY,float startAngle,float sweepAngle,float inner_circle,float outter_circle) {

    Path outterpath = new Path();

    outterpath.moveTo(outerX, outerY);
    outterpath.lineTo(outerX, outerY - outter_circle);
    outterpath.arcTo(outerX - outter_circle, outerY - outter_circle, outerX + outter_circle, outerY + outter_circle, startAngle, sweepAngle, true);
    outterpath.lineTo(outerX, outerY);
    outterpath.close();

    Path innerpath = new Path();

    innerpath.moveTo(interX, innerY);
    innerpath.lineTo(interX, innerY - inner_circle);
    innerpath.arcTo(interX - inner_circle, innerY - inner_circle, interX + inner_circle, innerY + inner_circle, startAngle, -360, true);
    innerpath.lineTo(interX, innerY);
    innerpath.close();

    outterpath.op(innerpath,Path.Op.DIFFERENCE);
    canvas.drawPath(outterpath,paint);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终整个动画由一个定时器控制速率，通过定时重绘View实现了整个动画，最后的退出动画是通过对画布操作完成的（对画布的操作必须在绘制之前）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);

    canvas.translate(TRACK1_OUTTER_CIRCLE * 1.5f, TRACK1_OUTTER_CIRCLE * 1.5f);
    scaleAnim(canvas);

    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    paint.setStyle(Paint.Style.FILL);
    track1(canvas, paint);
    track2(canvas, paint);
    track3(canvas, paint);

    if(!isTimerRunning){
        mHandler.post(mRunnable);
        isTimerRunning = true;
    }else{
        mHandler.postDelayed(mRunnable, mFrameTime);
    }
    if(mFrameNumber&amp;gt;60){
        resetAnim();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Android绘图-LOGO-实现1</title>
        <link>http://www.liuschen.com/2016/01/12/draw-a-logo.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/12/draw-a-logo.html</guid>
        <pubDate>Tue, 12 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;整体通过继承View来绘制自定义的logo；&lt;br /&gt;
logo动画分为3个部分，所以通过3个track来实现对3部分动画的分别控制，3个track函数分别在ondraw里面绘制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    track1(canvas);
    track2(canvas);
    track3(canvas);
    invalidate();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.绘制圆环&lt;/p&gt;

&lt;p&gt;圆环的绘制是基于android Java层的API来实现的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void drawArc(float left, float top, float right, float bottom, float startAngle,
            float sweepAngle, boolean useCenter, @NonNull Paint paint) {
        native_drawArc(mNativeCanvasWrapper, left, top, right, bottom, startAngle, sweepAngle,
                useCenter, paint.getNativeInstance());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中前四个参数：&lt;br /&gt;
左上右下是绘制图形的左边上边右边下边分别与右上角为原点的笛卡尔坐标系两坐标轴的距离&lt;br /&gt;
startAngle:是扇形开始的角度；&lt;br /&gt;
sweepAngle:扇形扫过的角度；&lt;strong&gt;正数为顺时针，负数为逆时针(之所以这样,是因为AndroidView中的坐标是y轴正向向下)&lt;/strong&gt;&lt;br /&gt;
useCenter:是否包以圆心为中心点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paint.setColor(Color.RED);
canvas.drawArc(-OUTTER_CIRCLE, -OUTTER_CIRCLE, OUTTER_CIRCLE, OUTTER_CIRCLE, 270, endAngle, true, paint);
paint.setColor(Color.BLACK);
canvas.drawArc(-INNER_CIRCLE, -INNER_CIRCLE, INNER_CIRCLE, INNER_CIRCLE, 270,endAngle, true, paint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法，会将圆环中心的颜色填充，不再支持透明，对于画圆环除了以上一种方法外，还可以用path来画&lt;br /&gt;
但是path添加圆弧存在一个问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Path outterpath = new Path();
outterpath.addArc(-OUTTER_CIRCLE, -OUTTER_CIRCLE, OUTTER_CIRCLE, OUTTER_CIRCLE, 270, endAngle);
outterpath.addArc(-INNER_CIRCLE, -INNER_CIRCLE, INNER_CIRCLE, INNER_CIRCLE, 270, endAngle);
outterpath.setFillType(Path.FillType.EVEN_ODD);
canvas.drawPath(outterpath,paint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是addARC里面没有useCenter参数，默认是不以圆心为中心画的，达不到效果要求。所以要画圆弧需要自己画，比较麻烦。&lt;br /&gt;
贝塞尔曲线可以考虑，但太麻烦，需要计算。&lt;br /&gt;
QuadTo一阶贝塞尔曲线&lt;br /&gt;
CubicTo二阶贝塞尔曲线&lt;br /&gt;
带r的跟去掉字母r的相对应的函数一样，但是都会考虑提供的点跟轮廓的相对位置。&lt;/p&gt;

&lt;p&gt;可以依然用path但换一种方式来实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	Path outterpath = new Path();

    outterpath.moveTo(0, 0);
    outterpath.lineTo(0, -OUTTER_CIRCLE);
    outterpath.arcTo(-OUTTER_CIRCLE, -OUTTER_CIRCLE, OUTTER_CIRCLE, OUTTER_CIRCLE, 270, endAngle, true);
    outterpath.lineTo(0, 0);
    outterpath.close();

    Path innerpath = new Path();

    innerpath.moveTo(0, 0);
    innerpath.lineTo(0, -INNER_CIRCLE);
    innerpath.arcTo(-INNER_CIRCLE, -INNER_CIRCLE, INNER_CIRCLE, INNER_CIRCLE, 270, endAngle, true);
    innerpath.lineTo(0, 0);
    innerpath.close();

    outterpath.setFillType(Path.FillType.EVEN_ODD);
    outterpath.addPath(innerpath);
    canvas.drawPath(outterpath,paint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.最后的动画效果同过定时重绘来实现&lt;/p&gt;

&lt;p&gt;总的来说，在Java层通过API来调用已有的绘图函数画自己想要的图形不难，里面既有现成的绘制图形的函数比如圆，矩形等等，也有Path工具可以定制自己想要的图形，和Photoshop的绘图原理基本相同。还有贝塞尔曲线，只要数学可以，任何图形都可以画。&lt;/p&gt;

&lt;p&gt;项目地址:&lt;a href=&quot;https://github.com/luofengliuchen/QJLogo&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>android图像处理:像素过滤</title>
        <link>http://www.liuschen.com/2016/01/11/deal-with-pix.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/11/deal-with-pix.html</guid>
        <pubDate>Mon, 11 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;第一次用photoshop时给我印象最深的是里面的&lt;strong&gt;色相/饱和度&lt;/strong&gt;功能&lt;/p&gt;

  &lt;p&gt;用它来替换图片中的颜色特别方便。要知道我最早用来处理图片用的是微软的画图工具，在高放大率下对每一个像素点进行处理，现在想想也是醉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在做程序，更多的方法也变的可行，毕竟在计算机上做的一切事情都是各种程序在下面默默付出辛劳的结果。虽然语言不同，但转换成二进制都是执行的同一件事。不同的只是有些语言，为了追求个别功能，扩展性等等再转换成底层语言时绕了远路，所以才有了效率上的差异。&lt;/p&gt;

&lt;p&gt;我现在要写的是在Android上对图像像素的过滤。&lt;/p&gt;

&lt;p&gt;首先如果要对bitmap里面的像素点进行操作需要将里面的一个参数&lt;/p&gt;

&lt;p&gt;mIsMutable设置为true&lt;br /&gt;
可以在copy Bitmap时设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bitmap.copy(bitmap.getConfig(), true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而我最开始是在写的工具方法里面通过反射设置的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	try {
        Field mIsMutable = Bitmap.class.getDeclaredField(&quot;mIsMutable&quot;);
        mIsMutable.setAccessible(true);
        mIsMutable.setBoolean(bitmap,true);
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就对bitmap图像进行点的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int bitmapWidth = bitmap.getWidth();
int bitmapHeight = bitmap.getHeight();
for (int i = 0; i &amp;lt; bitmapHeight; i++) {
    for (int j = 0; j &amp;lt; bitmapWidth; j++) {
        int singleColor = bitmap.getPixel(j,i);
        if(addFilter(singleColor,filter)){
            continue;
        }else{
            bitmap.setPixel(j, i, color);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中添加了一个过滤函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static boolean addFilter(int singleColor,ColorFilter filter) {

    int a = Color.alpha(singleColor);
    switch(filter){
        case TRANSLATE:
            if(a==0){
                return true;
            }else{
                break;
            }
        case WHITE:
            if(singleColor == 0xffffffff){
                return true;
            }else{
                break;
            }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个过滤函数可以自由定制，我这里添加了一个透明像素点和白色像素的的忽略。可以自由选择并且修改。因为要对每一个像素点进行操作，肯定需要耗费CPU资源，至于到什么程度，我也没测就是了。这个在可以在需要严控应用资源大小时用到。内部对颜色不多的图片进行色相操作，满足对资源的需求。&lt;/p&gt;

&lt;p&gt;现在已知操作后图片以原分辨率显示会有明显锯齿，还没想到合适的解决办法。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/luofengliuchen/AndroidColorMaster&quot;&gt;本篇DEMO地址&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>