<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>落风的博客</title>
    <link>http://www.liuschen.com</link>
    <description>落风的博客</description>
    
      <item>
        <title>Android数据库和Bean的交互</title>
        <link>http://www.liuschen.com/2016/04/29/sqlite.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/04/29/sqlite.html</guid>
        <pubDate>Fri, 29 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Android中数据库使用的轻量级的Sqlite数据库，创建数据库的过程，因为系统都封装好了，所以比较简单。只要继承SQLiteOpenHelper即可。然后再写一些增删改查的函数就可以了。&lt;/p&gt;

&lt;p&gt;Android系统对数据的操作，就我的理解，主要是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;网络请求-内存(数据模型)-本地存储
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 JSON数据-本地Bean对象-数据库 则是其中一种通用的路子。&lt;br /&gt;
json到Bean对象以及Bean和数据库的交互转化，虽然可以针对每一种数据模型来实现，但是那样做未免太麻烦，同时也会浪费太多不必要的精力。&lt;br /&gt;
fastjson（阿里工程师开发的）和GSON(谷歌带的)就是很好的实现了json和Bean转化的框架，里面都是用的反射来实现的，其实也只能用反射，只不过牛逼的框架一般做的都很全，在性能上也处理的比较的当，我等也能佩服。&lt;/p&gt;

&lt;p&gt;当然我现在要说的是数据库和Bean的交互，因为时间比较匆忙，也没精力找别人写好的框架用，所以自己就简单的写了个。&lt;/p&gt;

&lt;p&gt;用到了反射，但是因为数据库中的字段名称和我自己的命名习惯不符(数据库字段名是已经定好的),所以便退而求其次，用了注解。首先，定义了一个注解:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DBDataType {
    /**为数据库中的信息，type=0时表示该为主键，-1为默认值，1,2,3,4为预留值，普通值请从5起，
     * 并且表示了该列值在数据库中的添加顺序*/
    int type() default -1;

    /**数据库中的元素名*/
    String elementName() default &quot;&quot;;
    /**数据库中的元素类型*/
    String elementType() default &quot;text&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着在建立的Bean对象中，对每一个field添加注解:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@DBDataType(type = 0, elementName = &quot;ID&quot;)
public String id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中type是字段在数据库建表时的排列顺序，从5开始，0时表示该字段定义为主键，1，2，3，4为预留值，elementName表示该值在表中的字段名，其实还有一个elementType表示字段的属性，默认是文本类型，其他可以指定&lt;/p&gt;

&lt;p&gt;然后就是关键代码，对sql语句进行拼接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {

		/**通过反射获取局部变量*/
		Field[] fields = clazz.getDeclaredFields();
		/**存储列的序号*/
		int[] cloumns = new int[fields.length];
		HashMap&amp;lt;Integer,DBDataType&amp;gt; hashMap = new HashMap&amp;lt;Integer,DBDataType&amp;gt;();
		/**建立序号到每个field对应的注解DBDataType映射关系*/
		for (int i=0;i&amp;lt;fields.length;i++){
			DBDataType dbDataTypes = fields[i].getAnnotation(DBDataType.class);
			int cloumnNumber = dbDataTypes.type();
			cloumns[i] = cloumnNumber;
			hashMap.put(cloumnNumber,dbDataTypes);
		}
		/**
		 * 对序号进行排序
		 * */
		Arrays.sort(cloumns);

		/**开始拼接sql语句*/
		String sqlfont = &quot;create table if not exists &quot; + tableName + &quot; (&quot;;
		String sqlContent = &quot;&quot;;
		String sqlOver = &quot;)&quot;;

		for(int i=0;i&amp;lt;cloumns.length;i++){

			String elementType = hashMap.get(cloumns[i]).elementType();
			String elementName = hashMap.get(cloumns[i]).elementName();

			if(cloumns[i]==0){
				//该值为主键
				sqlContent += elementName + &quot; &quot; + elementType + &quot; primary key&quot; +&quot;,&quot;;
			}else{
				sqlContent += elementName + &quot; &quot; + elementType +((i==cloumns.length-1)?&quot;&quot;:&quot;,&quot;);
			}

		}
		String sql = sqlfont + sqlContent + sqlOver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里传入的clazz为一个Bean对象，就是通过对field进行注解标记的Bean，这些代码是封装到数据库操作类中的，所以之后创建表，只需要传入一个Bean对象即可。对数据库的插入，查询也是，只需用注解和反射去写好一个通用的方法即可。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>荒原日记-习惯</title>
        <link>http://www.liuschen.com/2016/04/25/wildernessdiary-habby.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/04/25/wildernessdiary-habby.html</guid>
        <pubDate>Mon, 25 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;站在现在的角度看过去的自己，不得不说，我，是一个奇怪的小孩。&lt;/p&gt;

&lt;p&gt;“这是一个美丽的世界，关闭。”也许你会好奇我说的这句话的意义，但是正如我所说，我以前是一个很奇怪的孩子，而这句话就是我常常在心中念叨的一句咒语。它的功用在于它能帮我清除心中的杂念，当然，如果杂念太多那我就还需要点时间好好捋捋。你可能会说，你看，这孩子把自己当机器了，还要关机开机呢。当不当机器不好说，不过强迫症肯定是有的，这个习惯不知道是从什么时候开始的，我也不清楚是从什么时候结束的。我总是强迫自己尽善尽美的处理遇到的任何事情，所以在此期间没丢过东西也没遗忘过什么。像提前设定的程序，日子平平淡淡，却也无味至极，甚至对我来说，知道别人不会这样做，而对这种习惯和未来联系到的日子充满恐惧。&lt;/p&gt;

&lt;p&gt;后来证明，这种担心多余了，甚至现在的我竟然搞不清，我舍弃掉的这个习惯是否一并带走了我更重要的东西。我试着和过去划清界限，并不是要证明我的进步或是堕落，只是我想，该静下心好好重新的认识一下自己了，不是自我剖析，而是以朋友的身份~&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>荒原日记-开篇</title>
        <link>http://www.liuschen.com/2016/04/16/wildernessdiary-start.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/04/16/wildernessdiary-start.html</guid>
        <pubDate>Sat, 16 Apr 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;我从哪里来，又往哪里去？在我7，8岁的时候，常常在考虑这个问题，因为小，不理解前路漫长，总是觉得人生不过弹指岁月，所以总是充满了对死亡的恐惧。&lt;/p&gt;

&lt;p&gt;都说时间能抚平一切，当我将藏在幼小心中的想法封印，企图在时间之海中将它沉溺，缓缓流逝的时间却告诉我，它可以使炽烈的热恋冷却，将绝对冰点的感情消融，却无法使我遗忘自己追问本源的这种淡淡的想法。&lt;/p&gt;

&lt;p&gt;慢慢的，我也逐渐找到了自己的答案，也许每个人来到世上都是为了寻找到这一个答案，只是或许有些人不愿意分享，在喧闹的城市抑或宁静的乡村，只有当你在午夜，万物沉寂，而你独自一人时才会有机会偶然想起你此刻立于此地的意义。我们每个人都有一个答案，只是有些人一生可能都不会想起。幸运抑或不幸，只是人对自己过往的追问和总结罢了。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Visual Studio开发Android程序</title>
        <link>http://www.liuschen.com/2016/02/21/studio.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/21/studio.html</guid>
        <pubDate>Sun, 21 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;早就听说微软在新版的visual studio上增强了对移动开发的便利，而且提供的Android模拟器比Google提供的性能上要好很多，所以周末就弄了一下，简单说一下遇到的问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;visual-studio-2015&quot;&gt;1.安装Visual Studio 2015&lt;/h1&gt;

&lt;p&gt;安装Visual Studio 2015时，要联网下载很多东西，虽然安装包已经不小了，很显然，安装的要更多。装了近10个小时（只能说我够闲），完了后仍然提示我说android 的sdk和一个git相关的什么东西没装上，最重要的是sdk没装上肯定就不能开发Android了，下载是不现实的，所以就用了我本地存放的sdk,更改sdk路径的设置需要依次点击&lt;/p&gt;

&lt;h3 id=&quot;cross-platform&quot;&gt;工具-选项-Cross Platform&lt;/h3&gt;

&lt;p&gt;就能看到，然后勾选Android SDK前面的选择框就可以更改路径了。&lt;/p&gt;

&lt;p&gt;调试Android程序，如果是真机调试一般选ARM，连接上手机开发者一般就能看到设备了，如果是window的虚拟机则是选x86。&lt;/p&gt;

&lt;h1 id=&quot;window&quot;&gt;2.安装window的虚拟机&lt;/h1&gt;

&lt;p&gt;安装window提供的Android虚拟机需要window对Hyper-V的支持，这个功能家庭版上没有，至少要专业版才行，然后再控制面板中打开该功能，电脑在此期间会重启来完成功能的添加。之后就能安装虚拟机了，如果没有添加该功能直接安装会出错，安装虚拟机要升级到最新版本，安装完后就能使用了。&lt;/p&gt;

&lt;p&gt;window提供的Android虚拟机的基础Hyper-V感觉和workstation以及virtualbox差不多，但是毕竟是在window系统自家提供的功能，相必必有一些过人的地方，只是Android的模拟器虽然速度比Google自己的要快很多，但是总有些似曾相识的感觉，之前用sdk自带的虚拟机，在window上其实也是可以加速的，也就是单独针对x86架构有加速的独立window程序可以安装，和这个差不多，都是针对同一种架构的优化，从这个意义上来讲，其实这个虚拟机对我做开发意义并不是太大。&lt;/p&gt;

&lt;h1 id=&quot;visual-studio-2015-1&quot;&gt;3.Visual Studio 2015编程&lt;/h1&gt;

&lt;p&gt;我最期待的是Visual Studio 2015用c++来架构程序的效果，新建工程时,我发现没有Java构建代码的模板，好像在这里面C#是Java的等效语言，除此之外就是Visual c++，在里面的跨平台中还是找到了一个模板可以构建Java的Android程序，同时也可以建c++共享库，也有纯c++来开发Android的模板，遗憾的是，我看过之后发现这个模板是完全照抄的NDK中的示例源码，可见这并不是visualstudio的主要功能。其中也有Apache Cordova的模板，用网页前端语言构建app的框架，这个可以使代码可以轻松的跨平台，在节省开发成本上具有广泛意义，但传统的仍然认为这种方式在运行速度上仍不理想，所以现在还是以Java+html5混合编程为主。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>C++学习整理</title>
        <link>http://www.liuschen.com/2016/02/19/c++.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/19/c++.html</guid>
        <pubDate>Fri, 19 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;打印字符串&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
extern int pow(int, int);
int main()
{
	int val = 2;
	int exp = 15;
	cout &amp;lt;&amp;lt; &quot;The Powers of 2\n&quot;;
	for ( int cnt=0; cnt &amp;lt;= exp; ++cnt )
	cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; &quot;: &quot;
	&amp;lt;&amp;lt; pow(val, cnt) &amp;lt;&amp;lt; endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;inline&quot;&gt;内联函数inline,最好放在头文件中&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;inline int min( int v1, int v2 ) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;extern-c&quot;&gt;链接指示符 extern “c”,告诉编译器函数编写语言类型&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// 单一语句形式的链接指示符
extern &quot;C&quot; void exit(int);
// 复合语句形式的链接指示符
extern &quot;C&quot; {
int printf( const char* ... );
int scanf( const char* ... );
}
// 复合语句形式的链接指示符
extern &quot;C&quot; {
	#include &amp;lt;cmath&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链接指示符不能出现在函数体中，并且如果需要c调用c++程序也需要在前面生命链接指示符,链接指示符如果声明多次，可以只声明一次，自动作用于后面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ---- myMath.h ----
extern &quot;C&quot; double calc( double );
// ---- myMath.C ----
// 在 Math.h 中的calc() 的声明
#include &quot;myMath.h&quot;
// 定义了 extern &quot;C&quot; calc() 函数
// calc() 可以从C 程序中被调用
double calc( double dparm ) { // ...
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Socket编程笔记</title>
        <link>http://www.liuschen.com/2016/02/17/socket.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/17/socket.html</guid>
        <pubDate>Wed, 17 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;android中的socket连接HttpURLConnection来实现的。而HttpClient是对HttpURLConnection做了一层封装，HttpClient6.0之后被废弃了,推荐用HttpURLConnection。而HttpURLConnection继承于HttpConnection，两者都是抽象类，想了解其中的实现原理，就要深入的剖析一下代码，但是其中一些关键的方法如connect()方法却是抽象的，所以需要找到它的实现类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，是找到connect()的实现，最可能的是在URL类中找线索，因为是在url中获取的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;URL url = new URL(httpUrl);//此处有异常抛出
HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，URL中却显示streamHandler中取得的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public URLConnection openConnection() throws IOException {
    return streamHandler.openConnection(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而streamHandler这个实例所属的对象实现的方法仍然是抽象的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected abstract URLConnection openConnection(URL u) throws IOException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说单独知道这个出处还不够，还需要知道streamHandler是在什么时候被赋值的，这时候可以注意到URL中有URLStreamHandlerFactory streamHandlerFactory的工厂声明，点击去发现还是抽象的(晕)，然后顺着streamHandlerFactory就找到了下面的方法，是对streamHandler赋值的关键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; void setupStreamHandler() {
    // Check for a cached (previously looked up) handler for
    // the requested protocol.
    streamHandler = streamHandlers.get(protocol);
    if (streamHandler != null) {
        return;
    }

    // If there is a stream handler factory, then attempt to
    // use it to create the handler.
    if (streamHandlerFactory != null) {
        streamHandler = streamHandlerFactory.createURLStreamHandler(protocol);
        if (streamHandler != null) {
            streamHandlers.put(protocol, streamHandler);
            return;
        }
    }

    // Check if there is a list of packages which can provide handlers.
    // If so, then walk this list looking for an applicable one.
    String packageList = System.getProperty(&quot;java.protocol.handler.pkgs&quot;);
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    if (packageList != null &amp;amp;&amp;amp; contextClassLoader != null) {
        for (String packageName : packageList.split(&quot;\\|&quot;)) {
            String className = packageName + &quot;.&quot; + protocol + &quot;.Handler&quot;;
            try {
                Class&amp;lt;?&amp;gt; c = contextClassLoader.loadClass(className);
                streamHandler = (URLStreamHandler) c.newInstance();
                if (streamHandler != null) {
                    streamHandlers.put(protocol, streamHandler);
                }
                return;
            } catch (IllegalAccessException ignored) {
            } catch (InstantiationException ignored) {
            } catch (ClassNotFoundException ignored) {
            }
        }
    }

    // Fall back to a built-in stream handler if the user didn&#39;t supply one
    if (protocol.equals(&quot;file&quot;)) {
        streamHandler = new FileHandler();
    } else if (protocol.equals(&quot;ftp&quot;)) {
        streamHandler = new FtpHandler();
    } else if (protocol.equals(&quot;http&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;https&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpsHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;jar&quot;)) {
        streamHandler = new JarHandler();
    }
    if (streamHandler != null) {
        streamHandlers.put(protocol, streamHandler);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看注释区分，总共分为4个部分&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;第一部分&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt; streamHandler = streamHandlers.get(protocol);
    if (streamHandler != null) {
        return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是取缓存的streamHandler实例，如果已经存在了，就不会往下执行了。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;第二部分&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;if (streamHandlerFactory != null) {
        streamHandler = streamHandlerFactory.createURLStreamHandler(protocol);
        if (streamHandler != null) {
            streamHandlers.put(protocol, streamHandler);
            return;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明显用到了工厂，所以需要知道工厂的出处，是这里:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Sets the stream handler factory for this VM.
 *
 * @throws Error if a URLStreamHandlerFactory has already been installed
 *     for the current VM.
 */
public static synchronized void setURLStreamHandlerFactory(URLStreamHandlerFactory factory) {
    if (streamHandlerFactory != null) {
        throw new Error(&quot;Factory already set&quot;);
    }
    streamHandlers.clear();
    streamHandlerFactory = factory;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得了，这个是公共的设置方法:Sets the stream handler factory for this VM顿时感觉好高大上，总之，不通。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;第三部分&lt;/h1&gt;

&lt;p&gt;在系统属性指定的包中寻找相应的URLStreamHandler处理类，因为没怎么用过这种方法，值得注意，不过不是这里的重点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String packageList = System.getProperty(&quot;java.protocol.handler.pkgs&quot;);
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    if (packageList != null &amp;amp;&amp;amp; contextClassLoader != null) {
        for (String packageName : packageList.split(&quot;\\|&quot;)) {
            String className = packageName + &quot;.&quot; + protocol + &quot;.Handler&quot;;
            try {
                Class&amp;lt;?&amp;gt; c = contextClassLoader.loadClass(className);
                streamHandler = (URLStreamHandler) c.newInstance();
                if (streamHandler != null) {
                    streamHandlers.put(protocol, streamHandler);
                }
                return;
            } catch (IllegalAccessException ignored) {
            } catch (InstantiationException ignored) {
            } catch (ClassNotFoundException ignored) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-3&quot;&gt;第四部分&lt;/h1&gt;

&lt;p&gt;再不成只能做最后的挣扎了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (protocol.equals(&quot;file&quot;)) {
        streamHandler = new FileHandler();
    } else if (protocol.equals(&quot;ftp&quot;)) {
        streamHandler = new FtpHandler();
    } else if (protocol.equals(&quot;http&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;https&quot;)) {
        try {
            String name = &quot;com.android.okhttp.HttpsHandler&quot;;
            streamHandler = (URLStreamHandler) Class.forName(name).newInstance();
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    } else if (protocol.equals(&quot;jar&quot;)) {
        streamHandler = new JarHandler();
    }
    if (streamHandler != null) {
        streamHandlers.put(protocol, streamHandler);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中https依然是在特定包com.android.okhttp.HttpsHandler中找&lt;br /&gt;
而其他的则是直接new一个对象，这些对象的导入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import libcore.net.url.FileHandler;
import libcore.net.url.FtpHandler;
import libcore.net.url.JarHandler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在androidstudio中显示的是灰色的，表示没有没有提供相关源码，至此，线索全断了，不过通过这些查找也并非没有收获。&lt;/p&gt;

&lt;p&gt;一直以来找的URLStreamHandler streamHandler其实是一个协议流处理器，每一个&lt;br /&gt;
对应一个URLHttpConnection，至于实现它们的源码，限于sdk中源码包没有所以没看到，不过却找到了出处，网上查了一下知道了其中实现也是通过Socket，大体的关系总是理清了。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;总结：&lt;/h1&gt;

&lt;p&gt;1.URLHttpConnection和URLHttpsConnection都继承了URLConnection都是基于应用层对http或https协议的封装，里面通信还是用的socket&lt;/p&gt;

&lt;p&gt;2.URLConnection里面调用的Socket是传输层对应用层提供的抽象接口,是下层黑箱的一个门面，其中包括的协议有传输层的TCP协议和UDP协议，以及网络层的IP协议。当然也可以直接用socket通信，可以在应用层通过socket来架构网络框架，但是需要考虑多线程，以及状态监控（其实用URLConnection也要自己写多线程）等因素，更省流量以及更可控，但是如果要用到http等应用层协议，还是用URLConnection方便些。&lt;/p&gt;

&lt;p&gt;3.每个URLConnection都有一个相对应的URLStreamHandler实例用来处理协议，URL类中还有关于file，ftp,jar对应类型的URLStreamHandler应该也是一些协议的封装的处理器，也就是说每一种协议需要对应一种处理模型。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;最后，温习一下网络模型：&lt;/h1&gt;

&lt;h2 id=&quot;section-6&quot;&gt;应用层-应用层，表示层，会话层&lt;/h2&gt;

&lt;h2 id=&quot;section-7&quot;&gt;传输层-传输层&lt;/h2&gt;

&lt;h2 id=&quot;section-8&quot;&gt;网际互联层-网络层&lt;/h2&gt;

&lt;h2 id=&quot;section-9&quot;&gt;网络接入层-数据链路层，物理层&lt;/h2&gt;

</description>
      </item>
    
      <item>
        <title>git常用命令行</title>
        <link>http://www.liuschen.com/2016/02/16/apk.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/16/apk.html</guid>
        <pubDate>Tue, 16 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;首先将git目录下的cmd配置到环境变量，打开cmd就可以使用git命令，git仓库就是目录下隐藏的.git文件夹&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.bootcss.com/p/git-guide/&quot;&gt;git简易使用说明(外链)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;创建版本库&lt;br /&gt;
git init&lt;/p&gt;

&lt;p&gt;查看分支&lt;br /&gt;
git branch&lt;br /&gt;
git branch -a&lt;/p&gt;

&lt;p&gt;从远端拉取&lt;br /&gt;
git clone 地址&lt;/p&gt;

&lt;p&gt;显示状态&lt;br /&gt;
git status&lt;/p&gt;

&lt;p&gt;修改加入缓存&lt;br /&gt;
git add filename&lt;/p&gt;

&lt;p&gt;修改提交到HEAD(本地库最近版本)&lt;br /&gt;
git commit -m “提交注释内容”&lt;/p&gt;

&lt;p&gt;创建分支并切换  单独切换分支 删除本地分支&lt;br /&gt;
git checkout -b name&lt;br /&gt;
git checkout name&lt;/p&gt;

&lt;p&gt;还没提交到远端的分支可以直接删除&lt;br /&gt;
git branch -d name&lt;/p&gt;

&lt;p&gt;更新不需要密码&lt;br /&gt;
git pull&lt;br /&gt;
提交到远端库&lt;br /&gt;
git push&lt;/p&gt;

&lt;p&gt;本地有一个远端的拷贝，和远端同步&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>android反编译</title>
        <link>http://www.liuschen.com/2016/02/14/apk.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/14/apk.html</guid>
        <pubDate>Sun, 14 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;android程序是apk格式，其实就是一个压缩包，可以直接解压，但是直接解压后可以直接得到资源文件，以及c的动态链接库，但是打开布局文件却是乱码，并且没有的到直接可读的java源码，所以需要用到反编译相关的软件，而android逆向助手就是一个整合了多个反编译工具的软件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog-apk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，反编译apk和反编译dex直接提取的都是smali格式的文件&lt;/p&gt;

&lt;h3 id=&quot;androidjava&quot;&gt;获得android程序源码中java格式的源码：&lt;/h3&gt;
&lt;p&gt;通过dex转成jar格式   通过js-gui可以直接读取其中的内容，如果里面代码经过了混淆，则被混淆过的代码名称均用无意义的英文字母来命名，因为更改了名称，所以该部分代码不能用到反射。&lt;/p&gt;

&lt;h3 id=&quot;androidxml&quot;&gt;获得android程序源码中的xml文件：&lt;/h3&gt;

&lt;p&gt;反编译apk中就能获得xml文件用的APKTool工具&lt;br /&gt;
没有说明出错了, apktool.jar版本没更，跟不上android的版本&lt;br /&gt;
直接替换反编译却又不能出结果&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;结果：&lt;/h3&gt;

&lt;p&gt;直接用里面的apktool d 文件 来解析xml文件&lt;br /&gt;
用完整工具可以解析src中的Java文件&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>html5内嵌入android</title>
        <link>http://www.liuschen.com/2016/02/05/html5-2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/05/html5-2.html</guid>
        <pubDate>Fri, 05 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;首先Android的目录中建立一个assets文件夹，将canvas.html文件放入其中，然后添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	WebView webview = (WebView) findViewById(R.id.wv);
    webview.getSettings().setJavaScriptEnabled(true);
    webview.setBackgroundColor(Color.TRANSPARENT);
    webview.loadUrl(&quot;file:///android_asset/canvas2.html&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地也需要加入权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以在就可以写一些js代码来嵌入Android应用，所以我又写了一个简单的loading用来做嵌入Android的测试：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/blog-web-html5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/luofengliuchen/AndroidWebTest&quot;&gt;Android测试Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;loading本来是想做的像玉器一样的，但是太耗费时间，所以配色上可能不太理想。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/loading.html&quot;&gt;loading动画网页预览&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>HTML5绘图学习记录</title>
        <link>http://www.liuschen.com/2016/02/04/html5-1.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/04/html5-1.html</guid>
        <pubDate>Thu, 04 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;首先先要导入jquery.min.js&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1.绘制矩形，线条，圆形&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;//获取canvas对象
var canvas  = $(&quot;#mycanvas&quot;);
//的到2D context
var context = canvas.get(0).getContext(&quot;2d&quot;);

//矩形
context.fillStyle = &quot;rgb(255,0,0)&quot;;
context.strokeStyle = &quot;rgb(0,255,0)&quot;;
context.fillRect(40,40,100,100);
context.strokeRect(140,140,100,100);

//直线
context.beginPath();
context.moveTo(240,240);
context.lineTo(600,500);
context.closePath();
context.stroke();

//绘制圆形
context.beginPath();
context.arc(500,500,50,0,Math.PI/2,false);
context.lineTo(500,500);
context.closePath();
context.stroke();

//绘制字体
var text  = &quot;this is html5&quot;;
context.font = &quot;italic 30px serif&quot;;
context.fillText(text,40,300);	
context.lineWidth = 1;
context.strokeText(text,40,400);

//擦除操作
context.clearRect(200,200,100,100);

//擦除操作
context.clearRect(200,200,100,100);
//context.clearRect(0,0,canvas.width(),canvas.height());

//重置所有canvas上的元素
canvas.attr(&quot;width&quot;,canvas.width());
canvas.attr(&quot;height&quot;,canvas.height());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/canvas.html&quot;&gt;HTML5练习1&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.绘图状态的保存，画布变换，阴影，渐变和贝塞尔曲线&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;保存和应用就是一个对栈进行存取的操作，存的是画布的状态信息，如颜色，阴影，变换信息等等，先进后出，后进先出&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;context.save();
context.restore();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;变换，对画布的操作，只对之后绘制的图形产生影响，可以把画布当成有多个图层，每次绘制都会新开一个图层，而变换就是对之后新开图层产生影响，绘制目标完后可以对画布进行还原&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//平移
context.translate(100,100);
//缩放，注意缩放中心
context.scale(1,1.5);
//缩放，注意旋转中心
context.rotate(Math.PI/12);

//全局阿尔法值
context.globalAlpha = 0.5;
//合成模式，PS上的混合模式
context.globalCompositeOperation = &quot;xor&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;渐变的应用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//线性渐变
context.restore();
var gradient = context.createLinearGradient(0,0,0,canvas.height());
gradient.addColorStop(0,&quot;rgb(0,0,0)&quot;);
gradient.addColorStop(1,&quot;rgb(255,0,0)&quot;);
context.fillStyle = gradient;
context.fillRect(100,100,100,100);

//放射渐变
var canvasCentreX = canvas.width()/2;
var canvasCentreY = canvas.height()/2;
var gradient = context.createRadialGradient(canvasCentreX,canvasCentreY,0,canvasCentreX,canvasCentreY,250);
gradient.addColorStop(0,&quot;rgb(0,0,0)&quot;);
gradient.addColorStop(1,&quot;rgb(150,150,150)&quot;);
context.fillStyle = gradient;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;贝塞尔曲线&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//一阶贝塞尔曲线
context.lineWidth = 15;
context.beginPath();
context.moveTo(200,200);
context.quadraticCurveTo(350,200,450,450);
context.stroke();
//三阶贝塞尔曲线
context.lineWidth = 15;
context.beginPath();
context.moveTo(200,200);
context.bezierCurveTo(350,200,450,450,800,500);
context.stroke();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/canvas2.html&quot;&gt;HTML5练习2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;3.把绘制的图像导出，并应用到其他地方&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var dataURL = canvas.get(0).toDataURL();
var img = $(&quot;&amp;lt;img&amp;gt;&amp;lt;/img&amp;gt;&quot;);
img.attr(&quot;src&quot;,dataURL);
canvas.replaceWith(img);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/canvas3.html&quot;&gt;HTML5练习3&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;4.对图片进行处理&lt;/h2&gt;

&lt;p&gt;在画布上绘制图片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var image = new Image();
image.src = &quot;example.jpg&quot;;
$(image).load(function(e) {
	//显示图像
    context.drawImage(image,0,0);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;对图片进行处理，可以对每个像素点进行操作，图片大的话，不推荐&lt;/h3&gt;

&lt;h3 id=&quot;section-7&quot;&gt;对图片马赛克化，风格化处理，是将图片分割，每个格子取一个像素点，用该颜色画一个图形取代原来的格子&lt;/h3&gt;

&lt;h3 id=&quot;section-8&quot;&gt;对图片作灰度处理是将图片每一个像素点，取通道均值赋给各个通道&lt;/h3&gt;

&lt;h3 id=&quot;section-9&quot;&gt;对图片反相是将各个通道值被255减之后赋回给各个通道&lt;/h3&gt;

&lt;h3 id=&quot;section-10&quot;&gt;之前的模糊算法是将每个像素点和周边像素点的值做正态分布加权平均然后再赋回给该像素点，做的运算更复杂&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/drawpicture.html&quot;&gt;HTML5练习4&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;5.动画&lt;/h2&gt;

&lt;h3 id=&quot;section-12&quot;&gt;加一个定时器，然后对画布进行绘制-擦除-绘制循环就是动画&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../../html5/anim.html&quot;&gt;HTML5练习5&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>HTML5绘图学习</title>
        <link>http://www.liuschen.com/2016/02/03/html5.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/02/03/html5.html</guid>
        <pubDate>Wed, 03 Feb 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;这几天花了点儿时间了解了下HTML5，为现有的工作拓宽一下思路，都说HTML5如何强大，之前只是听说，并没有太多的体会。用后才发现的确没有夸张，众所周知，过去网页上要想播放视频都是需要有flash插件的支持的，而flash插件则是由Adobe公司提供的，Adobe公司在图形图像处理方面表现出众，过去一直很关注它的几款产品的更新。一两年时间没注意，才发现Adobe竟然已经停止产品的迭代，转主要做服务了。而HTML5出来也很长时间了，我也是才深入的体会到它的强大，毕竟它取代了在网页上长久以来占据核心地位的flash。&lt;/p&gt;

&lt;p&gt;而对于我，主要发现有3点便利的地方:&lt;/p&gt;

&lt;p&gt;1.html5绘图后可以直接保存成为图片，好方便；&lt;/p&gt;

&lt;p&gt;2.html5绘图API的原理同android绘图一样，很多地方共通；&lt;/p&gt;

&lt;p&gt;3.html5可以对图片做处理，可以对视频做处理，可以做动画，可以写游戏，而不需要另加插件，大大提升了网页的拓展性；&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>想要冬眠的狐狸</title>
        <link>http://www.liuschen.com/2016/01/31/fox3.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/31/fox3.html</guid>
        <pubDate>Sun, 31 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;有人说它在笑，你说呢&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyz7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>擅长卖萌的狐狸</title>
        <link>http://www.liuschen.com/2016/01/31/fox2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/31/fox2.html</guid>
        <pubDate>Sun, 31 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;萌神小白狐，其实有两只，一只在前台接客（卖萌），另一只嘛，在后台装石头（睡觉），对，就是后面白色的那个大鹅卵石。&lt;/p&gt;

  &lt;p&gt;看见了没！它狐狸尾巴渐渐露出来了。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyj.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyl.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greym.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyo.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyr.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greys.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyt.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyw.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>正在找东西的狐狸</title>
        <link>http://www.liuschen.com/2016/01/31/fox1.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/31/fox1.html</guid>
        <pubDate>Sun, 31 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;如果不是在动物园看到的，我还以为这货是狗呢，扒洞贼溜。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_grey9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpui7.com1.z0.glb.clouddn.com/photo-fox_greyg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>梦花</title>
        <link>http://www.liuschen.com/2016/01/27/dream-flower.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/27/dream-flower.html</guid>
        <pubDate>Wed, 27 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;想写些小说,但是老实说,写出来老是缺少画面感,并且多半时候今天写了，明天就会看得不顺，所以作罢了好多次，但是如果一直不写，也就谈不上进步。所有权当练习表达了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;初生一觉醒来，发现自己正坐在大巴里，大巴没动，看着正在陆续上来找座位的同学，初生明白了自己还没走，是要去哪里，一时之间却始终想不起来。&lt;/p&gt;

&lt;p&gt;现在好像正值仲夏，烈日当空，蝉声的嘶鸣催动的空气中的燥热，在四处恣意的流动，弯曲了光线，仿佛用肉眼就能看到空气中那细小的流苏，灼人肌肤，燥人心房。&lt;/p&gt;

&lt;p&gt;初生想不起来自己是要去哪里，回家？亦或是离去，游玩？也可能是逃离。&lt;/p&gt;

&lt;p&gt;初生又打了个盹儿，梦里他看到一片圆形的雨云突然遮蔽了天空，四周顿时变得阴暗。初生来不及思考，只是见那雨云越来越厚，四周的空气也变的厚重起来，令他喘不过气。如果说此时的他的痛苦能够让他忘记思考，那么接下来他看到的也足以令他忘记这种苦痛的了，周遭的空气变得越发的重，突然，不可思议的事情发生了，初生隔着窗子外的建筑开始发生变化，掉落的砖瓦开始，重新砌好，因为年久剥落的涂料开始一点点的重新回到墙上，渐渐的，整个建筑焕然一新，只是这个过程却丝毫没有半分减缓的迹象，却仿佛更快了，建筑逐渐低矮，最后全部变成了堆积在一旁的砖瓦。又是一栋建筑在飞散的灰尘中瞬间立起，由旧变新，最后变化的速度太快，以至于仿佛本来是电影被点了快进一般却突然被人索性拖着进度条直溜的就朝尾声奔去了。&lt;/p&gt;

&lt;p&gt;初生隐隐约约明白了发生了什么。他睁开眼，大脑柔乎了一阵儿，仔细的观察了一下四周，一个激灵上来，瞬间清醒了好多，才明白眼前发生的不是梦。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实就是我昨天做的梦，因为梦里很玄妙的样子，印象很深，不是有妙笔生花一说吗？这可以叫妙梦生花，故曰:梦花。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      </item>
    
      <item>
        <title>我对瀑布开发模式和敏捷开发模式的理解</title>
        <link>http://www.liuschen.com/2016/01/27/project-mode.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/27/project-mode.html</guid>
        <pubDate>Wed, 27 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;瀑布开发模式就是一种最常用的开发模型，因为这种开发方式不但简单直观而且大大便利了项目管理的运作。 瀑布开发模式可以令项目管理人员非常方便地把整个项目置于自己的掌握之下。瀑布开发模式限制了开发期间团队间的交互，评估起来相当方便，由于开发计划稳定而且几乎不会发生经常性的变化从而有效地简化了项目开发的管理工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;敏捷开发则是多种软件开发项目管理方法的集合，其中包括了XP、Scrum等十几种开发模式，这些开发方法有些共同点，比如重视响应变更，重视实现客户的价值，重视开发人员的自身发展等等，核心原则是主张简单，拥抱变化，快速反馈并注重开发的目的性，轻装前行，高质量的工作，使投资最大化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;严格瀑布开发模式，各个环节会依次有条不紊的进行，开发的生命周期时间上往往很好把控，所以它的优点是易于管理和掌控进度。但是因为开发的效果只有在项目完成后才能看到，对用户的反馈往往会滞后，并且如果项目前面环节没有做的很好，到了项目后期这种问题就会被指数性的放大，甚至到达bug的层面。各个开发团队之前缺乏交流也会是整个项目效率低下的一个原因。&lt;/p&gt;

&lt;p&gt;这种开发模式很受传统行业公司的青睐，原因大概就是这种管理模式符合传统项目的美学，严谨，规范，对时间的绝对把握，但是我个人却认为这种美学却不大符合互联网的思维。&lt;/p&gt;

&lt;p&gt;敏捷开发则是瀑布开发模式在互联网思维的进化，说是进化也许有些不妥，因为瀑布开发模式重在管理，易于驾驭，而敏捷开发，则是剥离了管理的外壳，把精力完全放在了个人，产品，和客户需求这个最重要的3个要素之上，并不好驾驭，如果你要管理整个项目，就必须要参与其中，并且具有指导其他成员的能力。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Android滤镜-快速模糊</title>
        <link>http://www.liuschen.com/2016/01/25/stackblur.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/25/stackblur.html</guid>
        <pubDate>Mon, 25 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;github上有一个stackblur的开源项目，可以对图片进行快速模糊处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有通过Java写的，而我主要看的是通过jni调用的c代码，其实算法都是一样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//bitmapOut ：bitmap图片
//radius模糊半径
//threadCount 线程总数
//threadIndex 第几个处理线程
//round 第几步


JNIEXPORT void JNICALL Java_luofeng_myjnitest_jni_JniHelper_toBlur(JNIEnv* env, jclass clzz, jobject bitmapOut, jint radius, jint threadCount, jint threadIndex, jint round) {
// Properties
AndroidBitmapInfo   infoOut;
void*               pixelsOut;

int ret;

// Get image info
if ((ret = AndroidBitmap_getInfo(env, bitmapOut, &amp;amp;infoOut)) != 0) {
    LOGE(&quot;AndroidBitmap_getInfo() failed ! error=%d&quot;, ret);
    return;
}

// Check image
if (infoOut.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {
    LOGE(&quot;Bitmap format is not RGBA_8888!&quot;);
    LOGE(&quot;==&amp;gt; %d&quot;, infoOut.format);
    return;
}

// Lock all images
if ((ret = AndroidBitmap_lockPixels(env, bitmapOut, &amp;amp;pixelsOut)) != 0) {
    LOGE(&quot;AndroidBitmap_lockPixels() failed ! error=%d&quot;, ret);
    return;
}

int h = infoOut.height;
int w = infoOut.width;
stackblurJob((unsigned char*)pixelsOut, w, h, radius, threadCount, threadIndex, round);
// Unlocks everything
AndroidBitmap_unlockPixels(env, bitmapOut);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，模糊半径是用来确定模糊的程度的，高斯模糊是通过每个像素点和周围像素点运算求平均值来实现的，这个模糊半径就是确定一个点的运算范围的。&lt;/p&gt;

&lt;p&gt;threadCount，threadIndex：外部通过n个线程来同时处理提速的。而内部传入这几个值是为了计算每个线程分别处理的区域的，和多线程下载类似。&lt;/p&gt;

&lt;p&gt;round：为1时是水平模糊，为2时是竖直模糊。&lt;/p&gt;

&lt;p&gt;Java层通过同时启动n个线程来处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static final int EXECUTOR_THREADS = Runtime.getRuntime().availableProcessors();
static final ExecutorService EXECUTOR = Executors.newFixedThreadPool(EXECUTOR_THREADS);

public Bitmap blur(Bitmap original, float radius) {
    Bitmap bitmapOut = original.copy(Bitmap.Config.ARGB_8888, true);

    int cores = EXECUTOR_THREADS;

    ArrayList&amp;lt;NativeTask&amp;gt; horizontal = new ArrayList&amp;lt;NativeTask&amp;gt;(cores);
    ArrayList&amp;lt;NativeTask&amp;gt; vertical = new ArrayList&amp;lt;NativeTask&amp;gt;(cores);
    for (int i = 0; i &amp;lt; cores; i++) {
        horizontal.add(new NativeTask(bitmapOut, (int) radius, cores, i, 1));
        vertical.add(new NativeTask(bitmapOut, (int) radius, cores, i, 2));
    }

    try {
        EXECUTOR.invokeAll(horizontal);
    } catch (InterruptedException e) {
        return bitmapOut;
    }

    try {
        EXECUTOR.invokeAll(vertical);
    } catch (InterruptedException e) {
        return bitmapOut;
    }
    return bitmapOut;
}

private static class NativeTask implements Callable&amp;lt;Void&amp;gt; {
    private final Bitmap _bitmapOut;
    private final int _radius;
    private final int _totalCores;
    private final int _coreIndex;
    private final int _round;

    public NativeTask(Bitmap bitmapOut, int radius, int totalCores, int coreIndex, int round) {
        _bitmapOut = bitmapOut;
        _radius = radius;
        _totalCores = totalCores;
        _coreIndex = coreIndex;
        _round = round;
    }

    @Override
    public Void call() throws Exception {
        JniHelper.toBlur(_bitmapOut, _radius, _totalCores, _coreIndex, _round);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是图片有时可能会很大，由于模糊就是丢失精度的操作，为了提高效率，可以先对图片进行缩放从而丢失部分像素精度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static Bitmap scaleBitmap(Bitmap bitmap,float scale) {
    Matrix matrix = new Matrix();
    matrix.postScale(scale,scale); //长和宽放大缩小的比例
    Bitmap resizeBmp = Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,true);
    return resizeBmp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提高了处理速度，而最终效果区别却不会太大。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/luofengliuchen/MyJniTest/tree/bulr&quot;&gt;Demo地址&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>listview焦点冲突</title>
        <link>http://www.liuschen.com/2016/01/18/listview-focus.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/18/listview-focus.html</guid>
        <pubDate>Mon, 18 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;listView中经常出现焦点冲突问题，导致Item不可点击，解决方法是在条目Item的跟布局添加如下属性:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android:descendantFocusability=&quot;blocksDescendants&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该属性有3个值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	beforeDescendants：viewgroup会优先其子类控件而获取到焦点

    afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点

    blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在StringPicker中除了对NumberPicker中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mClazz.getMethod(&quot;setMaxValue&quot;, int.class).invoke(mInstance, values.length - 1);
mClazz.getMethod(&quot;setMinValue&quot;, int.class).invoke(mInstance, 0);
mClazz.getMethod(&quot;setDisplayedValues&quot;, String[].class).invoke(mInstance, new Object[]{values});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有setValue和getValue进行反射调用外，就是对这个属性的设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setDescendantFocusability
值为:
NumberPicker.FOCUS_BLOCK_DESCENDANTS
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>NumberPicker与StringPicker</title>
        <link>http://www.liuschen.com/2016/01/18/android-StringPicker.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/18/android-StringPicker.html</guid>
        <pubDate>Mon, 18 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;NumberPicker是一款开源的控件，被收入goole的android包里面，原本我以为它不支持不连续的数字组合，后来找到了StringPicker看了它的源码才知道里面用的也是NumberPicker。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;StringPicker里面用反射获取了并调用了setDisplayedValues的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	try {
            mClazz.getMethod(&quot;setMaxValue&quot;, int.class).invoke(mInstance, values.length - 1);
            mClazz.getMethod(&quot;setMinValue&quot;, int.class).invoke(mInstance, 0);
            mClazz.getMethod(&quot;setDisplayedValues&quot;, String[].class).invoke(mInstance, new Object[]{values});
        } catch (final Exception e) {
            throw new RuntimeException(e);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用来设置进去一个字符串数组。&lt;br /&gt;
因为setDisplayedValues这个方法并不是私有的所以可以直接调用修改，但是经过初步尝试，嵌入在dialog中的NumberPicker在构造方法中实例化后不能直接调用setDisplayedValues传入数组对其进行赋值操作。在这一步只能通过设置大小极值来获得一个连续区间，同时调用的setDisplayedValues不会起作用。必须将这一步作为一个方法分离，分开调用才能得到StringPicker的效果。&lt;/p&gt;

&lt;p&gt;这时，setValue和getValue的值需要在dialog中进行转换，因为NumberPicker可以直接传入和获取数字，但此时setValue传入的值需要转换成values数组对应元素的序号，同理getValue也是从NumberPicker中获取的序号，需要转化成values中对应的元素。&lt;/p&gt;

&lt;p&gt;单独分离的setValues方法:mElseNum是一个不连续的String数组，作为一个连续数字区间的额外补充。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void setValues(){
    values = new String[mMax-mMin+mElseNum.length+1];
    for (int i=0;i&amp;lt;mMax-mMin+mElseNum.length+1;i++){
        if(mMin+i&amp;lt;=mMax){
            values[i] = String.valueOf(mMin+i);
        }else{
            values[i] = String.valueOf(mElseNum[i-(mMax-mMin)-1]);
        }
    }
    numberPickerView.setMaxValue(mMax + mElseNum.length - mMin);
    numberPickerView.setMinValue(0);
    numberPickerView.setDisplayedValues(values);
    numberPickerView.setValue(currentValue);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Android绘图-LOGO兼容低版本</title>
        <link>http://www.liuschen.com/2016/01/15/draw-a-logo2.html</link>
        <guid isPermaLink="true">http://www.liuschen.com/2016/01/15/draw-a-logo2.html</guid>
        <pubDate>Fri, 15 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;最开始被带沟里了，走了不少弯路，兼容方法:通过圆弧相接画圆环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void drawRing(Canvas canvas, Paint paint,float interX, float innerY,float outerX, float outerY,float outerStartAngle,float outerSweepAngle,float innerStartAngle,float innerSweepAnglefloat ,float inner_circle,float outter_circle) {

        Path mPath = new Path();
        arcTo(mPath,outerX,outerY,outter_circle,outerStartAngle,outerSweepAngle,false);
        arcTo(mPath,interX,innerY,inner_circle,innerStartAngle+innerSweepAnglefloat,-innerSweepAnglefloat,false);
        mPath.close();
        canvas.drawPath(mPath,paint);

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造的方法同html5中的对应方法用相似的参数，只是最后forceMoveTo是是否强制封闭圆弧，和js中的最后参数控制绘制顺逆方向不同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 通过已知圆心半径和夹角画圆心
 * */
private void arcTo(Path path ,float circleX,float circleY,float circleR, float startAngle,
                   float sweepAngle, boolean forceMoveTo){

    float left = circleX - circleR;
    float right = circleX + circleR;
    float top = circleY -circleR;
    float bottom = circleY + circleR;

    path.arcTo(new RectF(left, top, right, bottom), startAngle,
            sweepAngle, forceMoveTo);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
  </channel>
</rss>